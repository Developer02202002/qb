/*
  +----------------------------------------------------------------------+
  | PHP Version 5                                                        |
  +----------------------------------------------------------------------+
  | Copyright (c) 1997-2012 The PHP Group                                |
  +----------------------------------------------------------------------+
  | This source file is subject to version 3.01 of the PHP license,      |
  | that is bundled with this package in the file LICENSE, and is        |
  | available through the world-wide-web at the following url:           |
  | http://www.php.net/license/3_01.txt                                  |
  | If you did not receive a copy of the PHP license and are unable to   |
  | obtain it through the world-wide-web, please send a note to          |
  | license@php.net so we can mail you a copy immediately.               |
  +----------------------------------------------------------------------+
  | Author: Chung Leong <cleong@cal.berkeley.edu>                        |
  +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include "qb.h"
#include "qb_interpreter_gcc.h"

#define op1	(*op1_ptr)
#define op2	(*op2_ptr)
#define op3	(*op3_ptr)
#define op4	(*op4_ptr)
#define op5	(*op5_ptr)
#define res		(*res_ptr)

void ZEND_FASTCALL qb_run(qb_interpreter_context *__restrict cxt) {
	
	if(cxt) {
		register void *__restrict op_handler;
		register int8_t *__restrict instruction_pointer;
		int8_t *__restrict segments[MAX_SEGMENT_COUNT];
		int8_t *__restrict segment0;
		int32_t segment_expandable[MAX_SEGMENT_COUNT];
		uint32_t segment_element_counts[MAX_SEGMENT_COUNT];
		uint32_t selector, index, index_index, size_index;
		uint32_t string_length;
		uint32_t vector_count, matrix1_count, matrix2_count, mmult_res_count;
		uint32_t op1_start_index, op2_start_index, op3_start_index, op4_start_index, op5_start_index;
		uint32_t op1_count, op2_count, op3_count, op4_count, op5_count;
		uint32_t res_start_index, res_count, res_count_before;
		USE_TSRM
		
		{
			uint32_t i;
			instruction_pointer = cxt->function->instructions;
			op_handler = *((void **) instruction_pointer);
			instruction_pointer += sizeof(void *);
			// copy values from cxt onto the stack so they can be accessed without two second deferences
			for(i = 0; i < cxt->storage->segment_count; i++) {
				qb_memory_segment *segment = &cxt->storage->segments[i];
				segments[i] = segment->memory;
				segment_element_counts[i] = *segment->array_size_pointer;
				segment_expandable[i] = (segment->flags & QB_SEGMENT_EXPANDABLE);
				// set the pointers in the segment structure to local variables here so we can update
				// them as well when we expand the segment
				segment->stack_ref_memory = &segments[i];
				segment->stack_ref_element_count = &segment_element_counts[i];
			}
			// store pointer to segment 0 in a separate variable to enable better optimization
			// since segment 0 and 1 will never be enlarged, we don't have to worry about it changing
			segment0 = segments[0];
			goto *op_handler;
		}
		
		label_NOP:
		op_handler = ((qb_instruction_0 *) instruction_pointer)->next_handler;
		{
			
		}
		instruction_pointer += sizeof(qb_instruction_0);
		goto *op_handler;
		
		label_JMP:
		op_handler = ((qb_instruction_jump_0 *) instruction_pointer)->next_handler;
		{
		}
		instruction_pointer = ((qb_instruction_jump_0 *) instruction_pointer)->instruction_pointer;
		goto *op_handler;
		
		label_RET:
		{
		}
		goto label_exit;
		
		label_EXIT_I32:
		{
			int32_t *op1_ptr;
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			EG(exit_status) = op1;
			zend_bailout();
		}
		
		label_FCALL_VAR:
		op_handler = ((qb_instruction_fcall *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_fcall *) instruction_pointer)->line_number
			uint32_t symbol_index = ((qb_instruction_fcall *) instruction_pointer)->symbol_index;
			uint32_t argument_count = ((qb_instruction_fcall *) instruction_pointer)->argument_count;
			uint32_t *operands = ((qb_instruction_fcall *) instruction_pointer)->operands, *op;
			uint32_t i;
			zend_function *function = cxt->function->external_symbols[symbol_index]->pointer;
			qb_initialize_function_call(cxt, function, argument_count, PHP_LINE_NUMBER);
			cxt->argument_address = &cxt->value_address;
			cxt->value_address.segment_selector = QB_SELECTOR_VARIABLE;
			for(i = 0, op = operands; i < argument_count; i++) {
				op += qb_decode_fcall_variable_operand(cxt, segments, op);
				qb_copy_argument(cxt, i);
			}
			qb_execute_function_call(cxt);
			for(i = 0, op = operands; i < argument_count + 1; i++) {
				op += qb_decode_fcall_variable_operand(cxt, segments, op);
				qb_resync_argument(cxt, i);
			}
			qb_finalize_function_call(cxt);
			if(cxt->exception_encountered) {
				goto label_exit;
			}
			instruction_pointer += sizeof(((qb_instruction_fcall *) instruction_pointer)->next_handler) + ((qb_instruction_fcall *) instruction_pointer)->operand_size;
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_FCALL_MIX:
		op_handler = ((qb_instruction_fcall *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_fcall *) instruction_pointer)->line_number
			uint32_t symbol_index = ((qb_instruction_fcall *) instruction_pointer)->symbol_index;
			uint32_t argument_count = ((qb_instruction_fcall *) instruction_pointer)->argument_count;
			uint32_t *operands = ((qb_instruction_fcall *) instruction_pointer)->operands, *op;
			uint32_t i;
			zend_function *function = cxt->function->external_symbols[symbol_index]->pointer;
			qb_initialize_function_call(cxt, function, argument_count, PHP_LINE_NUMBER);
			for(i = 0, op = operands; i < argument_count; i++) {
				op += qb_decode_fcall_mix_operand(cxt, segments, op);
				qb_copy_argument(cxt, i);
			}
			qb_execute_function_call(cxt);
			for(i = 0, op = operands; i < argument_count + 1; i++) {
				op += qb_decode_fcall_mix_operand(cxt, segments, op);
				qb_resync_argument(cxt, i);
			}
			qb_finalize_function_call(cxt);
			if(cxt->exception_encountered) {
				goto label_exit;
			}
			instruction_pointer += sizeof(((qb_instruction_fcall *) instruction_pointer)->next_handler) + ((qb_instruction_fcall *) instruction_pointer)->operand_size;
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_INIT:
		op_handler = ((qb_instruction_branch_0 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			if(cxt->storage->flags & QB_STORAGE_STATIC_INITIALIZED) {
				condition = 1;
			} else {
				condition = 0;
				cxt->storage->flags |= QB_STORAGE_STATIC_INITIALIZED;
			}
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_0 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_0 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_0 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_T_I32_VAR:
		op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int32_t *op1_ptr;
			index = ((qb_instruction_branch_1 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			condition = op1;
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_T_I32_ELV:
		op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_1_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int32_t *op1_ptr;
			selector = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			condition = op1;
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_F_I32_VAR:
		op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int32_t *op1_ptr;
			index = ((qb_instruction_branch_1 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			condition = !op1;
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_F_I32_ELV:
		op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_1_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int32_t *op1_ptr;
			selector = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			condition = !op1;
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_EQ_I32_I32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_EQ_I32_I32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_NE_I32_I32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_NE_I32_I32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LT_S32_S32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_S32_S32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_S32_S32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_S32_S32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_S32_S32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_S32_S32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_S32_S32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_S32_S32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_ADD_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 + op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_ADD_I32_I32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 + op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_I32_I32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_add_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 - op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SUB_I32_I32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 - op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_I32_I32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_divide_S32(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_divide_S32(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 % op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 % op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAC_S32_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 + (op2 * op3);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_MAC_S32_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_S32_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_NEG_I32_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = - op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_NEG_I32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = - op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_I32_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I32_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I32_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_I32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int32_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int32_t *) segment0) + index;
			
			++res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_INC_I32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			++res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_I32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_multiple_times_I32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_I32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int32_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int32_t *) segment0) + index;
			
			--res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_DEC_I32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			--res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_I32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_multiple_times_I32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_EQ_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_EQ_I32_I32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_I32_I32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S32(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_NE_I32_I32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_I32_I32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S32(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_S32_S32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_S32_S32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_S32_S32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S32(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_S32_S32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_S32_S32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_S32_S32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S32(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_SET_I32_I32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_equal_vector_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_SET_I32_I32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_not_equal_vector_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_S32_S32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_S32_S32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NOT_SET_I32_I32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_not_vector_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ANY_I32_I32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_any_I32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ANY_I32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_any_I32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ALL_I32_I32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_all_I32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ALL_I32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_all_I32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BW_AND_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 & op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_AND_I32_I32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 & op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_AND_I32_I32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_and_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_OR_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 | op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_OR_I32_I32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 | op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_OR_I32_I32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_or_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_XOR_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 ^ op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_XOR_I32_I32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 ^ op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_XOR_I32_I32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_xor_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_NOT_I32_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = ~op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BW_NOT_I32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = ~op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BW_NOT_I32_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_not_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SHL_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 << op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHL_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 << op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_left_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 >> op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHR_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = op1 >> op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_right_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AND_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 && op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_OR_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = op1 || op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_XOR_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = !op1 != !op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_NOT_I32_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = !op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ISSET_I32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index >= segment_element_counts[selector]) {
				op1_ptr = NULL;
			} else {
				op1_ptr = ((int32_t *) segments[selector]) + index;
			}
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNSET_I32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int32_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = 0;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_UNSET_I32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index < segment_element_counts[selector]) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_UNSET_I32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = ((uint32_t *) segment0)[size_index];
			if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MOV_I32_I08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = (int8_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I32_I08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = (int8_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I32_I08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_I32_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I32_I16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = (int16_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I32_I16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = (int16_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I32_I16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_I32_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S32_I64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S32_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S32_I64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S32_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S32_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S32_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S32_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S32_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S32_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_I32_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = !(!(op1));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BOOL_I32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = !(!(op1));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_I32_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_boolean_cast_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_S32_S32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (int32_t) abs(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ABS_S32_S32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (int32_t) abs(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_S32_S32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_abs_multiple_times_S32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_random_S32(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_RAND_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_random_S32(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_random_multiple_times_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_random_mt_S32(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MT_RAND_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_random_mt_S32(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_S32_S32_S32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_random_mt_multiple_times_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PRN_S32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int32_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			qb_do_print_variable_S32(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_S32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_print_variable_S32(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_S32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_S32_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S32_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_S32(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_S32(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S32_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_S32(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_S32(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S32_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_S32(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_S32(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_S32_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PACK_LE_I32_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint32_t *) res_ptr) = SWAP_LE_I32(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_LE_I32_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint32_t *) res_ptr) = SWAP_LE_I32(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_I32_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint32_t *) res_ptr) = SWAP_BE_I32(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_I32_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint32_t *) res_ptr) = SWAP_BE_I32(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_I32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			*((uint32_t *) &res) = SWAP_LE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			*((uint32_t *) &res) = SWAP_LE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_I32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			*((uint32_t *) &res) = SWAP_BE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			*((uint32_t *) &res) = SWAP_BE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SORT_S32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_S32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_S32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_S32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_S32_S32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_min_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_S32_S32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_max_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_S32_S32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_product_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_S32_S32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_sum_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_S32_S32_S32_S32_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_S32(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_range_S32(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_S32_S32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_array_min_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_S32_S32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_array_max_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_S32_S32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_array_product_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_S32_S32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			qb_do_array_sum_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_S32_S32_S32_S32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_S32(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_range_S32(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_I32(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I32_I32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_I32(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I32_I32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I32_I32_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_I32(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I32_I32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_I32(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I32_I32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_APOS_I32_I32_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_I32(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_ARPOS_I32_I32_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_from_end_I32(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AREV_I32_U32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_array_reverse_I32(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AINS_I32_U32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			res_count = res_count + op1_count;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_array_insert_I32(op1_ptr, op1_count, op2, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AUNIQ_I32_U32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_unique_element_count_I32(op1_ptr, op1_count, op2);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_array_unique_I32(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_IF_LT_U32_U32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_U32_U32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_U32_U32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_U32_U32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_U32_U32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_U32_U32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_U32_U32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_U32_U32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_MUL_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint32_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((uint32_t *) segment0) + index;
			
			qb_do_divide_U32(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			qb_do_divide_U32(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint32_t *) segment0) + index;
			
			res = op1 % op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			res = op1 % op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAC_U32_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((uint32_t *) segment0) + index;
			
			res = op1 + (op2 * op3);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_MAC_U32_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_U32_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((uint32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_LT_U32_U32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_U32_U32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_U32_U32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_U32(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_U32_U32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_U32_U32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_U32_U32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_U32(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_U32_U32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_U32_U32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint32_t *) segment0) + index;
			
			res = op1 << op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHL_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			res = op1 << op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_left_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint32_t *) segment0) + index;
			
			res = op1 >> op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHR_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			res = op1 >> op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_right_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_U32_I64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U32_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U32_I64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U32_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U32_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U32_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U32_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U32_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U32_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint32_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint32_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint32_t *) segment0) + index;
			
			qb_do_random_U32(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_RAND_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			qb_do_random_U32(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_random_multiple_times_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_U32_U32_U32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint32_t *) segment0) + index;
			
			qb_do_random_mt_U32(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MT_RAND_U32_U32_U32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			qb_do_random_mt_U32(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_U32_U32_U32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_random_mt_multiple_times_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_UTF8_DEC_U08_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_utf8_codepoint_count(op1_ptr, op1_count);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_utf8decode_U32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UTF8_ENC_U32_U08:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_utf8_encoded_length_U32(op1_ptr, op1_count);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_utf8encode_U32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PRN_U32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			uint32_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			qb_do_print_variable_U32(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_U32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			qb_do_print_variable_U32(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_U32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_U32_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U32_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_U32(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_U32(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U32_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_U32(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_U32(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U32_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_U32(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_U32(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_U32_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SORT_U32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_U32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_U32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_U32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_U32_U32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint32_t *) segment0) + index;
			
			qb_do_array_min_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_U32_U32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint32_t *) segment0) + index;
			
			qb_do_array_max_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_U32_U32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint32_t *) segment0) + index;
			
			qb_do_array_product_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_U32_U32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint32_t *) segment0) + index;
			
			qb_do_array_sum_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_U32_U32_S32_U32_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *op3_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_U32(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_range_U32(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_U32_U32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			qb_do_array_min_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_U32_U32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			qb_do_array_max_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_U32_U32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			qb_do_array_product_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_U32_U32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			qb_do_array_sum_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_U32_U32_S32_U32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			uint32_t *op2_ptr;
			int32_t *op3_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_U32(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_range_U32(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_IF_EQ_I08_I08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_EQ_I08_I08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_NE_I08_I08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_NE_I08_I08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LT_S08_S08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_S08_S08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_S08_S08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_S08_S08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_S08_S08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_S08_S08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_S08_S08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_S08_S08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_ADD_I08_I08_I08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1 + op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_ADD_I08_I08_I08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1 + op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_I08_I08_I08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_add_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_I08_I08_I08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1 - op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SUB_I08_I08_I08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1 - op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_I08_I08_I08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_S08_S08_S08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			qb_do_divide_S08(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			qb_do_divide_S08(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S08_S08_S08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1 % op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1 % op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_S08_S08_S08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_I08_I08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = - op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_NEG_I08_I08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = - op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_I08_I08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_multiple_times_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I08_I08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I08_I08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I08_I08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_multiple_times_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_I08_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int8_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int8_t *) segment0) + index;
			
			++res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_INC_I08_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int8_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			++res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_I08_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int8_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_multiple_times_I08(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_I08_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int8_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int8_t *) segment0) + index;
			
			--res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_DEC_I08_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int8_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			--res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_I08_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int8_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_multiple_times_I08(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_EQ_I08_I08_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_EQ_I08_I08_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_I08_I08_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S08(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_I08_I08_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_NE_I08_I08_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_I08_I08_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S08(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_S08_S08_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_S08_S08_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_S08_S08_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S08(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_S08_S08_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_S08_S08_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_S08_S08_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S08(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_SET_I08_I08_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_equal_vector_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_SET_I08_I08_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_not_equal_vector_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_S08_S08_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_S08_S08_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_AND_I08_I08_I08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1 & op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_AND_I08_I08_I08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1 & op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_AND_I08_I08_I08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_and_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_OR_I08_I08_I08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1 | op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_OR_I08_I08_I08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1 | op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_OR_I08_I08_I08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_or_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_XOR_I08_I08_I08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1 ^ op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_XOR_I08_I08_I08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1 ^ op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_XOR_I08_I08_I08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_xor_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_NOT_I08_I08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = ~op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BW_NOT_I08_I08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = ~op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BW_NOT_I08_I08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_not_multiple_times_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SHL_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1 << op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHL_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1 << op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_S08_S08_S08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_left_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = op1 >> op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHR_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = op1 >> op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_S08_S08_S08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_right_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ISSET_I08_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index >= segment_element_counts[selector]) {
				op1_ptr = NULL;
			} else {
				op1_ptr = ((int8_t *) segments[selector]) + index;
			}
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNSET_I08_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int8_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = 0;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_UNSET_I08_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index < segment_element_counts[selector]) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_UNSET_I08_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = ((uint32_t *) segment0)[size_index];
			if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MOV_S08_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (int32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S08_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (int32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S08_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S08_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S08_I16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = (int16_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S08_I16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = (int16_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S08_I16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S08_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S08_I64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S08_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S08_I64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S08_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S08_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S08_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S08_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S08_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S08_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S08_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S08_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S08_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_I08_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = !(!(op1));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BOOL_I08_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = !(!(op1));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_I08_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_boolean_cast_multiple_times_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_S08_S08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = (int8_t) abs(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ABS_S08_S08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = (int8_t) abs(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_S08_S08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_abs_multiple_times_S08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_S08_S08_S08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_S08_S08_S08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			qb_do_random_S08(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_RAND_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			qb_do_random_S08(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_S08_S08_S08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_random_multiple_times_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int8_t *) segment0) + index;
			
			qb_do_random_mt_S08(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MT_RAND_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			qb_do_random_mt_S08(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_S08_S08_S08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_random_mt_multiple_times_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PRN_S08_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int8_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			qb_do_print_variable_S08(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_S08_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			qb_do_print_variable_S08(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_S08_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_S08_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S08_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_S08(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_S08(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S08_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_S08(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_S08(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S08_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_S08(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_S08(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_S08_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SORT_S08:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int8_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_S08(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_S08:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int8_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_S08(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_S08_S08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			qb_do_array_min_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_S08_S08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			qb_do_array_max_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_S08_S08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			qb_do_array_product_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_S08_S08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			qb_do_array_sum_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_S08_S08_S08_S08_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *op3_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int8_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_S08(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_range_S08(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_S08_S08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			qb_do_array_min_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_S08_S08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			qb_do_array_max_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_S08_S08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			qb_do_array_product_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_S08_S08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			qb_do_array_sum_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_S08_S08_S08_S08_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int8_t *op3_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_S08(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_range_S08(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I08_I08_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_I08(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I08_I08_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_I08(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I08_I08_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I08_I08_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int8_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_I08(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I08_I08_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_I08(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I08_I08_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_APOS_I08_I08_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_I08(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_ARPOS_I08_I08_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			int8_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_from_end_I08(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AREV_I08_U32_I08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			uint32_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_array_reverse_I08(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AINS_I08_U32_I08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			uint32_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			res_count = res_count + op1_count;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_array_insert_I08(op1_ptr, op1_count, op2, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AUNIQ_I08_U32_I08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int8_t *op1_ptr;
			uint32_t *op2_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_unique_element_count_I08(op1_ptr, op1_count, op2);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_array_unique_I08(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_IF_LT_U08_U08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_U08_U08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_U08_U08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_U08_U08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_U08_U08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_U08_U08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_U08_U08_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_U08_U08_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_MUL_U08_U08_U08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint8_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_U08_U08_U08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_U08_U08_U08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U08_U08_U08_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((uint8_t *) segment0) + index;
			
			qb_do_divide_U08(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U08_U08_U08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			qb_do_divide_U08(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U08_U08_U08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_U08_U08_U08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint8_t *) segment0) + index;
			
			res = op1 % op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_U08_U08_U08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			res = op1 % op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_U08_U08_U08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_U08_U08_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_U08_U08_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_U08_U08_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_U08(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_U08_U08_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_U08_U08_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_U08_U08_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_U08(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_U08_U08_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_U08_U08_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_U08_U08_U08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint8_t *) segment0) + index;
			
			res = op1 << op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHL_U08_U08_U08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			res = op1 << op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_U08_U08_U08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_left_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_U08_U08_U08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint8_t *) segment0) + index;
			
			res = op1 >> op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHR_U08_U08_U08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			res = op1 >> op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_U08_U08_U08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_right_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_U08_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (int32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U08_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (int32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U08_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U08_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U08_I16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = (int16_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U08_I16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = (int16_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U08_I16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U08_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U08_I64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U08_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U08_I64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U08_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U08_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U08_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U08_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U08_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U08_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U08_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U08_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U08_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_U08_U08_U08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint8_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_U08_U08_U08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_U08_U08_U08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_U08_U08_U08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint8_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_U08_U08_U08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_U08_U08_U08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_U08_U08_U08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint8_t *) segment0) + index;
			
			qb_do_random_U08(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_RAND_U08_U08_U08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			qb_do_random_U08(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_U08_U08_U08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_random_multiple_times_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_U08_U08_U08_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint8_t *) segment0) + index;
			
			qb_do_random_mt_U08(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MT_RAND_U08_U08_U08_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			qb_do_random_mt_U08(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_U08_U08_U08_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_random_mt_multiple_times_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PRN_STR_U08:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			php_write(op1_ptr, op1_count TSRMLS_CC);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_CAT_STR_U08_U08:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			res_count = res_count + op1_count;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			memcpy(res_ptr + res_count_before, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PRN_U08_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			uint8_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			qb_do_print_variable_U08(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_U08_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			qb_do_print_variable_U08(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_U08_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_U08_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U08_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_U08(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_U08(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U08_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_U08(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_U08(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U08_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_U08(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_U08(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_U08_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SORT_U08:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_U08(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_U08:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_U08(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_U08_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint8_t *) segment0) + index;
			
			qb_do_array_min_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_U08_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint8_t *) segment0) + index;
			
			qb_do_array_max_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_U08_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint8_t *) segment0) + index;
			
			qb_do_array_product_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_U08_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint8_t *) segment0) + index;
			
			qb_do_array_sum_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_U08_U08_S08_U08_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int8_t *op3_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint8_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int8_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_U08(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_range_U08(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_U08_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			qb_do_array_min_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_U08_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			qb_do_array_max_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_U08_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			qb_do_array_product_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_U08_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			qb_do_array_sum_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_U08_U08_S08_U08_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint8_t *op2_ptr;
			int8_t *op3_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int8_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_U08(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_range_U08(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_IF_EQ_I16_I16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_EQ_I16_I16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_NE_I16_I16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_NE_I16_I16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LT_S16_S16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_S16_S16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_S16_S16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_S16_S16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_S16_S16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_S16_S16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_S16_S16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_S16_S16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_ADD_I16_I16_I16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1 + op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_ADD_I16_I16_I16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1 + op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_I16_I16_I16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_add_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_I16_I16_I16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1 - op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SUB_I16_I16_I16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1 - op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_I16_I16_I16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_S16_S16_S16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			qb_do_divide_S16(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			qb_do_divide_S16(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S16_S16_S16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1 % op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1 % op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_S16_S16_S16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_I16_I16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = - op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_NEG_I16_I16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = - op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_I16_I16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_multiple_times_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I16_I16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I16_I16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I16_I16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_multiple_times_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_I16_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int16_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int16_t *) segment0) + index;
			
			++res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_INC_I16_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int16_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			++res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_I16_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int16_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_multiple_times_I16(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_I16_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int16_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int16_t *) segment0) + index;
			
			--res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_DEC_I16_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int16_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			--res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_I16_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int16_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_multiple_times_I16(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_EQ_I16_I16_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_EQ_I16_I16_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_I16_I16_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S16(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_I16_I16_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_NE_I16_I16_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_I16_I16_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S16(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_S16_S16_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_S16_S16_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_S16_S16_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S16(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_S16_S16_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_S16_S16_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_S16_S16_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S16(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_SET_I16_I16_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_equal_vector_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_SET_I16_I16_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_not_equal_vector_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_S16_S16_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_S16_S16_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_AND_I16_I16_I16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1 & op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_AND_I16_I16_I16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1 & op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_AND_I16_I16_I16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_and_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_OR_I16_I16_I16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1 | op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_OR_I16_I16_I16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1 | op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_OR_I16_I16_I16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_or_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_XOR_I16_I16_I16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1 ^ op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_XOR_I16_I16_I16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1 ^ op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_XOR_I16_I16_I16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_xor_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_NOT_I16_I16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = ~op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BW_NOT_I16_I16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = ~op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BW_NOT_I16_I16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_not_multiple_times_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SHL_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1 << op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHL_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1 << op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_S16_S16_S16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_left_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = op1 >> op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHR_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = op1 >> op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_S16_S16_S16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_right_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ISSET_I16_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index >= segment_element_counts[selector]) {
				op1_ptr = NULL;
			} else {
				op1_ptr = ((int16_t *) segments[selector]) + index;
			}
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNSET_I16_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int16_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = 0;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_UNSET_I16_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index < segment_element_counts[selector]) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_UNSET_I16_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = ((uint32_t *) segment0)[size_index];
			if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MOV_S16_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (int32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S16_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (int32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S16_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S16_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I16_I08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = (int8_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I16_I08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = (int8_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I16_I08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_I16_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S16_I64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S16_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S16_I64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S16_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S16_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S16_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S16_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S16_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S16_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S16_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S16_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S16_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_I16_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = !(!(op1));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BOOL_I16_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = !(!(op1));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_I16_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_boolean_cast_multiple_times_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_S16_S16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = (int16_t) abs(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ABS_S16_S16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = (int16_t) abs(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_S16_S16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_abs_multiple_times_S16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_S16_S16_S16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_S16_S16_S16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			qb_do_random_S16(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_RAND_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			qb_do_random_S16(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_S16_S16_S16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_random_multiple_times_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int16_t *) segment0) + index;
			
			qb_do_random_mt_S16(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MT_RAND_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			qb_do_random_mt_S16(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_S16_S16_S16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_random_mt_multiple_times_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PRN_S16_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int16_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			qb_do_print_variable_S16(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_S16_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			qb_do_print_variable_S16(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_S16_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_S16_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S16_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_S16(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_S16(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S16_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_S16(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_S16(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S16_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_S16(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_S16(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_S16_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PACK_LE_I16_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(2 > res_count) {
				res_count = 2;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint16_t *) res_ptr) = SWAP_LE_I16(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_LE_I16_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(2 > res_count) {
				res_count = 2;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint16_t *) res_ptr) = SWAP_LE_I16(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_I16_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(2 > res_count) {
				res_count = 2;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint16_t *) res_ptr) = SWAP_BE_I16(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_I16_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(2 > res_count) {
				res_count = 2;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint16_t *) res_ptr) = SWAP_BE_I16(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_I16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			*((uint16_t *) &res) = SWAP_LE_I16(*((uint16_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_I16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			*((uint16_t *) &res) = SWAP_LE_I16(*((uint16_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_I16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			*((uint16_t *) &res) = SWAP_BE_I16(*((uint16_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_I16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			*((uint16_t *) &res) = SWAP_BE_I16(*((uint16_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SORT_S16:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int16_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_S16(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_S16:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int16_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_S16(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_S16_S16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			qb_do_array_min_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_S16_S16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			qb_do_array_max_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_S16_S16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			qb_do_array_product_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_S16_S16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			qb_do_array_sum_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_S16_S16_S16_S16_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *op3_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int16_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_S16(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_range_S16(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_S16_S16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			qb_do_array_min_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_S16_S16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			qb_do_array_max_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_S16_S16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			qb_do_array_product_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_S16_S16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			qb_do_array_sum_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_S16_S16_S16_S16_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int16_t *op3_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_S16(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_range_S16(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I16_I16_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_I16(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I16_I16_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_I16(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I16_I16_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I16_I16_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int16_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_I16(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I16_I16_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_I16(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I16_I16_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_APOS_I16_I16_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_I16(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_ARPOS_I16_I16_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			int16_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_from_end_I16(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AREV_I16_U32_I16:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint32_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_array_reverse_I16(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AINS_I16_U32_I16:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint32_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			res_count = res_count + op1_count;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_array_insert_I16(op1_ptr, op1_count, op2, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AUNIQ_I16_U32_I16:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int16_t *op1_ptr;
			uint32_t *op2_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_unique_element_count_I16(op1_ptr, op1_count, op2);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_array_unique_I16(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_IF_LT_U16_U16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_U16_U16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_U16_U16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_U16_U16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_U16_U16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_U16_U16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_U16_U16_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_U16_U16_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_MUL_U16_U16_U16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint16_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_U16_U16_U16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_U16_U16_U16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U16_U16_U16_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((uint16_t *) segment0) + index;
			
			qb_do_divide_U16(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U16_U16_U16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			qb_do_divide_U16(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U16_U16_U16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_U16_U16_U16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint16_t *) segment0) + index;
			
			res = op1 % op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_U16_U16_U16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			res = op1 % op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_U16_U16_U16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_U16_U16_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_U16_U16_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_U16_U16_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_U16(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_U16_U16_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_U16_U16_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_U16_U16_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_U16(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_U16_U16_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_U16_U16_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_U16_U16_U16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint16_t *) segment0) + index;
			
			res = op1 << op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHL_U16_U16_U16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			res = op1 << op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_U16_U16_U16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_left_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_U16_U16_U16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint16_t *) segment0) + index;
			
			res = op1 >> op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHR_U16_U16_U16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			res = op1 >> op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_U16_U16_U16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_right_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_U16_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (int32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U16_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (int32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U16_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U16_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U16_I64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U16_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U16_I64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U16_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U16_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U16_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U16_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U16_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U16_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U16_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U16_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U16_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_U16_U16_U16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint16_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_U16_U16_U16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_U16_U16_U16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_U16_U16_U16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint16_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_U16_U16_U16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_U16_U16_U16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_U16_U16_U16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint16_t *) segment0) + index;
			
			qb_do_random_U16(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_RAND_U16_U16_U16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			qb_do_random_U16(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_U16_U16_U16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_random_multiple_times_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_U16_U16_U16_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint16_t *) segment0) + index;
			
			qb_do_random_mt_U16(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MT_RAND_U16_U16_U16_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			qb_do_random_mt_U16(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_U16_U16_U16_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_random_mt_multiple_times_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_UTF8_DEC_U08_U16:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_utf8_codepoint_count(op1_ptr, op1_count);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_utf8decode_U16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UTF8_ENC_U16_U08:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_utf8_encoded_length_U16(op1_ptr, op1_count);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_utf8encode_U16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PRN_U16_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			uint16_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			qb_do_print_variable_U16(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_U16_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			qb_do_print_variable_U16(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_U16_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_U16_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U16_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_U16(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_U16(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U16_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_U16(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_U16(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U16_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_U16(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_U16(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_U16_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SORT_U16:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_U16(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_U16:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_U16(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_U16_U16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint16_t *) segment0) + index;
			
			qb_do_array_min_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_U16_U16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint16_t *) segment0) + index;
			
			qb_do_array_max_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_U16_U16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint16_t *) segment0) + index;
			
			qb_do_array_product_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_U16_U16_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint16_t *) segment0) + index;
			
			qb_do_array_sum_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_U16_U16_S16_U16_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int16_t *op3_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint16_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int16_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_U16(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_range_U16(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_U16_U16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			qb_do_array_min_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_U16_U16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			qb_do_array_max_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_U16_U16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			qb_do_array_product_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_U16_U16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			qb_do_array_sum_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_U16_U16_S16_U16_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint16_t *op1_ptr;
			uint16_t *op2_ptr;
			int16_t *op3_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int16_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_U16(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_range_U16(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_IF_EQ_I64_I64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_EQ_I64_I64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_NE_I64_I64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_NE_I64_I64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LT_S64_S64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_S64_S64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_S64_S64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_S64_S64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_S64_S64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_S64_S64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_S64_S64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_S64_S64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_ADD_I64_I64_I64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 + op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_ADD_I64_I64_I64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 + op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_I64_I64_I64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_add_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_I64_I64_I64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 - op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SUB_I64_I64_I64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 - op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_I64_I64_I64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			qb_do_divide_S64(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			qb_do_divide_S64(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 % op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 % op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAC_S64_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *op3_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 + (op2 * op3);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_MAC_S64_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *op3_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_S64_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *op3_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_NEG_I64_I64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = - op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_NEG_I64_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = - op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_I64_I64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_multiple_times_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I64_I64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I64_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I64_I64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_multiple_times_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_I64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int64_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int64_t *) segment0) + index;
			
			++res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_INC_I64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			++res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_I64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_multiple_times_I64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_I64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int64_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int64_t *) segment0) + index;
			
			--res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_DEC_I64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			--res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_I64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_multiple_times_I64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_EQ_I64_I64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_EQ_I64_I64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_I64_I64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S64(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_I64_I64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_NE_I64_I64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_I64_I64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S64(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_S64_S64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_S64_S64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_S64_S64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S64(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_S64_S64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_S64_S64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_S64_S64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_S64(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_SET_I64_I64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_equal_vector_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_SET_I64_I64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_not_equal_vector_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_S64_S64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_S64_S64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_AND_I64_I64_I64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 & op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_AND_I64_I64_I64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 & op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_AND_I64_I64_I64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_and_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_OR_I64_I64_I64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 | op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_OR_I64_I64_I64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 | op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_OR_I64_I64_I64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_or_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_XOR_I64_I64_I64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 ^ op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_BW_XOR_I64_I64_I64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 ^ op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_XOR_I64_I64_I64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_xor_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_BW_NOT_I64_I64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = ~op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BW_NOT_I64_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = ~op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BW_NOT_I64_I64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_bitwise_not_multiple_times_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SHL_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 << op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHL_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 << op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_left_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = op1 >> op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHR_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = op1 >> op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_right_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ISSET_I64_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index >= segment_element_counts[selector]) {
				op1_ptr = NULL;
			} else {
				op1_ptr = ((int64_t *) segments[selector]) + index;
			}
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNSET_I64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int64_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = 0;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_UNSET_I64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index < segment_element_counts[selector]) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_UNSET_I64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = ((uint32_t *) segment0)[size_index];
			if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MOV_I64_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (int32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I64_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (int32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I64_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_I64_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I64_I08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = (int8_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I64_I08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = (int8_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I64_I08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_I64_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I64_I16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = (int16_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_I64_I16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = (int16_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_I64_I16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_I64_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S64_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S64_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S64_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S64_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_S64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_S64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_S64_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_I64_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = !(!(op1));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BOOL_I64_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = !(!(op1));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_I64_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_boolean_cast_multiple_times_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_S64_S64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (int64_t) llabs(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ABS_S64_S64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (int64_t) llabs(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_S64_S64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_abs_multiple_times_S64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			qb_do_random_S64(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_RAND_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			qb_do_random_S64(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_random_multiple_times_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int64_t *) segment0) + index;
			
			qb_do_random_mt_S64(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MT_RAND_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			qb_do_random_mt_S64(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_S64_S64_S64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_random_mt_multiple_times_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PRN_S64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			int64_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			qb_do_print_variable_S64(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_S64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			qb_do_print_variable_S64(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_S64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_S64_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S64_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_S64(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_S64(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S64_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_S64(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_S64(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_S64_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_S64(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_S64(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_S64_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PACK_LE_I64_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(8 > res_count) {
				res_count = 8;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint64_t *) res_ptr) = SWAP_LE_I64(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_LE_I64_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(8 > res_count) {
				res_count = 8;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint64_t *) res_ptr) = SWAP_LE_I64(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_I64_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(8 > res_count) {
				res_count = 8;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint64_t *) res_ptr) = SWAP_BE_I64(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_I64_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(8 > res_count) {
				res_count = 8;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			*((uint64_t *) res_ptr) = SWAP_BE_I64(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_I64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			*((uint64_t *) &res) = SWAP_LE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			*((uint64_t *) &res) = SWAP_LE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_I64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			*((uint64_t *) &res) = SWAP_BE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_I64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			*((uint64_t *) &res) = SWAP_BE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SORT_S64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_S64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_S64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			int64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_S64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_S64_S64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			qb_do_array_min_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_S64_S64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			qb_do_array_max_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_S64_S64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			qb_do_array_product_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_S64_S64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			qb_do_array_sum_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_S64_S64_S64_S64_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *op3_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_S64(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_range_S64(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_S64_S64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			qb_do_array_min_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_S64_S64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			qb_do_array_max_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_S64_S64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			qb_do_array_product_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_S64_S64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			qb_do_array_sum_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_S64_S64_S64_S64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int64_t *op3_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_S64(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_range_S64(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I64_I64_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_I64(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I64_I64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_I64(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_I64_I64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I64_I64_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((int64_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_I64(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I64_I64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_I64(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_I64_I64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_APOS_I64_I64_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_I64(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_ARPOS_I64_I64_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			int64_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_from_end_I64(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AREV_I64_U32_I64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint32_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_array_reverse_I64(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AINS_I64_U32_I64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint32_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			res_count = res_count + op1_count;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_array_insert_I64(op1_ptr, op1_count, op2, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AUNIQ_I64_U32_I64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			int64_t *op1_ptr;
			uint32_t *op2_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_unique_element_count_I64(op1_ptr, op1_count, op2);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_array_unique_I64(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_IF_LT_U64_U64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_U64_U64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_U64_U64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_U64_U64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_U64_U64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_U64_U64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_U64_U64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_U64_U64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_MUL_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint64_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((uint64_t *) segment0) + index;
			
			qb_do_divide_U64(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			qb_do_divide_U64(cxt, op1, op2, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint64_t *) segment0) + index;
			
			res = op1 % op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			res = op1 % op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAC_U64_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *op3_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((uint64_t *) segment0) + index;
			
			res = op1 + (op2 * op3);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_MAC_U64_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *op3_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_U64_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *op3_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((uint64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_LT_U64_U64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_U64_U64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_U64_U64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_U64(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_U64_U64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_U64_U64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_U64_U64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_U64(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_U64_U64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_U64_U64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint64_t *) segment0) + index;
			
			res = op1 << op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHL_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			res = op1 << op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHL_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_left_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint64_t *) segment0) + index;
			
			res = op1 >> op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SHR_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			res = op1 >> op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SHR_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_shift_right_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_U64_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U64_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U64_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U64_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_U64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_U64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_U64_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint64_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint64_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint64_t *) segment0) + index;
			
			qb_do_random_U64(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_RAND_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			qb_do_random_U64(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_RAND_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_random_multiple_times_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_U64_U64_U64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((uint64_t *) segment0) + index;
			
			qb_do_random_mt_U64(cxt, op1, op2, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MT_RAND_U64_U64_U64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			qb_do_random_mt_U64(cxt, op1, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MT_RAND_U64_U64_U64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_random_mt_multiple_times_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PRN_U64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			uint64_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			qb_do_print_variable_U64(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_U64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			qb_do_print_variable_U64(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_U64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_U64_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U64_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_U64(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_U64(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U64_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_U64(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_U64(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_U64_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_U64(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_U64(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_U64_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SORT_U64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_U64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_U64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_U64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_U64_U64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint64_t *) segment0) + index;
			
			qb_do_array_min_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_U64_U64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint64_t *) segment0) + index;
			
			qb_do_array_max_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_U64_U64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint64_t *) segment0) + index;
			
			qb_do_array_product_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_U64_U64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((uint64_t *) segment0) + index;
			
			qb_do_array_sum_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_U64_U64_S64_U64_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int64_t *op3_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint64_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_U64(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_range_U64(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_U64_U64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			qb_do_array_min_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_U64_U64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			qb_do_array_max_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_U64_U64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			qb_do_array_product_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_U64_U64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			qb_do_array_sum_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_U64_U64_S64_U64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			uint64_t *op1_ptr;
			uint64_t *op2_ptr;
			int64_t *op3_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_U64(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_range_U64(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_IF_EQ_F32_F32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_EQ_F32_F32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_NE_F32_F32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_NE_F32_F32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LT_F32_F32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_F32_F32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_F32_F32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_F32_F32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_F32_F32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_F32_F32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_F32_F32_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_F32_F32_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_ADD_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1 + op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_ADD_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1 + op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_add_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1 - op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SUB_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1 - op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1 / op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_DIV_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1 / op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = fmodf(op1, op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = fmodf(op1, op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAC_F32_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1 + (op2 * op3);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_MAC_F32_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MOD_FLR_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) (op1 - op2 * floor(op1 / op2));
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_FLR_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) (op1 - op2 * floor(op1 / op2));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_FLR_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_floored_division_modulo_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = - op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_NEG_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = - op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_F32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float32_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((float32_t *) segment0) + index;
			
			++res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_INC_F32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			++res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_F32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float32_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((float32_t *) segment0) + index;
			
			--res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_DEC_F32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			--res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_EQ_F32_F32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_EQ_F32_F32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_F32_F32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_F32(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_F32_F32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_NE_F32_F32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_F32_F32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_F32(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_F32_F32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_F32_F32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_F32_F32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_F32(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_F32_F32_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_F32_F32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_F32_F32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_F32(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_SET_F32_F32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_equal_vector_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_SET_F32_F32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_not_equal_vector_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_F32_F32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_F32_F32_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ISSET_F32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index >= segment_element_counts[selector]) {
				op1_ptr = NULL;
			} else {
				op1_ptr = ((float32_t *) segments[selector]) + index;
			}
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNSET_F32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float32_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = 0;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_UNSET_F32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index < segment_element_counts[selector]) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_UNSET_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = ((uint32_t *) segment0)[size_index];
			if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MOV_F32_S32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (int32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_S32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (int32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_S32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F32_S32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_U32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((uint32_t *) segment0) + index;
			
			res = (uint32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_U32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			res = (uint32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_U32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F32_U32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_S08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = (int8_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_S08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = (int8_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_S08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F32_S08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_U08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((uint8_t *) segment0) + index;
			
			res = (uint8_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			res = (uint8_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F32_U08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_S16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = (int16_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_S16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = (int16_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_S16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F32_S16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_U16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((uint16_t *) segment0) + index;
			
			res = (uint16_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_U16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			res = (uint16_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_U16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F32_U16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_S64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_S64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_S64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F32_S64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_U64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((uint64_t *) segment0) + index;
			
			res = (uint64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_U64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			res = (uint64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_U64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F32_U64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F32_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F32_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F32_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_F32_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = !(!(op1));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BOOL_F32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = !(!(op1));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_F32_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_boolean_cast_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) fabsf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ABS_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) fabsf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_abs_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SIN_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) sinf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_SIN_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) sinf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SIN_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sin_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASIN_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = asinf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ASIN_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = asinf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASIN_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_asin_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_COS_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = cosf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_COS_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = cosf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_COS_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cos_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ACOS_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) acosf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ACOS_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) acosf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ACOS_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_acos_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_TAN_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = tanf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_TAN_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = tanf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_TAN_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_tan_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATAN_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = atanf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ATAN_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = atanf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATAN_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_atan_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATAN2_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = atan2f(op1, op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_ATAN2_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = atan2f(op1, op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ATAN2_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_atan2_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SINH_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = sinhf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_SINH_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = sinhf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SINH_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sinh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASINH_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = asinhf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ASINH_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = asinhf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASINH_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_asinh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_COSH_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = coshf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_COSH_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = coshf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_COSH_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cosh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ACOSH_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = acoshf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ACOSH_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = acoshf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ACOSH_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_acosh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_TANH_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = tanhf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_TANH_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = tanhf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_TANH_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_tanh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATANH_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = atanhf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ATANH_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = atanhf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATANH_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_atanh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CEIL_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = ceilf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_CEIL_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = ceilf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CEIL_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_ceil_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_FLOOR_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) floorf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_FLOOR_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) floorf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_FLOOR_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_floor_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ROUND_F32_I32_I32_F32_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) _php_math_round(op1, op2, op3);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_ROUND_F32_I32_I32_F32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) _php_math_round(op1, op2, op3);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_ROUND_F32_I32_I32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_round_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_LOG_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = logf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_LOG_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = logf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_log_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG1P_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = log1pf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_LOG1P_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = log1pf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG1P_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_log1p_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG2_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = log2f(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_LOG2_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = log2f(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG2_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_log2_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG10_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = log10f(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_LOG10_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = log10f(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG10_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_log10_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXP_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = expf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_EXP_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = expf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXP_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_exp_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXPM1_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = expm1f(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_EXPM1_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = expm1f(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXPM1_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_exp_m1_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXP2_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = exp2f(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_EXP2_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = exp2f(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXP2_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_exp2_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_POW_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = powf(op1, op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_POW_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = powf(op1, op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_POW_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_pow_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SQRT_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = sqrtf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_SQRT_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = sqrtf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SQRT_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sqrt_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_HYPOT_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) hypotf(op1, op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_HYPOT_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) hypotf(op1, op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_HYPOT_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_hypot_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LCG_F32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float32_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_lcg_F32(cxt, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_LCG_F32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_lcg_F32(cxt, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_LCG_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_lcg_multiple_times_F32(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_FIN_F32_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = zend_finite(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_FIN_F32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = zend_finite(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_FIN_F32_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_is_finite_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INF_F32_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (zend_isinf(op1) != 0);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_INF_F32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (zend_isinf(op1) != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INF_F32_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_is_infinite_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NAN_F32_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = zend_isnan(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_NAN_F32_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = zend_isnan(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NAN_F32_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_is_nan_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RSQRT_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = qb_fast_rsqrtf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_RSQRT_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = qb_fast_rsqrtf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RSQRT_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_rsqrt_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CLAMP_F32_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_clamp_F32(op1, op2, op3, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_CLAMP_F32_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_clamp_F32(op1, op2, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_CLAMP_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_clamp_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_FRACT_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1 - floorf(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_FRACT_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1 - floorf(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_FRACT_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_fract_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIX_F32_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1 * (1 - op3) + op2 * op3;
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_MIX_F32_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1 * (1 - op3) + op2 * op3;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MIX_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_mix_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_SIGN_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_sign_F32(op1, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_SIGN_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_sign_F32(op1, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SIGN_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sign_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_STEP_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = ((op2 < op1) ? 0.0f : 1.0f);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_STEP_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = ((op2 < op1) ? 0.0f : 1.0f);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_STEP_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_step_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SSTEP_F32_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_smooth_step_F32(op1, op2, op3, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_SSTEP_F32_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_smooth_step_F32(op1, op2, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_SSTEP_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_smooth_step_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_RAD2DEG_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1 * ((float32_t) (180 / M_PI));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_RAD2DEG_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1 * ((float32_t) (180 / M_PI));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RAD2DEG_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_radian_to_degree_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DEG2RAD_F32_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = op1 * ((float32_t) (M_PI / 180.0));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_DEG2RAD_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = op1 * ((float32_t) (M_PI / 180.0));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DEG2RAD_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_degree_to_radian_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PRN_F32_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float32_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			qb_do_print_variable_F32(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_F32_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_print_variable_F32(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_F32_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_F32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_F32_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_F32(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_F32(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_F32_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_F32(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_F32(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_F32_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_F32(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_F32(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_F32_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_F32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_F32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PACK_LE_F32_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_pack_F32(op1, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_LE_F32_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_pack_F32(op1, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_F32_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_pack_F32(op1, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_F32_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_pack_F32(op1, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			*((uint32_t *) &res) = SWAP_LE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			*((uint32_t *) &res) = SWAP_LE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			*((uint32_t *) &res) = SWAP_BE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			*((uint32_t *) &res) = SWAP_BE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SORT_F32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_F32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_array_min_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_array_max_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_array_product_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_array_sum_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_F32_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_F32(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_range_F32(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_array_min_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_array_max_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_array_product_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_array_sum_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_F32_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_F32(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_range_F32(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_F32_F32_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_F32(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_F32_F32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_F32(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_F32_F32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_F32_F32_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_F32(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_F32_F32_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_F32(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_F32_F32_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_APOS_F32_F32_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_ARPOS_F32_F32_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_from_end_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AREV_F32_U32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_array_reverse_F32(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AINS_F32_U32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			res_count = res_count + op1_count;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_array_insert_F32(op1_ptr, op1_count, op2, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AUNIQ_F32_U32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_unique_element_count_F32(op1_ptr, op1_count, op2);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_array_unique_F32(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
			op4_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
			op5_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_4x_F32(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_4x_F32(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
			op4_start_index = ((uint32_t *) segment0)[index_index];
			op4_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float32_t *) segments[selector]) + op4_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
			op5_start_index = ((uint32_t *) segment0)[index_index];
			op5_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float32_t *) segments[selector]) + op5_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op4_count * 4 > res_count) {
				res_count = op4_count * 4;
			}
			if(op5_count * 4 > res_count) {
				res_count = op5_count * 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_4x_multiple_times_F32(op1_ptr, op1_count, op2, op3, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
			op4_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
			op5_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(3 > res_count) {
				res_count = 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_3x_F32(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(3 > res_count) {
				res_count = 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_3x_F32(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
			op4_start_index = ((uint32_t *) segment0)[index_index];
			op4_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float32_t *) segments[selector]) + op4_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
			op5_start_index = ((uint32_t *) segment0)[index_index];
			op5_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float32_t *) segments[selector]) + op5_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op4_count * 3 > res_count) {
				res_count = op4_count * 3;
			}
			if(op5_count * 3 > res_count) {
				res_count = op5_count * 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_3x_multiple_times_F32(op1_ptr, op1_count, op2, op3, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
			op4_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
			op5_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_4x_F32(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_4x_F32(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
			op4_start_index = ((uint32_t *) segment0)[index_index];
			op4_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float32_t *) segments[selector]) + op4_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
			op5_start_index = ((uint32_t *) segment0)[index_index];
			op5_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float32_t *) segments[selector]) + op5_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op4_count * 4 > res_count) {
				res_count = op4_count * 4;
			}
			if(op5_count * 4 > res_count) {
				res_count = op5_count * 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_4x_multiple_times_F32(op1_ptr, op1_count, op2, op3, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
			op4_ptr = ((float32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
			op5_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(3 > res_count) {
				res_count = 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_3x_F32(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(3 > res_count) {
				res_count = 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_3x_F32(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float32_t *op4_ptr;
			float32_t *op5_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
			op4_start_index = ((uint32_t *) segment0)[index_index];
			op4_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float32_t *) segments[selector]) + op4_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
			op5_start_index = ((uint32_t *) segment0)[index_index];
			op5_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float32_t *) segments[selector]) + op5_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op4_count * 3 > res_count) {
				res_count = op4_count * 3;
			}
			if(op5_count * 3 > res_count) {
				res_count = op5_count * 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_3x_multiple_times_F32(op1_ptr, op1_count, op2, op3, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_BLEND_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_alpha_blend_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PREMULT_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_apply_premultiplication_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPREMULT_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_remove_premultiplication_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MUL_MM_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MM_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 16;
			matrix2_count = op2_count / 16;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 16;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 16;
			matrix2_count = op2_count / 4;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 4;
			matrix2_count = op2_count / 16;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MTRAN_4X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MTRAN_4X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_4X_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_determinant_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_4X_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_determinant_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_4X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 16;
			if(matrix1_count > res_count) {
				res_count = matrix1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_determinant_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_4X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_4X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DOT_4X_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]) + (op1_ptr[2] * op2_ptr[2]) + (op1_ptr[3] * op2_ptr[3]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_4X_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]) + (op1_ptr[2] * op2_ptr[2]) + (op1_ptr[3] * op2_ptr[3]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 4;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_dot_product_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LEN_4X_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_length_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_4X_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_length_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_4X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 4;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_length_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DIS_4X_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_distance_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_4X_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_distance_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 4;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_distance_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NORM_4X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NORM_4X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CROSS_4X_F32_F32_F32_F32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_4x_F32(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_CROSS_4X_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_FORE_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFR_4X_F32_F32_F32_F32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_4x_F32(op1_ptr, op2_ptr, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_REFR_4X_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_TRAN_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_4X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0];
			res_ptr[1] = op1_ptr[1];
			res_ptr[2] = op1_ptr[2];
			res_ptr[3] = op1_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_4X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ADD_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + op2_ptr[0];
			res_ptr[1] = op1_ptr[1] + op2_ptr[1];
			res_ptr[2] = op1_ptr[2] + op2_ptr[2];
			res_ptr[3] = op1_ptr[3] + op2_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_add_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] - op2_ptr[0];
			res_ptr[1] = op1_ptr[1] - op2_ptr[1];
			res_ptr[2] = op1_ptr[2] - op2_ptr[2];
			res_ptr[3] = op1_ptr[3] - op2_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] * op2_ptr[0];
			res_ptr[1] = op1_ptr[1] * op2_ptr[1];
			res_ptr[2] = op1_ptr[2] * op2_ptr[2];
			res_ptr[3] = op1_ptr[3] * op2_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] / op2_ptr[0];
			res_ptr[1] = op1_ptr[1] / op2_ptr[1];
			res_ptr[2] = op1_ptr[2] / op2_ptr[2];
			res_ptr[3] = op1_ptr[3] / op2_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_4X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = fmodf(op1_ptr[0], op2_ptr[0]);
			res_ptr[1] = fmodf(op1_ptr[1], op2_ptr[1]);
			res_ptr[2] = fmodf(op1_ptr[2], op2_ptr[2]);
			res_ptr[3] = fmodf(op1_ptr[3], op2_ptr[3]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_4X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_4X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = - op1_ptr[0];
			res_ptr[1] = - op1_ptr[1];
			res_ptr[2] = - op1_ptr[2];
			res_ptr[3] = - op1_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_4X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_4X_F32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			++res_ptr[0];
			++res_ptr[1];
			++res_ptr[2];
			++res_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_4X_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_4x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_4X_F32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			--res_ptr[0];
			--res_ptr[1];
			--res_ptr[2];
			--res_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_4X_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_4x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MAC_4X_F32_F32_F32_F32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
			res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
			res_ptr[2] = op1_ptr[2] + (op2_ptr[2] * op3_ptr[2]);
			res_ptr[3] = op1_ptr[3] + (op2_ptr[3] * op3_ptr[3]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_4X_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MUL_MM_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MM_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 9;
			matrix2_count = op2_count / 9;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 9;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 9;
			matrix2_count = op2_count / 3;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 3;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 3;
			matrix2_count = op2_count / 9;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 3;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MM_3XP_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_3x_padded_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_3XP_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_3x_padded_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_3XP_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_3x_padded_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MTRAN_3X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MTRAN_3X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_3X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_3X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_3X_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_determinant_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_3X_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_determinant_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_3X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 9;
			if(matrix1_count > res_count) {
				res_count = matrix1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_determinant_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DOT_3X_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]) + (op1_ptr[2] * op2_ptr[2]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_3X_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]) + (op1_ptr[2] * op2_ptr[2]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 3;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_dot_product_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LEN_3X_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_length_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_3X_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_length_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_3X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 3;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_length_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DIS_3X_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_distance_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_3X_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_distance_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 3;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_distance_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NORM_3X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NORM_3X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CROSS_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CROSS_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFR_3X_F32_F32_F32_F32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_3x_F32(op1_ptr, op2_ptr, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_REFR_3X_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_TRAN_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_3X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0];
			res_ptr[1] = op1_ptr[1];
			res_ptr[2] = op1_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_3X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ADD_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + op2_ptr[0];
			res_ptr[1] = op1_ptr[1] + op2_ptr[1];
			res_ptr[2] = op1_ptr[2] + op2_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_add_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] - op2_ptr[0];
			res_ptr[1] = op1_ptr[1] - op2_ptr[1];
			res_ptr[2] = op1_ptr[2] - op2_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] * op2_ptr[0];
			res_ptr[1] = op1_ptr[1] * op2_ptr[1];
			res_ptr[2] = op1_ptr[2] * op2_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] / op2_ptr[0];
			res_ptr[1] = op1_ptr[1] / op2_ptr[1];
			res_ptr[2] = op1_ptr[2] / op2_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_3X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = fmodf(op1_ptr[0], op2_ptr[0]);
			res_ptr[1] = fmodf(op1_ptr[1], op2_ptr[1]);
			res_ptr[2] = fmodf(op1_ptr[2], op2_ptr[2]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_3X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_3X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = - op1_ptr[0];
			res_ptr[1] = - op1_ptr[1];
			res_ptr[2] = - op1_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_3X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_3X_F32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			++res_ptr[0];
			++res_ptr[1];
			++res_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_3X_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_3x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_3X_F32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			--res_ptr[0];
			--res_ptr[1];
			--res_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_3X_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_3x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MAC_3X_F32_F32_F32_F32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
			res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
			res_ptr[2] = op1_ptr[2] + (op2_ptr[2] * op3_ptr[2]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_3X_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MUL_MM_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MM_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 4;
			matrix2_count = op2_count / 4;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 4;
			matrix2_count = op2_count / 2;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 2;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 2;
			matrix2_count = op2_count / 4;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 2;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MTRAN_2X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MTRAN_2X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_2X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_2X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_2X_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (op1_ptr[0 * 2 + 0] * op1_ptr[1 * 2 + 1]) - (op1_ptr[0 * 2 + 1] * op1_ptr[1 * 2 + 0]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_2X_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (op1_ptr[0 * 2 + 0] * op1_ptr[1 * 2 + 1]) - (op1_ptr[0 * 2 + 1] * op1_ptr[1 * 2 + 0]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_2X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 4;
			if(matrix1_count > res_count) {
				res_count = matrix1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_determinant_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DOT_2X_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_2X_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_dot_product_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LEN_2X_F32_F32_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_length_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_2X_F32_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_length_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_2X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_length_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DIS_2X_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_distance_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_2X_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_distance_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_distance_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NORM_2X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NORM_2X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CROSS_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CROSS_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFR_2X_F32_F32_F32_F32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_2x_F32(op1_ptr, op2_ptr, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_REFR_2X_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_TRAN_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_2X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0];
			res_ptr[1] = op1_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_2X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ADD_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + op2_ptr[0];
			res_ptr[1] = op1_ptr[1] + op2_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_add_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] - op2_ptr[0];
			res_ptr[1] = op1_ptr[1] - op2_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] * op2_ptr[0];
			res_ptr[1] = op1_ptr[1] * op2_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] / op2_ptr[0];
			res_ptr[1] = op1_ptr[1] / op2_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_2X_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = fmodf(op1_ptr[0], op2_ptr[0]);
			res_ptr[1] = fmodf(op1_ptr[1], op2_ptr[1]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_2X_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_2X_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = - op1_ptr[0];
			res_ptr[1] = - op1_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_2X_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_2X_F32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			++res_ptr[0];
			++res_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_2X_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_2x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_2X_F32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			--res_ptr[0];
			--res_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_2X_F32_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float32_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_2x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MAC_2X_F32_F32_F32_F32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
			res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_2X_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MUL_MM_F32_F32_F32:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_MM_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
			matrix2_count = op2_count / (MATRIX2_ROWS * MATRIX2_COLS);
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (MATRIX1_ROWS * MATRIX2_COLS);
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_MV_F32_F32_F32:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_MV_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
			matrix2_count = op2_count / (MATRIX2_ROWS * 1);
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (MATRIX1_ROWS * 1);
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_VM_F32_F32_F32:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_VM_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / (1 * MATRIX1_COLS);
			matrix2_count = op2_count / (MATRIX2_ROWS * MATRIX2_COLS);
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (1 * MATRIX2_COLS);
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MTRAN_F32_F32:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MTRAN_F32_F32_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MINV_F32_F32:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MINV_F32_F32_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MDET_F32_F32_VAR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_determinant_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MDET_F32_F32_ELV:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_determinant_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MDET_F32_F32_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
			if(matrix1_count > res_count) {
				res_count = matrix1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_determinant_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_DOT_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_dot_product_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_DOT_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_dot_product_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_DOT_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / MATRIX1_COLS;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_dot_product_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_LEN_F32_F32_VAR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_length_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_LEN_F32_F32_ELV:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_length_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_LEN_F32_F32_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / MATRIX1_COLS;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_length_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_DIS_F32_F32_F32_VAR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float32_t *) segment0) + index;
			
			qb_do_distance_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_DIS_F32_F32_F32_ELV:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			qb_do_distance_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_DIS_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / MATRIX1_COLS;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_distance_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_NORM_F32_F32:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_NORM_F32_F32_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_FORE_F32_F32_F32:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_FORE_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_REFL_F32_F32_F32:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_REFL_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_REFR_F32_F32_F32_F32:
		op_handler = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_F32(op1_ptr, op2_ptr, op3, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_4_matrix_lineno);
		goto *op_handler;
		
		label_REFR_F32_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *op3_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float32_t *) segment0) + index;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_4_matrix_lineno);
		goto *op_handler;
		
		label_CABS_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = (float32_t) sqrt(op1_ptr[0] * op1_ptr[0] + op1_ptr[1] * op1_ptr[1]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CABS_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_abs_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CARG_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = (float32_t) atan2(op1_ptr[1], op1_ptr[0]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CARG_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_argument_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CMUL_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_multiply_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CMUL_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_multiply_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CDIV_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_divide_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CDIV_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_divide_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CEXP_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_exp_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CEXP_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_exp_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CLOG_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_log_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CLOG_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_log_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSQRT_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_square_root_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSQRT_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_square_root_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CPOW_F32_F32_F32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_pow_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CPOW_F32_F32_F32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *op2_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_pow_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CSIN_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_sin_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSIN_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_sin_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CCOS_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_cos_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CCOS_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_cos_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CTAN_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_tan_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CTAN_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_tan_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSINH_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_sinh_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSINH_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_sinh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CCOSH_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_cosh_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CCOSH_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_cosh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CTANH_F32_F32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_tanh_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CTANH_F32_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float32_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_tanh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_IF_EQ_F64_F64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_EQ_F64_F64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			condition = (op1 == op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_NE_F64_F64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_NE_F64_F64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			condition = (op1 != op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LT_F64_F64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LT_F64_F64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			condition = (op1 < op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GT_F64_F64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GT_F64_F64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			condition = (op1 > op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_LE_F64_F64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_LE_F64_F64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			condition = (op1 <= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_IF_GE_F64_F64_VAR:
		op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
		{
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
			}
		}
		goto *op_handler;
		
		label_IF_GE_F64_F64_ELV:
		op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
		{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
			int32_t condition;
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			condition = (op1 >= op2);
			if(condition) {
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
			} else {
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
				instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
			}
#undef PHP_LINE_NUMBER
		}
		goto *op_handler;
		
		label_ADD_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1 + op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_ADD_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1 + op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_add_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1 - op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_SUB_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1 - op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1 * op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MUL_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1 * op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1 / op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_DIV_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1 / op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = fmod(op1, op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = fmod(op1, op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAC_F64_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1 + (op2 * op3);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_MAC_F64_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MOD_FLR_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) (op1 - op2 * floor(op1 / op2));
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MOD_FLR_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) (op1 - op2 * floor(op1 / op2));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_FLR_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_floored_division_modulo_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = - op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_NEG_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = - op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_F64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float64_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((float64_t *) segment0) + index;
			
			++res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_INC_F64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			++res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_F64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float64_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((float64_t *) segment0) + index;
			
			--res;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_DEC_F64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			--res;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_EQ_F64_F64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_EQ_F64_F64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 == op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_F64_F64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_F64(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_F64_F64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_NE_F64_F64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 != op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_F64_F64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_F64(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_F64_F64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LT_F64_F64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 < op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_F64_F64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_F64(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_F64_F64_I32_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_LE_F64_F64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1 <= op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_F64_F64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (qb_compare_array_F64(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_EQ_SET_F64_F64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_equal_vector_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NE_SET_F64_F64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_not_equal_vector_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LT_SET_F64_F64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_vector_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LE_SET_F64_F64_I32:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_less_than_or_equal_vector_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ISSET_F64_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index >= segment_element_counts[selector]) {
				op1_ptr = NULL;
			} else {
				op1_ptr = ((float64_t *) segments[selector]) + index;
			}
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNSET_F64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float64_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = 0;
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_UNSET_F64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(index < segment_element_counts[selector]) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_UNSET_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = ((uint32_t *) segment0)[size_index];
			if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
				qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
			}
			
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MOV_F64_S32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (int32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_S32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (int32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_S32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F64_S32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_U32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			uint32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((uint32_t *) segment0) + index;
			
			res = (uint32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_U32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + index;
			
			res = (uint32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_U32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F64_U32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_S08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			int8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int8_t *) segment0) + index;
			
			res = (int8_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_S08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + index;
			
			res = (int8_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_S08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int8_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F64_S08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_U08_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((uint8_t *) segment0) + index;
			
			res = (uint8_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + index;
			
			res = (uint8_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F64_U08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_S16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			int16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int16_t *) segment0) + index;
			
			res = (int16_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_S16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + index;
			
			res = (int16_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_S16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int16_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F64_S16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_U16_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			uint16_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((uint16_t *) segment0) + index;
			
			res = (uint16_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_U16_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + index;
			
			res = (uint16_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_U16_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint16_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F64_U16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_S64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			int64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int64_t *) segment0) + index;
			
			res = (int64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_S64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + index;
			
			res = (int64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_S64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F64_S64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_U64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			uint64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((uint64_t *) segment0) + index;
			
			res = (uint64_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_U64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + index;
			
			res = (uint64_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_U64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F64_U64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_F32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float32_t *) segment0) + index;
			
			res = (float32_t) op1;
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_MOV_F64_F32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + index;
			
			res = (float32_t) op1;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_F64_F32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float32_t *) segments[selector]) + res_start_index;
			
			qb_do_cast_multiple_times_F64_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_F64_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = !(!(op1));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_BOOL_F64_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = !(!(op1));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_BOOL_F64_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_boolean_cast_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) fabs(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ABS_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) fabs(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ABS_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_abs_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIN_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (op1 < op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MIN_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MIN_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_min_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (op1 > op2) ? op1 : op2;
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_MAX_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MAX_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_max_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SIN_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) sin(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_SIN_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) sin(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SIN_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sin_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASIN_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = asin(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ASIN_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = asin(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASIN_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_asin_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_COS_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = cos(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_COS_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = cos(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_COS_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cos_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ACOS_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) acos(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ACOS_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) acos(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ACOS_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_acos_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_TAN_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = tan(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_TAN_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = tan(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_TAN_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_tan_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATAN_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = atan(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ATAN_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = atan(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATAN_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_atan_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATAN2_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = atan2(op1, op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_ATAN2_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = atan2(op1, op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ATAN2_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_atan2_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SINH_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = sinh(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_SINH_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = sinh(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SINH_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sinh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASINH_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = asinh(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ASINH_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = asinh(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASINH_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_asinh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_COSH_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = cosh(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_COSH_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = cosh(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_COSH_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cosh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ACOSH_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = acosh(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ACOSH_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = acosh(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ACOSH_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_acosh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_TANH_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = tanh(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_TANH_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = tanh(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_TANH_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_tanh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATANH_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = atanh(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_ATANH_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = atanh(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ATANH_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_atanh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CEIL_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = ceil(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_CEIL_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = ceil(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CEIL_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_ceil_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_FLOOR_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) floor(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_FLOOR_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) floor(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_FLOOR_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_floor_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ROUND_F64_I32_I32_F64_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) _php_math_round(op1, op2, op3);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_ROUND_F64_I32_I32_F64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int32_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) _php_math_round(op1, op2, op3);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_ROUND_F64_I32_I32_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *op2_ptr;
			int32_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((int32_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_round_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_LOG_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = log(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_LOG_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = log(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_log_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG1P_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = log1p(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_LOG1P_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = log1p(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG1P_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_log1p_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG2_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = log2(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_LOG2_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = log2(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG2_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_log2_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG10_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = log10(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_LOG10_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = log10(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LOG10_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_log10_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXP_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = exp(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_EXP_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = exp(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXP_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_exp_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXPM1_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = expm1(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_EXPM1_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = expm1(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXPM1_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_exp_m1_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXP2_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = exp2(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_EXP2_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = exp2(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXP2_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_exp2_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_POW_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = pow(op1, op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_POW_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = pow(op1, op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_POW_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_pow_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SQRT_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = sqrt(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_SQRT_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = sqrt(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SQRT_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sqrt_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_HYPOT_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = (float64_t) hypot(op1, op2);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_HYPOT_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = (float64_t) hypot(op1, op2);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_HYPOT_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_hypot_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LCG_F64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float64_t *res_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_lcg_F64(cxt, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_LCG_F64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_lcg_F64(cxt, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_LCG_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_lcg_multiple_times_F64(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_FIN_F64_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = zend_finite(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_FIN_F64_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = zend_finite(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_FIN_F64_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_is_finite_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INF_F64_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = (zend_isinf(op1) != 0);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_INF_F64_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = (zend_isinf(op1) != 0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INF_F64_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_is_infinite_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NAN_F64_I32_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((int32_t *) segment0) + index;
			
			res = zend_isnan(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_NAN_F64_I32_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + index;
			
			res = zend_isnan(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NAN_F64_I32_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((int32_t *) segments[selector]) + res_start_index;
			
			qb_do_is_nan_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RSQRT_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = qb_fast_rsqrt(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_RSQRT_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = qb_fast_rsqrt(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RSQRT_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_rsqrt_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CLAMP_F64_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_clamp_F64(op1, op2, op3, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_CLAMP_F64_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_clamp_F64(op1, op2, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_CLAMP_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_clamp_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_FRACT_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1 - floor(op1);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_FRACT_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1 - floor(op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_FRACT_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_fract_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MIX_F64_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1 * (1 - op3) + op2 * op3;
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_MIX_F64_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1 * (1 - op3) + op2 * op3;
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MIX_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_mix_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_SIGN_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_sign_F64(op1, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_SIGN_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_sign_F64(op1, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SIGN_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sign_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_STEP_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3 *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = ((op2 < op1) ? 0.0 : 1.0);
		}
		instruction_pointer += sizeof(qb_instruction_3);
		goto *op_handler;
		
		label_STEP_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = ((op2 < op1) ? 0.0 : 1.0);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_STEP_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_step_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SSTEP_F64_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4 *) instruction_pointer)->operand4;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_smooth_step_F64(op1, op2, op3, res_ptr);
		}
		instruction_pointer += sizeof(qb_instruction_4);
		goto *op_handler;
		
		label_SSTEP_F64_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_smooth_step_F64(op1, op2, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_SSTEP_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_smooth_step_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_RAD2DEG_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1 * ((float64_t) (180 / M_PI));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_RAD2DEG_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1 * ((float64_t) (180 / M_PI));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RAD2DEG_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_radian_to_degree_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DEG2RAD_F64_F64_VAR:
		op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_2 *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			res = op1 * ((float64_t) (M_PI / 180.0));
		}
		instruction_pointer += sizeof(qb_instruction_2);
		goto *op_handler;
		
		label_DEG2RAD_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			res = op1 * ((float64_t) (M_PI / 180.0));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DEG2RAD_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_degree_to_radian_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PRN_F64_VAR:
		op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
		{
			float64_t *op1_ptr;
			
			index = ((qb_instruction_1 *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			qb_do_print_variable_F64(cxt, op1);
		}
		instruction_pointer += sizeof(qb_instruction_1);
		goto *op_handler;
		
		label_PRN_F64_ELV:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_print_variable_F64(cxt, op1);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			qb_do_print_variable_multiple_times_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_PRN_DIM_F64_U32:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			qb_do_print_multidimensional_variable_F64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_F64_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_F64(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_F64(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_F64_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_scalar_sprintf_length_F64(cxt, op1);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_F64(cxt, op1, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_F64_U08_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_array_sprintf_length_F64(cxt, op1_ptr, op1_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_variable_multiple_times_F64(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CAT_DIM_F64_U32_U08:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_multidimensional_array_sprintf_length_F64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
			res_count = res_count + string_length;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_concat_multidimensional_variable_F64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PACK_LE_F64_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(8 > res_count) {
				res_count = 8;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_pack_F64(op1, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_LE_F64_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(8 > res_count) {
				res_count = 8;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_pack_F64(op1, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_F64_U08_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(8 > res_count) {
				res_count = 8;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_pack_F64(op1, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_PACK_BE_F64_U08_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint8_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(8 > res_count) {
				res_count = 8;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
			
			qb_do_pack_F64(op1, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			*((uint64_t *) &res) = SWAP_LE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_LE_U08_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			*((uint64_t *) &res) = SWAP_LE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			*((uint64_t *) &res) = SWAP_BE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPACK_BE_U08_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			uint8_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			*((uint64_t *) &res) = SWAP_BE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_SORT_F64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_scalar_sort_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_RSORT_F64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_reverse_scalar_sort_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_AMIN_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_array_min_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_array_max_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_array_product_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_array_sum_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_F64_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_F64(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_range_F64(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AMIN_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_array_min_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_AMAX_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_array_max_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_APROD_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_array_product_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ASUM_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_array_sum_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_RANGE_F64_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_range_length_F64(op1, op2, op3);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_range_F64(op1, op2, op3, string_length, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_F64_F64_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_F64(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_F64_F64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_F64(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_IDX_F64_F64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_array_search_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_F64_F64_I32_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_F64(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_F64_F64_I32_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_F64(op1_ptr, op1_count, op2, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AFIND_F64_F64_I32_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_in_array_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_APOS_F64_F64_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_ARPOS_F64_F64_I32_I32:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			int32_t *op3_ptr;
			int32_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((int32_t *) segment0) + index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
			res_ptr = ((int32_t *) segment0) + index;
			
			qb_do_subarray_position_from_end_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_AREV_F64_U32_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_array_reverse_F64(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AINS_F64_U32_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			res_count = res_count + op1_count;
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_array_insert_F64(op1_ptr, op1_count, op2, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_AUNIQ_F64_U32_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			string_length = qb_get_unique_element_count_F64(op1_ptr, op1_count, op2);
			if(string_length > res_count) {
				res_count = string_length;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_array_unique_F64(op1_ptr, op1_count, op2, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
			op4_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
			op5_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_4x_F64(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_4x_F64(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
			op4_start_index = ((uint32_t *) segment0)[index_index];
			op4_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float64_t *) segments[selector]) + op4_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
			op5_start_index = ((uint32_t *) segment0)[index_index];
			op5_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float64_t *) segments[selector]) + op5_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op4_count * 4 > res_count) {
				res_count = op4_count * 4;
			}
			if(op5_count * 4 > res_count) {
				res_count = op5_count * 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_4x_multiple_times_F64(op1_ptr, op1_count, op2, op3, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
			op4_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
			op5_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(3 > res_count) {
				res_count = 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_3x_F64(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(3 > res_count) {
				res_count = 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_3x_F64(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
			op4_start_index = ((uint32_t *) segment0)[index_index];
			op4_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float64_t *) segments[selector]) + op4_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
			op5_start_index = ((uint32_t *) segment0)[index_index];
			op5_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float64_t *) segments[selector]) + op5_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op4_count * 3 > res_count) {
				res_count = op4_count * 3;
			}
			if(op5_count * 3 > res_count) {
				res_count = op5_count * 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_nearest_3x_multiple_times_F64(op1_ptr, op1_count, op2, op3, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
			op4_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
			op5_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_4x_F64(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(4 > res_count) {
				res_count = 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_4x_F64(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
			op4_start_index = ((uint32_t *) segment0)[index_index];
			op4_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float64_t *) segments[selector]) + op4_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
			op5_start_index = ((uint32_t *) segment0)[index_index];
			op5_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float64_t *) segments[selector]) + op5_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op4_count * 4 > res_count) {
				res_count = op4_count * 4;
			}
			if(op5_count * 4 > res_count) {
				res_count = op5_count * 4;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_4x_multiple_times_F64(op1_ptr, op1_count, op2, op3, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
			op4_ptr = ((float64_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
			op5_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(3 > res_count) {
				res_count = 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_3x_F64(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float64_t *) segments[selector]) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(3 > res_count) {
				res_count = 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_3x_F64(op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			uint32_t *op2_ptr;
			uint32_t *op3_ptr;
			float64_t *op4_ptr;
			float64_t *op5_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
			op2_ptr = ((uint32_t *) segment0) + index;
			
			index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((uint32_t *) segment0) + index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
			op4_start_index = ((uint32_t *) segment0)[index_index];
			op4_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
			}
			op4_ptr = ((float64_t *) segments[selector]) + op4_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
			op5_start_index = ((uint32_t *) segment0)[index_index];
			op5_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
			}
			op5_ptr = ((float64_t *) segments[selector]) + op5_start_index;
			
			selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
			index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
			size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op4_count * 3 > res_count) {
				res_count = op4_count * 3;
			}
			if(op5_count * 3 > res_count) {
				res_count = op5_count * 3;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_sample_bilinear_3x_multiple_times_F64(op1_ptr, op1_count, op2, op3, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_6_lineno);
		goto *op_handler;
		
		label_BLEND_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_alpha_blend_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_PREMULT_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_apply_premultiplication_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_UNPREMULT_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_remove_premultiplication_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MUL_MM_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MM_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 16;
			matrix2_count = op2_count / 16;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 16;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 16;
			matrix2_count = op2_count / 4;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 4;
			matrix2_count = op2_count / 16;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MTRAN_4X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MTRAN_4X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_4X_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_determinant_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_4X_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_determinant_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_4X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 16;
			if(matrix1_count > res_count) {
				res_count = matrix1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_determinant_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_4X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_4X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DOT_4X_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_dot_product_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_4X_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_dot_product_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 4;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_dot_product_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LEN_4X_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_length_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_4X_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_length_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_4X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 4;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_length_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DIS_4X_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_distance_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_4X_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_distance_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 4;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_distance_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NORM_4X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NORM_4X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CROSS_4X_F64_F64_F64_F64:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_4x_F64(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_CROSS_4X_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_FORE_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFR_4X_F64_F64_F64_F64:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_4x_F64(op1_ptr, op2_ptr, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_REFR_4X_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_TRAN_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_4X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0];
			res_ptr[1] = op1_ptr[1];
			res_ptr[2] = op1_ptr[2];
			res_ptr[3] = op1_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_4X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ADD_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + op2_ptr[0];
			res_ptr[1] = op1_ptr[1] + op2_ptr[1];
			res_ptr[2] = op1_ptr[2] + op2_ptr[2];
			res_ptr[3] = op1_ptr[3] + op2_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_add_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] - op2_ptr[0];
			res_ptr[1] = op1_ptr[1] - op2_ptr[1];
			res_ptr[2] = op1_ptr[2] - op2_ptr[2];
			res_ptr[3] = op1_ptr[3] - op2_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] * op2_ptr[0];
			res_ptr[1] = op1_ptr[1] * op2_ptr[1];
			res_ptr[2] = op1_ptr[2] * op2_ptr[2];
			res_ptr[3] = op1_ptr[3] * op2_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] / op2_ptr[0];
			res_ptr[1] = op1_ptr[1] / op2_ptr[1];
			res_ptr[2] = op1_ptr[2] / op2_ptr[2];
			res_ptr[3] = op1_ptr[3] / op2_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_4X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = fmod(op1_ptr[0], op2_ptr[0]);
			res_ptr[1] = fmod(op1_ptr[1], op2_ptr[1]);
			res_ptr[2] = fmod(op1_ptr[2], op2_ptr[2]);
			res_ptr[3] = fmod(op1_ptr[3], op2_ptr[3]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_4X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_4X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = - op1_ptr[0];
			res_ptr[1] = - op1_ptr[1];
			res_ptr[2] = - op1_ptr[2];
			res_ptr[3] = - op1_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_4X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_4X_F64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			++res_ptr[0];
			++res_ptr[1];
			++res_ptr[2];
			++res_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_4X_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_4x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_4X_F64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			--res_ptr[0];
			--res_ptr[1];
			--res_ptr[2];
			--res_ptr[3];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_4X_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_4x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MAC_4X_F64_F64_F64_F64:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
			res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
			res_ptr[2] = op1_ptr[2] + (op2_ptr[2] * op3_ptr[2]);
			res_ptr[3] = op1_ptr[3] + (op2_ptr[3] * op3_ptr[3]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_4X_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MUL_MM_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MM_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 9;
			matrix2_count = op2_count / 9;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 9;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 9;
			matrix2_count = op2_count / 3;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 3;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 3;
			matrix2_count = op2_count / 9;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 3;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MTRAN_3X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MTRAN_3X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_3X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_3X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_3X_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_determinant_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_3X_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_determinant_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_3X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 9;
			if(matrix1_count > res_count) {
				res_count = matrix1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_determinant_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DOT_3X_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_dot_product_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_3X_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_dot_product_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 3;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_dot_product_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LEN_3X_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_length_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_3X_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_length_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_3X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 3;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_length_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DIS_3X_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_distance_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_3X_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_distance_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 3;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_distance_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NORM_3X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NORM_3X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CROSS_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CROSS_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFR_3X_F64_F64_F64_F64:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_3x_F64(op1_ptr, op2_ptr, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_REFR_3X_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_TRAN_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_3X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0];
			res_ptr[1] = op1_ptr[1];
			res_ptr[2] = op1_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_3X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ADD_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + op2_ptr[0];
			res_ptr[1] = op1_ptr[1] + op2_ptr[1];
			res_ptr[2] = op1_ptr[2] + op2_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_add_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] - op2_ptr[0];
			res_ptr[1] = op1_ptr[1] - op2_ptr[1];
			res_ptr[2] = op1_ptr[2] - op2_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] * op2_ptr[0];
			res_ptr[1] = op1_ptr[1] * op2_ptr[1];
			res_ptr[2] = op1_ptr[2] * op2_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] / op2_ptr[0];
			res_ptr[1] = op1_ptr[1] / op2_ptr[1];
			res_ptr[2] = op1_ptr[2] / op2_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_3X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = fmod(op1_ptr[0], op2_ptr[0]);
			res_ptr[1] = fmod(op1_ptr[1], op2_ptr[1]);
			res_ptr[2] = fmod(op1_ptr[2], op2_ptr[2]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_3X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_3X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = - op1_ptr[0];
			res_ptr[1] = - op1_ptr[1];
			res_ptr[2] = - op1_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_3X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_3X_F64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			++res_ptr[0];
			++res_ptr[1];
			++res_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_3X_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_3x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_3X_F64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			--res_ptr[0];
			--res_ptr[1];
			--res_ptr[2];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_3X_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_3x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MAC_3X_F64_F64_F64_F64:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
			res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
			res_ptr[2] = op1_ptr[2] + (op2_ptr[2] * op3_ptr[2]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_3X_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MUL_MM_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MM_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 4;
			matrix2_count = op2_count / 4;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_MV_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 4;
			matrix2_count = op2_count / 2;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 2;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_VM_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 2;
			matrix2_count = op2_count / 4;
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 2;
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MTRAN_2X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MTRAN_2X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_2X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MINV_2X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_2X_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_determinant_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_2X_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_determinant_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MDET_2X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / 4;
			if(matrix1_count > res_count) {
				res_count = matrix1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_determinant_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DOT_2X_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_dot_product_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_2X_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_dot_product_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DOT_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_dot_product_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_LEN_2X_F64_F64_VAR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_length_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_2X_F64_F64_ELV:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_length_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_LEN_2X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_length_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_DIS_2X_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_distance_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_2X_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_distance_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIS_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_distance_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NORM_2X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NORM_2X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CROSS_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CROSS_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_cross_product_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_FORE_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFL_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_REFR_2X_F64_F64_F64_F64:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_2x_F64(op1_ptr, op2_ptr, op3, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_REFR_2X_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_TRAN_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_cm_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_TRAN_RM_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transform_vector_rm_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOV_2X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0];
			res_ptr[1] = op1_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_MOV_2X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_copy_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_ADD_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + op2_ptr[0];
			res_ptr[1] = op1_ptr[1] + op2_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_ADD_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_add_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] - op2_ptr[0];
			res_ptr[1] = op1_ptr[1] - op2_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_SUB_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_subtract_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] * op2_ptr[0];
			res_ptr[1] = op1_ptr[1] * op2_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MUL_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] / op2_ptr[0];
			res_ptr[1] = op1_ptr[1] / op2_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_DIV_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_divide_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_2X_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = fmod(op1_ptr[0], op2_ptr[0]);
			res_ptr[1] = fmod(op1_ptr[1], op2_ptr[1]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_MOD_2X_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_modulo_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_NEG_2X_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = - op1_ptr[0];
			res_ptr[1] = - op1_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_NEG_2X_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_negate_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_INC_2X_F64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			++res_ptr[0];
			++res_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_INC_2X_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_increment_2x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_2X_F64:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			--res_ptr[0];
			--res_ptr[1];
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_DEC_2X_F64_ARR:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			float64_t *res_ptr;
			
			selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_decrement_2x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_MAC_2X_F64_F64_F64_F64:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
			res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MAC_2X_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
			op3_start_index = ((uint32_t *) segment0)[index_index];
			op3_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
			}
			op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
			
			selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(op3_count > res_count) {
				res_count = op3_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_accumulate_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_4_lineno);
		goto *op_handler;
		
		label_MUL_MM_F64_F64_F64:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_MM_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
			matrix2_count = op2_count / (MATRIX2_ROWS * MATRIX2_COLS);
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (MATRIX1_ROWS * MATRIX2_COLS);
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_matrix_cm_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_MV_F64_F64_F64:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_MV_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
			matrix2_count = op2_count / (MATRIX2_ROWS * 1);
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (MATRIX1_ROWS * 1);
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_matrix_by_vector_cm_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_VM_F64_F64_F64:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MUL_VM_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / (1 * MATRIX1_COLS);
			matrix2_count = op2_count / (MATRIX2_ROWS * MATRIX2_COLS);
			mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (1 * MATRIX2_COLS);
			if(mmult_res_count > res_count) {
				res_count = mmult_res_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_multiply_vector_by_matrix_cm_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_MTRAN_F64_F64:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MTRAN_F64_F64_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_transpose_matrix_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MINV_F64_F64:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MINV_F64_F64_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_invert_matrix_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MDET_F64_F64_VAR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_determinant_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MDET_F64_F64_ELV:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_determinant_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_MDET_F64_F64_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
			if(matrix1_count > res_count) {
				res_count = matrix1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_determinant_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_DOT_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_dot_product_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_DOT_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_dot_product_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_DOT_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / MATRIX1_COLS;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_dot_product_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_LEN_F64_F64_VAR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_length_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_LEN_F64_F64_ELV:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_length_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_LEN_F64_F64_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / MATRIX1_COLS;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_length_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_DIS_F64_F64_F64_VAR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3;
			res_ptr = ((float64_t *) segment0) + index;
			
			qb_do_distance_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_DIS_F64_F64_F64_ELV:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8;
			index = ((uint32_t *) segment0)[index_index];
			if(UNEXPECTED(index >= segment_element_counts[selector])) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + index;
			
			qb_do_distance_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_DIS_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / MATRIX1_COLS;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_distance_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_NORM_F64_F64:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_NORM_F64_F64_ARR:
		op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_normalize_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
		goto *op_handler;
		
		label_FORE_F64_F64_F64:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_FORE_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_face_forward_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_REFL_F64_F64_F64:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_REFL_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_reflect_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
		}
		instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
		goto *op_handler;
		
		label_REFR_F64_F64_F64_F64:
		op_handler = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_F64(op1_ptr, op2_ptr, op3, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_4_matrix_lineno);
		goto *op_handler;
		
		label_REFR_F64_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_4_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *op3_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand3;
			op3_ptr = ((float64_t *) segment0) + index;
			
			selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 & 0x00FF;
			index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
			size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_refract_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
		}
		instruction_pointer += sizeof(qb_instruction_4_matrix_lineno);
		goto *op_handler;
		
		label_CABS_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_abs_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CABS_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_abs_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CARG_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_argument_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CARG_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			vector_count = op1_count / 2;
			if(vector_count > res_count) {
				res_count = vector_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_argument_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CMUL_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_multiply_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CMUL_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_multiply_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CDIV_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_divide_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CDIV_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_divide_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CEXP_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_exp_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CEXP_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_exp_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CLOG_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_log_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CLOG_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_log_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSQRT_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_square_root_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSQRT_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_square_root_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CPOW_F64_F64_F64:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_pow_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CPOW_F64_F64_F64_ARR:
		op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *op2_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
			op2_start_index = ((uint32_t *) segment0)[index_index];
			op2_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
			}
			op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
			
			selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
			index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
			size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(op2_count > res_count) {
				res_count = op2_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_pow_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_3_lineno);
		goto *op_handler;
		
		label_CSIN_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_sin_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSIN_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_sin_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CCOS_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_cos_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CCOS_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_cos_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CTAN_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_tan_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CTAN_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_tan_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSINH_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_sinh_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CSINH_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_sinh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CCOSH_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_cosh_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CCOSH_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_cosh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CTANH_F64_F64:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_tanh_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_CTANH_F64_F64_ARR:
		op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
			float64_t *op1_ptr;
			float64_t *res_ptr;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
			op1_start_index = ((uint32_t *) segment0)[index_index];
			op1_count = ((uint32_t *) segment0)[size_index];
			if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
				qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
			}
			op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
			
			selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
			index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
			size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
			res_start_index = ((uint32_t *) segment0)[index_index];
			res_count = res_count_before = ((uint32_t *) segment0)[size_index];
			if(op1_count > res_count) {
				res_count = op1_count;
			}
			if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
				if(segment_expandable[selector]) {
					qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
				} else {
					qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
				}
			}
			res_ptr = ((float64_t *) segments[selector]) + res_start_index;
			
			qb_do_complex_tanh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_2_lineno);
		goto *op_handler;
		
		label_EXT_U32:
		op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
		{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
			uint32_t *op1_ptr;
			
			index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
			op1_ptr = ((uint32_t *) segment0) + index;
			
			qb_run_zend_extension_op(cxt, op1, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
		}
		instruction_pointer += sizeof(qb_instruction_1_lineno);
		goto *op_handler;
		
		label_exit:
		{
			uint32_t i;
			// point the stack_ref pointer back to variables in the structure
			for(i = 0; i < cxt->storage->segment_count; i++) {
				qb_memory_segment *segment = &cxt->storage->segments[i];
				segment->stack_ref_memory = &segment->memory;
				segment->stack_ref_element_count = &segment->element_count;
			}
			return;
		}
	} else {
		op_handlers[QB_NOP] = &&label_NOP;
		op_handlers[QB_JMP] = &&label_JMP;
		op_handlers[QB_RET] = &&label_RET;
		op_handlers[QB_EXIT_I32] = &&label_EXIT_I32;
		op_handlers[QB_FCALL_VAR] = &&label_FCALL_VAR;
		op_handlers[QB_FCALL_MIX] = &&label_FCALL_MIX;
		op_handlers[QB_IF_INIT] = &&label_IF_INIT;
		op_handlers[QB_IF_T_I32_VAR] = &&label_IF_T_I32_VAR;
		op_handlers[QB_IF_T_I32_ELV] = &&label_IF_T_I32_ELV;
		op_handlers[QB_IF_F_I32_VAR] = &&label_IF_F_I32_VAR;
		op_handlers[QB_IF_F_I32_ELV] = &&label_IF_F_I32_ELV;
		op_handlers[QB_IF_EQ_I32_I32_VAR] = &&label_IF_EQ_I32_I32_VAR;
		op_handlers[QB_IF_EQ_I32_I32_ELV] = &&label_IF_EQ_I32_I32_ELV;
		op_handlers[QB_IF_NE_I32_I32_VAR] = &&label_IF_NE_I32_I32_VAR;
		op_handlers[QB_IF_NE_I32_I32_ELV] = &&label_IF_NE_I32_I32_ELV;
		op_handlers[QB_IF_LT_S32_S32_VAR] = &&label_IF_LT_S32_S32_VAR;
		op_handlers[QB_IF_LT_S32_S32_ELV] = &&label_IF_LT_S32_S32_ELV;
		op_handlers[QB_IF_GT_S32_S32_VAR] = &&label_IF_GT_S32_S32_VAR;
		op_handlers[QB_IF_GT_S32_S32_ELV] = &&label_IF_GT_S32_S32_ELV;
		op_handlers[QB_IF_LE_S32_S32_VAR] = &&label_IF_LE_S32_S32_VAR;
		op_handlers[QB_IF_LE_S32_S32_ELV] = &&label_IF_LE_S32_S32_ELV;
		op_handlers[QB_IF_GE_S32_S32_VAR] = &&label_IF_GE_S32_S32_VAR;
		op_handlers[QB_IF_GE_S32_S32_ELV] = &&label_IF_GE_S32_S32_ELV;
		op_handlers[QB_ADD_I32_I32_I32_VAR] = &&label_ADD_I32_I32_I32_VAR;
		op_handlers[QB_ADD_I32_I32_I32_ELV] = &&label_ADD_I32_I32_I32_ELV;
		op_handlers[QB_ADD_I32_I32_I32_ARR] = &&label_ADD_I32_I32_I32_ARR;
		op_handlers[QB_SUB_I32_I32_I32_VAR] = &&label_SUB_I32_I32_I32_VAR;
		op_handlers[QB_SUB_I32_I32_I32_ELV] = &&label_SUB_I32_I32_I32_ELV;
		op_handlers[QB_SUB_I32_I32_I32_ARR] = &&label_SUB_I32_I32_I32_ARR;
		op_handlers[QB_MUL_S32_S32_S32_VAR] = &&label_MUL_S32_S32_S32_VAR;
		op_handlers[QB_MUL_S32_S32_S32_ELV] = &&label_MUL_S32_S32_S32_ELV;
		op_handlers[QB_MUL_S32_S32_S32_ARR] = &&label_MUL_S32_S32_S32_ARR;
		op_handlers[QB_DIV_S32_S32_S32_VAR] = &&label_DIV_S32_S32_S32_VAR;
		op_handlers[QB_DIV_S32_S32_S32_ELV] = &&label_DIV_S32_S32_S32_ELV;
		op_handlers[QB_DIV_S32_S32_S32_ARR] = &&label_DIV_S32_S32_S32_ARR;
		op_handlers[QB_MOD_S32_S32_S32_VAR] = &&label_MOD_S32_S32_S32_VAR;
		op_handlers[QB_MOD_S32_S32_S32_ELV] = &&label_MOD_S32_S32_S32_ELV;
		op_handlers[QB_MOD_S32_S32_S32_ARR] = &&label_MOD_S32_S32_S32_ARR;
		op_handlers[QB_MAC_S32_S32_S32_S32_VAR] = &&label_MAC_S32_S32_S32_S32_VAR;
		op_handlers[QB_MAC_S32_S32_S32_S32_ELV] = &&label_MAC_S32_S32_S32_S32_ELV;
		op_handlers[QB_MAC_S32_S32_S32_S32_ARR] = &&label_MAC_S32_S32_S32_S32_ARR;
		op_handlers[QB_NEG_I32_I32_VAR] = &&label_NEG_I32_I32_VAR;
		op_handlers[QB_NEG_I32_I32_ELV] = &&label_NEG_I32_I32_ELV;
		op_handlers[QB_NEG_I32_I32_ARR] = &&label_NEG_I32_I32_ARR;
		op_handlers[QB_MOV_I32_I32_VAR] = &&label_MOV_I32_I32_VAR;
		op_handlers[QB_MOV_I32_I32_ELV] = &&label_MOV_I32_I32_ELV;
		op_handlers[QB_MOV_I32_I32_ARR] = &&label_MOV_I32_I32_ARR;
		op_handlers[QB_INC_I32_VAR] = &&label_INC_I32_VAR;
		op_handlers[QB_INC_I32_ELV] = &&label_INC_I32_ELV;
		op_handlers[QB_INC_I32_ARR] = &&label_INC_I32_ARR;
		op_handlers[QB_DEC_I32_VAR] = &&label_DEC_I32_VAR;
		op_handlers[QB_DEC_I32_ELV] = &&label_DEC_I32_ELV;
		op_handlers[QB_DEC_I32_ARR] = &&label_DEC_I32_ARR;
		op_handlers[QB_EQ_I32_I32_I32_VAR] = &&label_EQ_I32_I32_I32_VAR;
		op_handlers[QB_EQ_I32_I32_I32_ELV] = &&label_EQ_I32_I32_I32_ELV;
		op_handlers[QB_EQ_I32_I32_I32_ARR] = &&label_EQ_I32_I32_I32_ARR;
		op_handlers[QB_NE_I32_I32_I32_VAR] = &&label_NE_I32_I32_I32_VAR;
		op_handlers[QB_NE_I32_I32_I32_ELV] = &&label_NE_I32_I32_I32_ELV;
		op_handlers[QB_NE_I32_I32_I32_ARR] = &&label_NE_I32_I32_I32_ARR;
		op_handlers[QB_LT_S32_S32_I32_VAR] = &&label_LT_S32_S32_I32_VAR;
		op_handlers[QB_LT_S32_S32_I32_ELV] = &&label_LT_S32_S32_I32_ELV;
		op_handlers[QB_LT_S32_S32_I32_ARR] = &&label_LT_S32_S32_I32_ARR;
		op_handlers[QB_LE_S32_S32_I32_VAR] = &&label_LE_S32_S32_I32_VAR;
		op_handlers[QB_LE_S32_S32_I32_ELV] = &&label_LE_S32_S32_I32_ELV;
		op_handlers[QB_LE_S32_S32_I32_ARR] = &&label_LE_S32_S32_I32_ARR;
		op_handlers[QB_EQ_SET_I32_I32_I32] = &&label_EQ_SET_I32_I32_I32;
		op_handlers[QB_NE_SET_I32_I32_I32] = &&label_NE_SET_I32_I32_I32;
		op_handlers[QB_LT_SET_S32_S32_I32] = &&label_LT_SET_S32_S32_I32;
		op_handlers[QB_LE_SET_S32_S32_I32] = &&label_LE_SET_S32_S32_I32;
		op_handlers[QB_NOT_SET_I32_I32] = &&label_NOT_SET_I32_I32;
		op_handlers[QB_ANY_I32_I32_VAR] = &&label_ANY_I32_I32_VAR;
		op_handlers[QB_ANY_I32_I32_ELV] = &&label_ANY_I32_I32_ELV;
		op_handlers[QB_ALL_I32_I32_VAR] = &&label_ALL_I32_I32_VAR;
		op_handlers[QB_ALL_I32_I32_ELV] = &&label_ALL_I32_I32_ELV;
		op_handlers[QB_BW_AND_I32_I32_I32_VAR] = &&label_BW_AND_I32_I32_I32_VAR;
		op_handlers[QB_BW_AND_I32_I32_I32_ELV] = &&label_BW_AND_I32_I32_I32_ELV;
		op_handlers[QB_BW_AND_I32_I32_I32_ARR] = &&label_BW_AND_I32_I32_I32_ARR;
		op_handlers[QB_BW_OR_I32_I32_I32_VAR] = &&label_BW_OR_I32_I32_I32_VAR;
		op_handlers[QB_BW_OR_I32_I32_I32_ELV] = &&label_BW_OR_I32_I32_I32_ELV;
		op_handlers[QB_BW_OR_I32_I32_I32_ARR] = &&label_BW_OR_I32_I32_I32_ARR;
		op_handlers[QB_BW_XOR_I32_I32_I32_VAR] = &&label_BW_XOR_I32_I32_I32_VAR;
		op_handlers[QB_BW_XOR_I32_I32_I32_ELV] = &&label_BW_XOR_I32_I32_I32_ELV;
		op_handlers[QB_BW_XOR_I32_I32_I32_ARR] = &&label_BW_XOR_I32_I32_I32_ARR;
		op_handlers[QB_BW_NOT_I32_I32_VAR] = &&label_BW_NOT_I32_I32_VAR;
		op_handlers[QB_BW_NOT_I32_I32_ELV] = &&label_BW_NOT_I32_I32_ELV;
		op_handlers[QB_BW_NOT_I32_I32_ARR] = &&label_BW_NOT_I32_I32_ARR;
		op_handlers[QB_SHL_S32_S32_S32_VAR] = &&label_SHL_S32_S32_S32_VAR;
		op_handlers[QB_SHL_S32_S32_S32_ELV] = &&label_SHL_S32_S32_S32_ELV;
		op_handlers[QB_SHL_S32_S32_S32_ARR] = &&label_SHL_S32_S32_S32_ARR;
		op_handlers[QB_SHR_S32_S32_S32_VAR] = &&label_SHR_S32_S32_S32_VAR;
		op_handlers[QB_SHR_S32_S32_S32_ELV] = &&label_SHR_S32_S32_S32_ELV;
		op_handlers[QB_SHR_S32_S32_S32_ARR] = &&label_SHR_S32_S32_S32_ARR;
		op_handlers[QB_AND_I32_I32_I32_VAR] = &&label_AND_I32_I32_I32_VAR;
		op_handlers[QB_OR_I32_I32_I32_VAR] = &&label_OR_I32_I32_I32_VAR;
		op_handlers[QB_XOR_I32_I32_I32_VAR] = &&label_XOR_I32_I32_I32_VAR;
		op_handlers[QB_NOT_I32_I32_VAR] = &&label_NOT_I32_I32_VAR;
		op_handlers[QB_ISSET_I32_I32_ELV] = &&label_ISSET_I32_I32_ELV;
		op_handlers[QB_UNSET_I32_VAR] = &&label_UNSET_I32_VAR;
		op_handlers[QB_UNSET_I32_ELV] = &&label_UNSET_I32_ELV;
		op_handlers[QB_UNSET_I32_ARR] = &&label_UNSET_I32_ARR;
		op_handlers[QB_MOV_I32_I08_VAR] = &&label_MOV_I32_I08_VAR;
		op_handlers[QB_MOV_I32_I08_ELV] = &&label_MOV_I32_I08_ELV;
		op_handlers[QB_MOV_I32_I08_ARR] = &&label_MOV_I32_I08_ARR;
		op_handlers[QB_MOV_I32_I16_VAR] = &&label_MOV_I32_I16_VAR;
		op_handlers[QB_MOV_I32_I16_ELV] = &&label_MOV_I32_I16_ELV;
		op_handlers[QB_MOV_I32_I16_ARR] = &&label_MOV_I32_I16_ARR;
		op_handlers[QB_MOV_S32_I64_VAR] = &&label_MOV_S32_I64_VAR;
		op_handlers[QB_MOV_S32_I64_ELV] = &&label_MOV_S32_I64_ELV;
		op_handlers[QB_MOV_S32_I64_ARR] = &&label_MOV_S32_I64_ARR;
		op_handlers[QB_MOV_S32_F32_VAR] = &&label_MOV_S32_F32_VAR;
		op_handlers[QB_MOV_S32_F32_ELV] = &&label_MOV_S32_F32_ELV;
		op_handlers[QB_MOV_S32_F32_ARR] = &&label_MOV_S32_F32_ARR;
		op_handlers[QB_MOV_S32_F64_VAR] = &&label_MOV_S32_F64_VAR;
		op_handlers[QB_MOV_S32_F64_ELV] = &&label_MOV_S32_F64_ELV;
		op_handlers[QB_MOV_S32_F64_ARR] = &&label_MOV_S32_F64_ARR;
		op_handlers[QB_BOOL_I32_I32_VAR] = &&label_BOOL_I32_I32_VAR;
		op_handlers[QB_BOOL_I32_I32_ELV] = &&label_BOOL_I32_I32_ELV;
		op_handlers[QB_BOOL_I32_I32_ARR] = &&label_BOOL_I32_I32_ARR;
		op_handlers[QB_ABS_S32_S32_VAR] = &&label_ABS_S32_S32_VAR;
		op_handlers[QB_ABS_S32_S32_ELV] = &&label_ABS_S32_S32_ELV;
		op_handlers[QB_ABS_S32_S32_ARR] = &&label_ABS_S32_S32_ARR;
		op_handlers[QB_MIN_S32_S32_S32_VAR] = &&label_MIN_S32_S32_S32_VAR;
		op_handlers[QB_MIN_S32_S32_S32_ELV] = &&label_MIN_S32_S32_S32_ELV;
		op_handlers[QB_MIN_S32_S32_S32_ARR] = &&label_MIN_S32_S32_S32_ARR;
		op_handlers[QB_MAX_S32_S32_S32_VAR] = &&label_MAX_S32_S32_S32_VAR;
		op_handlers[QB_MAX_S32_S32_S32_ELV] = &&label_MAX_S32_S32_S32_ELV;
		op_handlers[QB_MAX_S32_S32_S32_ARR] = &&label_MAX_S32_S32_S32_ARR;
		op_handlers[QB_RAND_S32_S32_S32_VAR] = &&label_RAND_S32_S32_S32_VAR;
		op_handlers[QB_RAND_S32_S32_S32_ELV] = &&label_RAND_S32_S32_S32_ELV;
		op_handlers[QB_RAND_S32_S32_S32_ARR] = &&label_RAND_S32_S32_S32_ARR;
		op_handlers[QB_MT_RAND_S32_S32_S32_VAR] = &&label_MT_RAND_S32_S32_S32_VAR;
		op_handlers[QB_MT_RAND_S32_S32_S32_ELV] = &&label_MT_RAND_S32_S32_S32_ELV;
		op_handlers[QB_MT_RAND_S32_S32_S32_ARR] = &&label_MT_RAND_S32_S32_S32_ARR;
		op_handlers[QB_PRN_S32_VAR] = &&label_PRN_S32_VAR;
		op_handlers[QB_PRN_S32_ELV] = &&label_PRN_S32_ELV;
		op_handlers[QB_PRN_S32_ARR] = &&label_PRN_S32_ARR;
		op_handlers[QB_PRN_DIM_S32_U32] = &&label_PRN_DIM_S32_U32;
		op_handlers[QB_CAT_S32_U08_VAR] = &&label_CAT_S32_U08_VAR;
		op_handlers[QB_CAT_S32_U08_ELV] = &&label_CAT_S32_U08_ELV;
		op_handlers[QB_CAT_S32_U08_ARR] = &&label_CAT_S32_U08_ARR;
		op_handlers[QB_CAT_DIM_S32_U32_U08] = &&label_CAT_DIM_S32_U32_U08;
		op_handlers[QB_PACK_LE_I32_U08_VAR] = &&label_PACK_LE_I32_U08_VAR;
		op_handlers[QB_PACK_LE_I32_U08_ELV] = &&label_PACK_LE_I32_U08_ELV;
		op_handlers[QB_PACK_BE_I32_U08_VAR] = &&label_PACK_BE_I32_U08_VAR;
		op_handlers[QB_PACK_BE_I32_U08_ELV] = &&label_PACK_BE_I32_U08_ELV;
		op_handlers[QB_UNPACK_LE_U08_I32_VAR] = &&label_UNPACK_LE_U08_I32_VAR;
		op_handlers[QB_UNPACK_LE_U08_I32_ELV] = &&label_UNPACK_LE_U08_I32_ELV;
		op_handlers[QB_UNPACK_BE_U08_I32_VAR] = &&label_UNPACK_BE_U08_I32_VAR;
		op_handlers[QB_UNPACK_BE_U08_I32_ELV] = &&label_UNPACK_BE_U08_I32_ELV;
		op_handlers[QB_SORT_S32] = &&label_SORT_S32;
		op_handlers[QB_RSORT_S32] = &&label_RSORT_S32;
		op_handlers[QB_AMIN_S32_S32_VAR] = &&label_AMIN_S32_S32_VAR;
		op_handlers[QB_AMAX_S32_S32_VAR] = &&label_AMAX_S32_S32_VAR;
		op_handlers[QB_APROD_S32_S32_VAR] = &&label_APROD_S32_S32_VAR;
		op_handlers[QB_ASUM_S32_S32_VAR] = &&label_ASUM_S32_S32_VAR;
		op_handlers[QB_RANGE_S32_S32_S32_S32_VAR] = &&label_RANGE_S32_S32_S32_S32_VAR;
		op_handlers[QB_AMIN_S32_S32_ELV] = &&label_AMIN_S32_S32_ELV;
		op_handlers[QB_AMAX_S32_S32_ELV] = &&label_AMAX_S32_S32_ELV;
		op_handlers[QB_APROD_S32_S32_ELV] = &&label_APROD_S32_S32_ELV;
		op_handlers[QB_ASUM_S32_S32_ELV] = &&label_ASUM_S32_S32_ELV;
		op_handlers[QB_RANGE_S32_S32_S32_S32_ELV] = &&label_RANGE_S32_S32_S32_S32_ELV;
		op_handlers[QB_AFIND_IDX_I32_I32_I32_VAR] = &&label_AFIND_IDX_I32_I32_I32_VAR;
		op_handlers[QB_AFIND_IDX_I32_I32_I32_ELV] = &&label_AFIND_IDX_I32_I32_I32_ELV;
		op_handlers[QB_AFIND_IDX_I32_I32_I32_ARR] = &&label_AFIND_IDX_I32_I32_I32_ARR;
		op_handlers[QB_AFIND_I32_I32_I32_VAR] = &&label_AFIND_I32_I32_I32_VAR;
		op_handlers[QB_AFIND_I32_I32_I32_ELV] = &&label_AFIND_I32_I32_I32_ELV;
		op_handlers[QB_AFIND_I32_I32_I32_ARR] = &&label_AFIND_I32_I32_I32_ARR;
		op_handlers[QB_APOS_I32_I32_I32_I32] = &&label_APOS_I32_I32_I32_I32;
		op_handlers[QB_ARPOS_I32_I32_I32_I32] = &&label_ARPOS_I32_I32_I32_I32;
		op_handlers[QB_AREV_I32_U32_I32] = &&label_AREV_I32_U32_I32;
		op_handlers[QB_AINS_I32_U32_I32] = &&label_AINS_I32_U32_I32;
		op_handlers[QB_AUNIQ_I32_U32_I32] = &&label_AUNIQ_I32_U32_I32;
		op_handlers[QB_IF_LT_U32_U32_VAR] = &&label_IF_LT_U32_U32_VAR;
		op_handlers[QB_IF_LT_U32_U32_ELV] = &&label_IF_LT_U32_U32_ELV;
		op_handlers[QB_IF_GT_U32_U32_VAR] = &&label_IF_GT_U32_U32_VAR;
		op_handlers[QB_IF_GT_U32_U32_ELV] = &&label_IF_GT_U32_U32_ELV;
		op_handlers[QB_IF_LE_U32_U32_VAR] = &&label_IF_LE_U32_U32_VAR;
		op_handlers[QB_IF_LE_U32_U32_ELV] = &&label_IF_LE_U32_U32_ELV;
		op_handlers[QB_IF_GE_U32_U32_VAR] = &&label_IF_GE_U32_U32_VAR;
		op_handlers[QB_IF_GE_U32_U32_ELV] = &&label_IF_GE_U32_U32_ELV;
		op_handlers[QB_MUL_U32_U32_U32_VAR] = &&label_MUL_U32_U32_U32_VAR;
		op_handlers[QB_MUL_U32_U32_U32_ELV] = &&label_MUL_U32_U32_U32_ELV;
		op_handlers[QB_MUL_U32_U32_U32_ARR] = &&label_MUL_U32_U32_U32_ARR;
		op_handlers[QB_DIV_U32_U32_U32_VAR] = &&label_DIV_U32_U32_U32_VAR;
		op_handlers[QB_DIV_U32_U32_U32_ELV] = &&label_DIV_U32_U32_U32_ELV;
		op_handlers[QB_DIV_U32_U32_U32_ARR] = &&label_DIV_U32_U32_U32_ARR;
		op_handlers[QB_MOD_U32_U32_U32_VAR] = &&label_MOD_U32_U32_U32_VAR;
		op_handlers[QB_MOD_U32_U32_U32_ELV] = &&label_MOD_U32_U32_U32_ELV;
		op_handlers[QB_MOD_U32_U32_U32_ARR] = &&label_MOD_U32_U32_U32_ARR;
		op_handlers[QB_MAC_U32_U32_U32_U32_VAR] = &&label_MAC_U32_U32_U32_U32_VAR;
		op_handlers[QB_MAC_U32_U32_U32_U32_ELV] = &&label_MAC_U32_U32_U32_U32_ELV;
		op_handlers[QB_MAC_U32_U32_U32_U32_ARR] = &&label_MAC_U32_U32_U32_U32_ARR;
		op_handlers[QB_LT_U32_U32_I32_VAR] = &&label_LT_U32_U32_I32_VAR;
		op_handlers[QB_LT_U32_U32_I32_ELV] = &&label_LT_U32_U32_I32_ELV;
		op_handlers[QB_LT_U32_U32_I32_ARR] = &&label_LT_U32_U32_I32_ARR;
		op_handlers[QB_LE_U32_U32_I32_VAR] = &&label_LE_U32_U32_I32_VAR;
		op_handlers[QB_LE_U32_U32_I32_ELV] = &&label_LE_U32_U32_I32_ELV;
		op_handlers[QB_LE_U32_U32_I32_ARR] = &&label_LE_U32_U32_I32_ARR;
		op_handlers[QB_LT_SET_U32_U32_I32] = &&label_LT_SET_U32_U32_I32;
		op_handlers[QB_LE_SET_U32_U32_I32] = &&label_LE_SET_U32_U32_I32;
		op_handlers[QB_SHL_U32_U32_U32_VAR] = &&label_SHL_U32_U32_U32_VAR;
		op_handlers[QB_SHL_U32_U32_U32_ELV] = &&label_SHL_U32_U32_U32_ELV;
		op_handlers[QB_SHL_U32_U32_U32_ARR] = &&label_SHL_U32_U32_U32_ARR;
		op_handlers[QB_SHR_U32_U32_U32_VAR] = &&label_SHR_U32_U32_U32_VAR;
		op_handlers[QB_SHR_U32_U32_U32_ELV] = &&label_SHR_U32_U32_U32_ELV;
		op_handlers[QB_SHR_U32_U32_U32_ARR] = &&label_SHR_U32_U32_U32_ARR;
		op_handlers[QB_MOV_U32_I64_VAR] = &&label_MOV_U32_I64_VAR;
		op_handlers[QB_MOV_U32_I64_ELV] = &&label_MOV_U32_I64_ELV;
		op_handlers[QB_MOV_U32_I64_ARR] = &&label_MOV_U32_I64_ARR;
		op_handlers[QB_MOV_U32_F32_VAR] = &&label_MOV_U32_F32_VAR;
		op_handlers[QB_MOV_U32_F32_ELV] = &&label_MOV_U32_F32_ELV;
		op_handlers[QB_MOV_U32_F32_ARR] = &&label_MOV_U32_F32_ARR;
		op_handlers[QB_MOV_U32_F64_VAR] = &&label_MOV_U32_F64_VAR;
		op_handlers[QB_MOV_U32_F64_ELV] = &&label_MOV_U32_F64_ELV;
		op_handlers[QB_MOV_U32_F64_ARR] = &&label_MOV_U32_F64_ARR;
		op_handlers[QB_MIN_U32_U32_U32_VAR] = &&label_MIN_U32_U32_U32_VAR;
		op_handlers[QB_MIN_U32_U32_U32_ELV] = &&label_MIN_U32_U32_U32_ELV;
		op_handlers[QB_MIN_U32_U32_U32_ARR] = &&label_MIN_U32_U32_U32_ARR;
		op_handlers[QB_MAX_U32_U32_U32_VAR] = &&label_MAX_U32_U32_U32_VAR;
		op_handlers[QB_MAX_U32_U32_U32_ELV] = &&label_MAX_U32_U32_U32_ELV;
		op_handlers[QB_MAX_U32_U32_U32_ARR] = &&label_MAX_U32_U32_U32_ARR;
		op_handlers[QB_RAND_U32_U32_U32_VAR] = &&label_RAND_U32_U32_U32_VAR;
		op_handlers[QB_RAND_U32_U32_U32_ELV] = &&label_RAND_U32_U32_U32_ELV;
		op_handlers[QB_RAND_U32_U32_U32_ARR] = &&label_RAND_U32_U32_U32_ARR;
		op_handlers[QB_MT_RAND_U32_U32_U32_VAR] = &&label_MT_RAND_U32_U32_U32_VAR;
		op_handlers[QB_MT_RAND_U32_U32_U32_ELV] = &&label_MT_RAND_U32_U32_U32_ELV;
		op_handlers[QB_MT_RAND_U32_U32_U32_ARR] = &&label_MT_RAND_U32_U32_U32_ARR;
		op_handlers[QB_UTF8_DEC_U08_U32] = &&label_UTF8_DEC_U08_U32;
		op_handlers[QB_UTF8_ENC_U32_U08] = &&label_UTF8_ENC_U32_U08;
		op_handlers[QB_PRN_U32_VAR] = &&label_PRN_U32_VAR;
		op_handlers[QB_PRN_U32_ELV] = &&label_PRN_U32_ELV;
		op_handlers[QB_PRN_U32_ARR] = &&label_PRN_U32_ARR;
		op_handlers[QB_PRN_DIM_U32_U32] = &&label_PRN_DIM_U32_U32;
		op_handlers[QB_CAT_U32_U08_VAR] = &&label_CAT_U32_U08_VAR;
		op_handlers[QB_CAT_U32_U08_ELV] = &&label_CAT_U32_U08_ELV;
		op_handlers[QB_CAT_U32_U08_ARR] = &&label_CAT_U32_U08_ARR;
		op_handlers[QB_CAT_DIM_U32_U32_U08] = &&label_CAT_DIM_U32_U32_U08;
		op_handlers[QB_SORT_U32] = &&label_SORT_U32;
		op_handlers[QB_RSORT_U32] = &&label_RSORT_U32;
		op_handlers[QB_AMIN_U32_U32_VAR] = &&label_AMIN_U32_U32_VAR;
		op_handlers[QB_AMAX_U32_U32_VAR] = &&label_AMAX_U32_U32_VAR;
		op_handlers[QB_APROD_U32_U32_VAR] = &&label_APROD_U32_U32_VAR;
		op_handlers[QB_ASUM_U32_U32_VAR] = &&label_ASUM_U32_U32_VAR;
		op_handlers[QB_RANGE_U32_U32_S32_U32_VAR] = &&label_RANGE_U32_U32_S32_U32_VAR;
		op_handlers[QB_AMIN_U32_U32_ELV] = &&label_AMIN_U32_U32_ELV;
		op_handlers[QB_AMAX_U32_U32_ELV] = &&label_AMAX_U32_U32_ELV;
		op_handlers[QB_APROD_U32_U32_ELV] = &&label_APROD_U32_U32_ELV;
		op_handlers[QB_ASUM_U32_U32_ELV] = &&label_ASUM_U32_U32_ELV;
		op_handlers[QB_RANGE_U32_U32_S32_U32_ELV] = &&label_RANGE_U32_U32_S32_U32_ELV;
		op_handlers[QB_IF_EQ_I08_I08_VAR] = &&label_IF_EQ_I08_I08_VAR;
		op_handlers[QB_IF_EQ_I08_I08_ELV] = &&label_IF_EQ_I08_I08_ELV;
		op_handlers[QB_IF_NE_I08_I08_VAR] = &&label_IF_NE_I08_I08_VAR;
		op_handlers[QB_IF_NE_I08_I08_ELV] = &&label_IF_NE_I08_I08_ELV;
		op_handlers[QB_IF_LT_S08_S08_VAR] = &&label_IF_LT_S08_S08_VAR;
		op_handlers[QB_IF_LT_S08_S08_ELV] = &&label_IF_LT_S08_S08_ELV;
		op_handlers[QB_IF_GT_S08_S08_VAR] = &&label_IF_GT_S08_S08_VAR;
		op_handlers[QB_IF_GT_S08_S08_ELV] = &&label_IF_GT_S08_S08_ELV;
		op_handlers[QB_IF_LE_S08_S08_VAR] = &&label_IF_LE_S08_S08_VAR;
		op_handlers[QB_IF_LE_S08_S08_ELV] = &&label_IF_LE_S08_S08_ELV;
		op_handlers[QB_IF_GE_S08_S08_VAR] = &&label_IF_GE_S08_S08_VAR;
		op_handlers[QB_IF_GE_S08_S08_ELV] = &&label_IF_GE_S08_S08_ELV;
		op_handlers[QB_ADD_I08_I08_I08_VAR] = &&label_ADD_I08_I08_I08_VAR;
		op_handlers[QB_ADD_I08_I08_I08_ELV] = &&label_ADD_I08_I08_I08_ELV;
		op_handlers[QB_ADD_I08_I08_I08_ARR] = &&label_ADD_I08_I08_I08_ARR;
		op_handlers[QB_SUB_I08_I08_I08_VAR] = &&label_SUB_I08_I08_I08_VAR;
		op_handlers[QB_SUB_I08_I08_I08_ELV] = &&label_SUB_I08_I08_I08_ELV;
		op_handlers[QB_SUB_I08_I08_I08_ARR] = &&label_SUB_I08_I08_I08_ARR;
		op_handlers[QB_MUL_S08_S08_S08_VAR] = &&label_MUL_S08_S08_S08_VAR;
		op_handlers[QB_MUL_S08_S08_S08_ELV] = &&label_MUL_S08_S08_S08_ELV;
		op_handlers[QB_MUL_S08_S08_S08_ARR] = &&label_MUL_S08_S08_S08_ARR;
		op_handlers[QB_DIV_S08_S08_S08_VAR] = &&label_DIV_S08_S08_S08_VAR;
		op_handlers[QB_DIV_S08_S08_S08_ELV] = &&label_DIV_S08_S08_S08_ELV;
		op_handlers[QB_DIV_S08_S08_S08_ARR] = &&label_DIV_S08_S08_S08_ARR;
		op_handlers[QB_MOD_S08_S08_S08_VAR] = &&label_MOD_S08_S08_S08_VAR;
		op_handlers[QB_MOD_S08_S08_S08_ELV] = &&label_MOD_S08_S08_S08_ELV;
		op_handlers[QB_MOD_S08_S08_S08_ARR] = &&label_MOD_S08_S08_S08_ARR;
		op_handlers[QB_NEG_I08_I08_VAR] = &&label_NEG_I08_I08_VAR;
		op_handlers[QB_NEG_I08_I08_ELV] = &&label_NEG_I08_I08_ELV;
		op_handlers[QB_NEG_I08_I08_ARR] = &&label_NEG_I08_I08_ARR;
		op_handlers[QB_MOV_I08_I08_VAR] = &&label_MOV_I08_I08_VAR;
		op_handlers[QB_MOV_I08_I08_ELV] = &&label_MOV_I08_I08_ELV;
		op_handlers[QB_MOV_I08_I08_ARR] = &&label_MOV_I08_I08_ARR;
		op_handlers[QB_INC_I08_VAR] = &&label_INC_I08_VAR;
		op_handlers[QB_INC_I08_ELV] = &&label_INC_I08_ELV;
		op_handlers[QB_INC_I08_ARR] = &&label_INC_I08_ARR;
		op_handlers[QB_DEC_I08_VAR] = &&label_DEC_I08_VAR;
		op_handlers[QB_DEC_I08_ELV] = &&label_DEC_I08_ELV;
		op_handlers[QB_DEC_I08_ARR] = &&label_DEC_I08_ARR;
		op_handlers[QB_EQ_I08_I08_I32_VAR] = &&label_EQ_I08_I08_I32_VAR;
		op_handlers[QB_EQ_I08_I08_I32_ELV] = &&label_EQ_I08_I08_I32_ELV;
		op_handlers[QB_EQ_I08_I08_I32_ARR] = &&label_EQ_I08_I08_I32_ARR;
		op_handlers[QB_NE_I08_I08_I32_VAR] = &&label_NE_I08_I08_I32_VAR;
		op_handlers[QB_NE_I08_I08_I32_ELV] = &&label_NE_I08_I08_I32_ELV;
		op_handlers[QB_NE_I08_I08_I32_ARR] = &&label_NE_I08_I08_I32_ARR;
		op_handlers[QB_LT_S08_S08_I32_VAR] = &&label_LT_S08_S08_I32_VAR;
		op_handlers[QB_LT_S08_S08_I32_ELV] = &&label_LT_S08_S08_I32_ELV;
		op_handlers[QB_LT_S08_S08_I32_ARR] = &&label_LT_S08_S08_I32_ARR;
		op_handlers[QB_LE_S08_S08_I32_VAR] = &&label_LE_S08_S08_I32_VAR;
		op_handlers[QB_LE_S08_S08_I32_ELV] = &&label_LE_S08_S08_I32_ELV;
		op_handlers[QB_LE_S08_S08_I32_ARR] = &&label_LE_S08_S08_I32_ARR;
		op_handlers[QB_EQ_SET_I08_I08_I32] = &&label_EQ_SET_I08_I08_I32;
		op_handlers[QB_NE_SET_I08_I08_I32] = &&label_NE_SET_I08_I08_I32;
		op_handlers[QB_LT_SET_S08_S08_I32] = &&label_LT_SET_S08_S08_I32;
		op_handlers[QB_LE_SET_S08_S08_I32] = &&label_LE_SET_S08_S08_I32;
		op_handlers[QB_BW_AND_I08_I08_I08_VAR] = &&label_BW_AND_I08_I08_I08_VAR;
		op_handlers[QB_BW_AND_I08_I08_I08_ELV] = &&label_BW_AND_I08_I08_I08_ELV;
		op_handlers[QB_BW_AND_I08_I08_I08_ARR] = &&label_BW_AND_I08_I08_I08_ARR;
		op_handlers[QB_BW_OR_I08_I08_I08_VAR] = &&label_BW_OR_I08_I08_I08_VAR;
		op_handlers[QB_BW_OR_I08_I08_I08_ELV] = &&label_BW_OR_I08_I08_I08_ELV;
		op_handlers[QB_BW_OR_I08_I08_I08_ARR] = &&label_BW_OR_I08_I08_I08_ARR;
		op_handlers[QB_BW_XOR_I08_I08_I08_VAR] = &&label_BW_XOR_I08_I08_I08_VAR;
		op_handlers[QB_BW_XOR_I08_I08_I08_ELV] = &&label_BW_XOR_I08_I08_I08_ELV;
		op_handlers[QB_BW_XOR_I08_I08_I08_ARR] = &&label_BW_XOR_I08_I08_I08_ARR;
		op_handlers[QB_BW_NOT_I08_I08_VAR] = &&label_BW_NOT_I08_I08_VAR;
		op_handlers[QB_BW_NOT_I08_I08_ELV] = &&label_BW_NOT_I08_I08_ELV;
		op_handlers[QB_BW_NOT_I08_I08_ARR] = &&label_BW_NOT_I08_I08_ARR;
		op_handlers[QB_SHL_S08_S08_S08_VAR] = &&label_SHL_S08_S08_S08_VAR;
		op_handlers[QB_SHL_S08_S08_S08_ELV] = &&label_SHL_S08_S08_S08_ELV;
		op_handlers[QB_SHL_S08_S08_S08_ARR] = &&label_SHL_S08_S08_S08_ARR;
		op_handlers[QB_SHR_S08_S08_S08_VAR] = &&label_SHR_S08_S08_S08_VAR;
		op_handlers[QB_SHR_S08_S08_S08_ELV] = &&label_SHR_S08_S08_S08_ELV;
		op_handlers[QB_SHR_S08_S08_S08_ARR] = &&label_SHR_S08_S08_S08_ARR;
		op_handlers[QB_ISSET_I08_I32_ELV] = &&label_ISSET_I08_I32_ELV;
		op_handlers[QB_UNSET_I08_VAR] = &&label_UNSET_I08_VAR;
		op_handlers[QB_UNSET_I08_ELV] = &&label_UNSET_I08_ELV;
		op_handlers[QB_UNSET_I08_ARR] = &&label_UNSET_I08_ARR;
		op_handlers[QB_MOV_S08_I32_VAR] = &&label_MOV_S08_I32_VAR;
		op_handlers[QB_MOV_S08_I32_ELV] = &&label_MOV_S08_I32_ELV;
		op_handlers[QB_MOV_S08_I32_ARR] = &&label_MOV_S08_I32_ARR;
		op_handlers[QB_MOV_S08_I16_VAR] = &&label_MOV_S08_I16_VAR;
		op_handlers[QB_MOV_S08_I16_ELV] = &&label_MOV_S08_I16_ELV;
		op_handlers[QB_MOV_S08_I16_ARR] = &&label_MOV_S08_I16_ARR;
		op_handlers[QB_MOV_S08_I64_VAR] = &&label_MOV_S08_I64_VAR;
		op_handlers[QB_MOV_S08_I64_ELV] = &&label_MOV_S08_I64_ELV;
		op_handlers[QB_MOV_S08_I64_ARR] = &&label_MOV_S08_I64_ARR;
		op_handlers[QB_MOV_S08_F32_VAR] = &&label_MOV_S08_F32_VAR;
		op_handlers[QB_MOV_S08_F32_ELV] = &&label_MOV_S08_F32_ELV;
		op_handlers[QB_MOV_S08_F32_ARR] = &&label_MOV_S08_F32_ARR;
		op_handlers[QB_MOV_S08_F64_VAR] = &&label_MOV_S08_F64_VAR;
		op_handlers[QB_MOV_S08_F64_ELV] = &&label_MOV_S08_F64_ELV;
		op_handlers[QB_MOV_S08_F64_ARR] = &&label_MOV_S08_F64_ARR;
		op_handlers[QB_BOOL_I08_I32_VAR] = &&label_BOOL_I08_I32_VAR;
		op_handlers[QB_BOOL_I08_I32_ELV] = &&label_BOOL_I08_I32_ELV;
		op_handlers[QB_BOOL_I08_I32_ARR] = &&label_BOOL_I08_I32_ARR;
		op_handlers[QB_ABS_S08_S08_VAR] = &&label_ABS_S08_S08_VAR;
		op_handlers[QB_ABS_S08_S08_ELV] = &&label_ABS_S08_S08_ELV;
		op_handlers[QB_ABS_S08_S08_ARR] = &&label_ABS_S08_S08_ARR;
		op_handlers[QB_MIN_S08_S08_S08_VAR] = &&label_MIN_S08_S08_S08_VAR;
		op_handlers[QB_MIN_S08_S08_S08_ELV] = &&label_MIN_S08_S08_S08_ELV;
		op_handlers[QB_MIN_S08_S08_S08_ARR] = &&label_MIN_S08_S08_S08_ARR;
		op_handlers[QB_MAX_S08_S08_S08_VAR] = &&label_MAX_S08_S08_S08_VAR;
		op_handlers[QB_MAX_S08_S08_S08_ELV] = &&label_MAX_S08_S08_S08_ELV;
		op_handlers[QB_MAX_S08_S08_S08_ARR] = &&label_MAX_S08_S08_S08_ARR;
		op_handlers[QB_RAND_S08_S08_S08_VAR] = &&label_RAND_S08_S08_S08_VAR;
		op_handlers[QB_RAND_S08_S08_S08_ELV] = &&label_RAND_S08_S08_S08_ELV;
		op_handlers[QB_RAND_S08_S08_S08_ARR] = &&label_RAND_S08_S08_S08_ARR;
		op_handlers[QB_MT_RAND_S08_S08_S08_VAR] = &&label_MT_RAND_S08_S08_S08_VAR;
		op_handlers[QB_MT_RAND_S08_S08_S08_ELV] = &&label_MT_RAND_S08_S08_S08_ELV;
		op_handlers[QB_MT_RAND_S08_S08_S08_ARR] = &&label_MT_RAND_S08_S08_S08_ARR;
		op_handlers[QB_PRN_S08_VAR] = &&label_PRN_S08_VAR;
		op_handlers[QB_PRN_S08_ELV] = &&label_PRN_S08_ELV;
		op_handlers[QB_PRN_S08_ARR] = &&label_PRN_S08_ARR;
		op_handlers[QB_PRN_DIM_S08_U32] = &&label_PRN_DIM_S08_U32;
		op_handlers[QB_CAT_S08_U08_VAR] = &&label_CAT_S08_U08_VAR;
		op_handlers[QB_CAT_S08_U08_ELV] = &&label_CAT_S08_U08_ELV;
		op_handlers[QB_CAT_S08_U08_ARR] = &&label_CAT_S08_U08_ARR;
		op_handlers[QB_CAT_DIM_S08_U32_U08] = &&label_CAT_DIM_S08_U32_U08;
		op_handlers[QB_SORT_S08] = &&label_SORT_S08;
		op_handlers[QB_RSORT_S08] = &&label_RSORT_S08;
		op_handlers[QB_AMIN_S08_S08_VAR] = &&label_AMIN_S08_S08_VAR;
		op_handlers[QB_AMAX_S08_S08_VAR] = &&label_AMAX_S08_S08_VAR;
		op_handlers[QB_APROD_S08_S08_VAR] = &&label_APROD_S08_S08_VAR;
		op_handlers[QB_ASUM_S08_S08_VAR] = &&label_ASUM_S08_S08_VAR;
		op_handlers[QB_RANGE_S08_S08_S08_S08_VAR] = &&label_RANGE_S08_S08_S08_S08_VAR;
		op_handlers[QB_AMIN_S08_S08_ELV] = &&label_AMIN_S08_S08_ELV;
		op_handlers[QB_AMAX_S08_S08_ELV] = &&label_AMAX_S08_S08_ELV;
		op_handlers[QB_APROD_S08_S08_ELV] = &&label_APROD_S08_S08_ELV;
		op_handlers[QB_ASUM_S08_S08_ELV] = &&label_ASUM_S08_S08_ELV;
		op_handlers[QB_RANGE_S08_S08_S08_S08_ELV] = &&label_RANGE_S08_S08_S08_S08_ELV;
		op_handlers[QB_AFIND_IDX_I08_I08_I32_VAR] = &&label_AFIND_IDX_I08_I08_I32_VAR;
		op_handlers[QB_AFIND_IDX_I08_I08_I32_ELV] = &&label_AFIND_IDX_I08_I08_I32_ELV;
		op_handlers[QB_AFIND_IDX_I08_I08_I32_ARR] = &&label_AFIND_IDX_I08_I08_I32_ARR;
		op_handlers[QB_AFIND_I08_I08_I32_VAR] = &&label_AFIND_I08_I08_I32_VAR;
		op_handlers[QB_AFIND_I08_I08_I32_ELV] = &&label_AFIND_I08_I08_I32_ELV;
		op_handlers[QB_AFIND_I08_I08_I32_ARR] = &&label_AFIND_I08_I08_I32_ARR;
		op_handlers[QB_APOS_I08_I08_I32_I32] = &&label_APOS_I08_I08_I32_I32;
		op_handlers[QB_ARPOS_I08_I08_I32_I32] = &&label_ARPOS_I08_I08_I32_I32;
		op_handlers[QB_AREV_I08_U32_I08] = &&label_AREV_I08_U32_I08;
		op_handlers[QB_AINS_I08_U32_I08] = &&label_AINS_I08_U32_I08;
		op_handlers[QB_AUNIQ_I08_U32_I08] = &&label_AUNIQ_I08_U32_I08;
		op_handlers[QB_IF_LT_U08_U08_VAR] = &&label_IF_LT_U08_U08_VAR;
		op_handlers[QB_IF_LT_U08_U08_ELV] = &&label_IF_LT_U08_U08_ELV;
		op_handlers[QB_IF_GT_U08_U08_VAR] = &&label_IF_GT_U08_U08_VAR;
		op_handlers[QB_IF_GT_U08_U08_ELV] = &&label_IF_GT_U08_U08_ELV;
		op_handlers[QB_IF_LE_U08_U08_VAR] = &&label_IF_LE_U08_U08_VAR;
		op_handlers[QB_IF_LE_U08_U08_ELV] = &&label_IF_LE_U08_U08_ELV;
		op_handlers[QB_IF_GE_U08_U08_VAR] = &&label_IF_GE_U08_U08_VAR;
		op_handlers[QB_IF_GE_U08_U08_ELV] = &&label_IF_GE_U08_U08_ELV;
		op_handlers[QB_MUL_U08_U08_U08_VAR] = &&label_MUL_U08_U08_U08_VAR;
		op_handlers[QB_MUL_U08_U08_U08_ELV] = &&label_MUL_U08_U08_U08_ELV;
		op_handlers[QB_MUL_U08_U08_U08_ARR] = &&label_MUL_U08_U08_U08_ARR;
		op_handlers[QB_DIV_U08_U08_U08_VAR] = &&label_DIV_U08_U08_U08_VAR;
		op_handlers[QB_DIV_U08_U08_U08_ELV] = &&label_DIV_U08_U08_U08_ELV;
		op_handlers[QB_DIV_U08_U08_U08_ARR] = &&label_DIV_U08_U08_U08_ARR;
		op_handlers[QB_MOD_U08_U08_U08_VAR] = &&label_MOD_U08_U08_U08_VAR;
		op_handlers[QB_MOD_U08_U08_U08_ELV] = &&label_MOD_U08_U08_U08_ELV;
		op_handlers[QB_MOD_U08_U08_U08_ARR] = &&label_MOD_U08_U08_U08_ARR;
		op_handlers[QB_LT_U08_U08_I32_VAR] = &&label_LT_U08_U08_I32_VAR;
		op_handlers[QB_LT_U08_U08_I32_ELV] = &&label_LT_U08_U08_I32_ELV;
		op_handlers[QB_LT_U08_U08_I32_ARR] = &&label_LT_U08_U08_I32_ARR;
		op_handlers[QB_LE_U08_U08_I32_VAR] = &&label_LE_U08_U08_I32_VAR;
		op_handlers[QB_LE_U08_U08_I32_ELV] = &&label_LE_U08_U08_I32_ELV;
		op_handlers[QB_LE_U08_U08_I32_ARR] = &&label_LE_U08_U08_I32_ARR;
		op_handlers[QB_LT_SET_U08_U08_I32] = &&label_LT_SET_U08_U08_I32;
		op_handlers[QB_LE_SET_U08_U08_I32] = &&label_LE_SET_U08_U08_I32;
		op_handlers[QB_SHL_U08_U08_U08_VAR] = &&label_SHL_U08_U08_U08_VAR;
		op_handlers[QB_SHL_U08_U08_U08_ELV] = &&label_SHL_U08_U08_U08_ELV;
		op_handlers[QB_SHL_U08_U08_U08_ARR] = &&label_SHL_U08_U08_U08_ARR;
		op_handlers[QB_SHR_U08_U08_U08_VAR] = &&label_SHR_U08_U08_U08_VAR;
		op_handlers[QB_SHR_U08_U08_U08_ELV] = &&label_SHR_U08_U08_U08_ELV;
		op_handlers[QB_SHR_U08_U08_U08_ARR] = &&label_SHR_U08_U08_U08_ARR;
		op_handlers[QB_MOV_U08_I32_VAR] = &&label_MOV_U08_I32_VAR;
		op_handlers[QB_MOV_U08_I32_ELV] = &&label_MOV_U08_I32_ELV;
		op_handlers[QB_MOV_U08_I32_ARR] = &&label_MOV_U08_I32_ARR;
		op_handlers[QB_MOV_U08_I16_VAR] = &&label_MOV_U08_I16_VAR;
		op_handlers[QB_MOV_U08_I16_ELV] = &&label_MOV_U08_I16_ELV;
		op_handlers[QB_MOV_U08_I16_ARR] = &&label_MOV_U08_I16_ARR;
		op_handlers[QB_MOV_U08_I64_VAR] = &&label_MOV_U08_I64_VAR;
		op_handlers[QB_MOV_U08_I64_ELV] = &&label_MOV_U08_I64_ELV;
		op_handlers[QB_MOV_U08_I64_ARR] = &&label_MOV_U08_I64_ARR;
		op_handlers[QB_MOV_U08_F32_VAR] = &&label_MOV_U08_F32_VAR;
		op_handlers[QB_MOV_U08_F32_ELV] = &&label_MOV_U08_F32_ELV;
		op_handlers[QB_MOV_U08_F32_ARR] = &&label_MOV_U08_F32_ARR;
		op_handlers[QB_MOV_U08_F64_VAR] = &&label_MOV_U08_F64_VAR;
		op_handlers[QB_MOV_U08_F64_ELV] = &&label_MOV_U08_F64_ELV;
		op_handlers[QB_MOV_U08_F64_ARR] = &&label_MOV_U08_F64_ARR;
		op_handlers[QB_MIN_U08_U08_U08_VAR] = &&label_MIN_U08_U08_U08_VAR;
		op_handlers[QB_MIN_U08_U08_U08_ELV] = &&label_MIN_U08_U08_U08_ELV;
		op_handlers[QB_MIN_U08_U08_U08_ARR] = &&label_MIN_U08_U08_U08_ARR;
		op_handlers[QB_MAX_U08_U08_U08_VAR] = &&label_MAX_U08_U08_U08_VAR;
		op_handlers[QB_MAX_U08_U08_U08_ELV] = &&label_MAX_U08_U08_U08_ELV;
		op_handlers[QB_MAX_U08_U08_U08_ARR] = &&label_MAX_U08_U08_U08_ARR;
		op_handlers[QB_RAND_U08_U08_U08_VAR] = &&label_RAND_U08_U08_U08_VAR;
		op_handlers[QB_RAND_U08_U08_U08_ELV] = &&label_RAND_U08_U08_U08_ELV;
		op_handlers[QB_RAND_U08_U08_U08_ARR] = &&label_RAND_U08_U08_U08_ARR;
		op_handlers[QB_MT_RAND_U08_U08_U08_VAR] = &&label_MT_RAND_U08_U08_U08_VAR;
		op_handlers[QB_MT_RAND_U08_U08_U08_ELV] = &&label_MT_RAND_U08_U08_U08_ELV;
		op_handlers[QB_MT_RAND_U08_U08_U08_ARR] = &&label_MT_RAND_U08_U08_U08_ARR;
		op_handlers[QB_PRN_STR_U08] = &&label_PRN_STR_U08;
		op_handlers[QB_CAT_STR_U08_U08] = &&label_CAT_STR_U08_U08;
		op_handlers[QB_PRN_U08_VAR] = &&label_PRN_U08_VAR;
		op_handlers[QB_PRN_U08_ELV] = &&label_PRN_U08_ELV;
		op_handlers[QB_PRN_U08_ARR] = &&label_PRN_U08_ARR;
		op_handlers[QB_PRN_DIM_U08_U32] = &&label_PRN_DIM_U08_U32;
		op_handlers[QB_CAT_U08_U08_VAR] = &&label_CAT_U08_U08_VAR;
		op_handlers[QB_CAT_U08_U08_ELV] = &&label_CAT_U08_U08_ELV;
		op_handlers[QB_CAT_U08_U08_ARR] = &&label_CAT_U08_U08_ARR;
		op_handlers[QB_CAT_DIM_U08_U32_U08] = &&label_CAT_DIM_U08_U32_U08;
		op_handlers[QB_SORT_U08] = &&label_SORT_U08;
		op_handlers[QB_RSORT_U08] = &&label_RSORT_U08;
		op_handlers[QB_AMIN_U08_U08_VAR] = &&label_AMIN_U08_U08_VAR;
		op_handlers[QB_AMAX_U08_U08_VAR] = &&label_AMAX_U08_U08_VAR;
		op_handlers[QB_APROD_U08_U08_VAR] = &&label_APROD_U08_U08_VAR;
		op_handlers[QB_ASUM_U08_U08_VAR] = &&label_ASUM_U08_U08_VAR;
		op_handlers[QB_RANGE_U08_U08_S08_U08_VAR] = &&label_RANGE_U08_U08_S08_U08_VAR;
		op_handlers[QB_AMIN_U08_U08_ELV] = &&label_AMIN_U08_U08_ELV;
		op_handlers[QB_AMAX_U08_U08_ELV] = &&label_AMAX_U08_U08_ELV;
		op_handlers[QB_APROD_U08_U08_ELV] = &&label_APROD_U08_U08_ELV;
		op_handlers[QB_ASUM_U08_U08_ELV] = &&label_ASUM_U08_U08_ELV;
		op_handlers[QB_RANGE_U08_U08_S08_U08_ELV] = &&label_RANGE_U08_U08_S08_U08_ELV;
		op_handlers[QB_IF_EQ_I16_I16_VAR] = &&label_IF_EQ_I16_I16_VAR;
		op_handlers[QB_IF_EQ_I16_I16_ELV] = &&label_IF_EQ_I16_I16_ELV;
		op_handlers[QB_IF_NE_I16_I16_VAR] = &&label_IF_NE_I16_I16_VAR;
		op_handlers[QB_IF_NE_I16_I16_ELV] = &&label_IF_NE_I16_I16_ELV;
		op_handlers[QB_IF_LT_S16_S16_VAR] = &&label_IF_LT_S16_S16_VAR;
		op_handlers[QB_IF_LT_S16_S16_ELV] = &&label_IF_LT_S16_S16_ELV;
		op_handlers[QB_IF_GT_S16_S16_VAR] = &&label_IF_GT_S16_S16_VAR;
		op_handlers[QB_IF_GT_S16_S16_ELV] = &&label_IF_GT_S16_S16_ELV;
		op_handlers[QB_IF_LE_S16_S16_VAR] = &&label_IF_LE_S16_S16_VAR;
		op_handlers[QB_IF_LE_S16_S16_ELV] = &&label_IF_LE_S16_S16_ELV;
		op_handlers[QB_IF_GE_S16_S16_VAR] = &&label_IF_GE_S16_S16_VAR;
		op_handlers[QB_IF_GE_S16_S16_ELV] = &&label_IF_GE_S16_S16_ELV;
		op_handlers[QB_ADD_I16_I16_I16_VAR] = &&label_ADD_I16_I16_I16_VAR;
		op_handlers[QB_ADD_I16_I16_I16_ELV] = &&label_ADD_I16_I16_I16_ELV;
		op_handlers[QB_ADD_I16_I16_I16_ARR] = &&label_ADD_I16_I16_I16_ARR;
		op_handlers[QB_SUB_I16_I16_I16_VAR] = &&label_SUB_I16_I16_I16_VAR;
		op_handlers[QB_SUB_I16_I16_I16_ELV] = &&label_SUB_I16_I16_I16_ELV;
		op_handlers[QB_SUB_I16_I16_I16_ARR] = &&label_SUB_I16_I16_I16_ARR;
		op_handlers[QB_MUL_S16_S16_S16_VAR] = &&label_MUL_S16_S16_S16_VAR;
		op_handlers[QB_MUL_S16_S16_S16_ELV] = &&label_MUL_S16_S16_S16_ELV;
		op_handlers[QB_MUL_S16_S16_S16_ARR] = &&label_MUL_S16_S16_S16_ARR;
		op_handlers[QB_DIV_S16_S16_S16_VAR] = &&label_DIV_S16_S16_S16_VAR;
		op_handlers[QB_DIV_S16_S16_S16_ELV] = &&label_DIV_S16_S16_S16_ELV;
		op_handlers[QB_DIV_S16_S16_S16_ARR] = &&label_DIV_S16_S16_S16_ARR;
		op_handlers[QB_MOD_S16_S16_S16_VAR] = &&label_MOD_S16_S16_S16_VAR;
		op_handlers[QB_MOD_S16_S16_S16_ELV] = &&label_MOD_S16_S16_S16_ELV;
		op_handlers[QB_MOD_S16_S16_S16_ARR] = &&label_MOD_S16_S16_S16_ARR;
		op_handlers[QB_NEG_I16_I16_VAR] = &&label_NEG_I16_I16_VAR;
		op_handlers[QB_NEG_I16_I16_ELV] = &&label_NEG_I16_I16_ELV;
		op_handlers[QB_NEG_I16_I16_ARR] = &&label_NEG_I16_I16_ARR;
		op_handlers[QB_MOV_I16_I16_VAR] = &&label_MOV_I16_I16_VAR;
		op_handlers[QB_MOV_I16_I16_ELV] = &&label_MOV_I16_I16_ELV;
		op_handlers[QB_MOV_I16_I16_ARR] = &&label_MOV_I16_I16_ARR;
		op_handlers[QB_INC_I16_VAR] = &&label_INC_I16_VAR;
		op_handlers[QB_INC_I16_ELV] = &&label_INC_I16_ELV;
		op_handlers[QB_INC_I16_ARR] = &&label_INC_I16_ARR;
		op_handlers[QB_DEC_I16_VAR] = &&label_DEC_I16_VAR;
		op_handlers[QB_DEC_I16_ELV] = &&label_DEC_I16_ELV;
		op_handlers[QB_DEC_I16_ARR] = &&label_DEC_I16_ARR;
		op_handlers[QB_EQ_I16_I16_I32_VAR] = &&label_EQ_I16_I16_I32_VAR;
		op_handlers[QB_EQ_I16_I16_I32_ELV] = &&label_EQ_I16_I16_I32_ELV;
		op_handlers[QB_EQ_I16_I16_I32_ARR] = &&label_EQ_I16_I16_I32_ARR;
		op_handlers[QB_NE_I16_I16_I32_VAR] = &&label_NE_I16_I16_I32_VAR;
		op_handlers[QB_NE_I16_I16_I32_ELV] = &&label_NE_I16_I16_I32_ELV;
		op_handlers[QB_NE_I16_I16_I32_ARR] = &&label_NE_I16_I16_I32_ARR;
		op_handlers[QB_LT_S16_S16_I32_VAR] = &&label_LT_S16_S16_I32_VAR;
		op_handlers[QB_LT_S16_S16_I32_ELV] = &&label_LT_S16_S16_I32_ELV;
		op_handlers[QB_LT_S16_S16_I32_ARR] = &&label_LT_S16_S16_I32_ARR;
		op_handlers[QB_LE_S16_S16_I32_VAR] = &&label_LE_S16_S16_I32_VAR;
		op_handlers[QB_LE_S16_S16_I32_ELV] = &&label_LE_S16_S16_I32_ELV;
		op_handlers[QB_LE_S16_S16_I32_ARR] = &&label_LE_S16_S16_I32_ARR;
		op_handlers[QB_EQ_SET_I16_I16_I32] = &&label_EQ_SET_I16_I16_I32;
		op_handlers[QB_NE_SET_I16_I16_I32] = &&label_NE_SET_I16_I16_I32;
		op_handlers[QB_LT_SET_S16_S16_I32] = &&label_LT_SET_S16_S16_I32;
		op_handlers[QB_LE_SET_S16_S16_I32] = &&label_LE_SET_S16_S16_I32;
		op_handlers[QB_BW_AND_I16_I16_I16_VAR] = &&label_BW_AND_I16_I16_I16_VAR;
		op_handlers[QB_BW_AND_I16_I16_I16_ELV] = &&label_BW_AND_I16_I16_I16_ELV;
		op_handlers[QB_BW_AND_I16_I16_I16_ARR] = &&label_BW_AND_I16_I16_I16_ARR;
		op_handlers[QB_BW_OR_I16_I16_I16_VAR] = &&label_BW_OR_I16_I16_I16_VAR;
		op_handlers[QB_BW_OR_I16_I16_I16_ELV] = &&label_BW_OR_I16_I16_I16_ELV;
		op_handlers[QB_BW_OR_I16_I16_I16_ARR] = &&label_BW_OR_I16_I16_I16_ARR;
		op_handlers[QB_BW_XOR_I16_I16_I16_VAR] = &&label_BW_XOR_I16_I16_I16_VAR;
		op_handlers[QB_BW_XOR_I16_I16_I16_ELV] = &&label_BW_XOR_I16_I16_I16_ELV;
		op_handlers[QB_BW_XOR_I16_I16_I16_ARR] = &&label_BW_XOR_I16_I16_I16_ARR;
		op_handlers[QB_BW_NOT_I16_I16_VAR] = &&label_BW_NOT_I16_I16_VAR;
		op_handlers[QB_BW_NOT_I16_I16_ELV] = &&label_BW_NOT_I16_I16_ELV;
		op_handlers[QB_BW_NOT_I16_I16_ARR] = &&label_BW_NOT_I16_I16_ARR;
		op_handlers[QB_SHL_S16_S16_S16_VAR] = &&label_SHL_S16_S16_S16_VAR;
		op_handlers[QB_SHL_S16_S16_S16_ELV] = &&label_SHL_S16_S16_S16_ELV;
		op_handlers[QB_SHL_S16_S16_S16_ARR] = &&label_SHL_S16_S16_S16_ARR;
		op_handlers[QB_SHR_S16_S16_S16_VAR] = &&label_SHR_S16_S16_S16_VAR;
		op_handlers[QB_SHR_S16_S16_S16_ELV] = &&label_SHR_S16_S16_S16_ELV;
		op_handlers[QB_SHR_S16_S16_S16_ARR] = &&label_SHR_S16_S16_S16_ARR;
		op_handlers[QB_ISSET_I16_I32_ELV] = &&label_ISSET_I16_I32_ELV;
		op_handlers[QB_UNSET_I16_VAR] = &&label_UNSET_I16_VAR;
		op_handlers[QB_UNSET_I16_ELV] = &&label_UNSET_I16_ELV;
		op_handlers[QB_UNSET_I16_ARR] = &&label_UNSET_I16_ARR;
		op_handlers[QB_MOV_S16_I32_VAR] = &&label_MOV_S16_I32_VAR;
		op_handlers[QB_MOV_S16_I32_ELV] = &&label_MOV_S16_I32_ELV;
		op_handlers[QB_MOV_S16_I32_ARR] = &&label_MOV_S16_I32_ARR;
		op_handlers[QB_MOV_I16_I08_VAR] = &&label_MOV_I16_I08_VAR;
		op_handlers[QB_MOV_I16_I08_ELV] = &&label_MOV_I16_I08_ELV;
		op_handlers[QB_MOV_I16_I08_ARR] = &&label_MOV_I16_I08_ARR;
		op_handlers[QB_MOV_S16_I64_VAR] = &&label_MOV_S16_I64_VAR;
		op_handlers[QB_MOV_S16_I64_ELV] = &&label_MOV_S16_I64_ELV;
		op_handlers[QB_MOV_S16_I64_ARR] = &&label_MOV_S16_I64_ARR;
		op_handlers[QB_MOV_S16_F32_VAR] = &&label_MOV_S16_F32_VAR;
		op_handlers[QB_MOV_S16_F32_ELV] = &&label_MOV_S16_F32_ELV;
		op_handlers[QB_MOV_S16_F32_ARR] = &&label_MOV_S16_F32_ARR;
		op_handlers[QB_MOV_S16_F64_VAR] = &&label_MOV_S16_F64_VAR;
		op_handlers[QB_MOV_S16_F64_ELV] = &&label_MOV_S16_F64_ELV;
		op_handlers[QB_MOV_S16_F64_ARR] = &&label_MOV_S16_F64_ARR;
		op_handlers[QB_BOOL_I16_I32_VAR] = &&label_BOOL_I16_I32_VAR;
		op_handlers[QB_BOOL_I16_I32_ELV] = &&label_BOOL_I16_I32_ELV;
		op_handlers[QB_BOOL_I16_I32_ARR] = &&label_BOOL_I16_I32_ARR;
		op_handlers[QB_ABS_S16_S16_VAR] = &&label_ABS_S16_S16_VAR;
		op_handlers[QB_ABS_S16_S16_ELV] = &&label_ABS_S16_S16_ELV;
		op_handlers[QB_ABS_S16_S16_ARR] = &&label_ABS_S16_S16_ARR;
		op_handlers[QB_MIN_S16_S16_S16_VAR] = &&label_MIN_S16_S16_S16_VAR;
		op_handlers[QB_MIN_S16_S16_S16_ELV] = &&label_MIN_S16_S16_S16_ELV;
		op_handlers[QB_MIN_S16_S16_S16_ARR] = &&label_MIN_S16_S16_S16_ARR;
		op_handlers[QB_MAX_S16_S16_S16_VAR] = &&label_MAX_S16_S16_S16_VAR;
		op_handlers[QB_MAX_S16_S16_S16_ELV] = &&label_MAX_S16_S16_S16_ELV;
		op_handlers[QB_MAX_S16_S16_S16_ARR] = &&label_MAX_S16_S16_S16_ARR;
		op_handlers[QB_RAND_S16_S16_S16_VAR] = &&label_RAND_S16_S16_S16_VAR;
		op_handlers[QB_RAND_S16_S16_S16_ELV] = &&label_RAND_S16_S16_S16_ELV;
		op_handlers[QB_RAND_S16_S16_S16_ARR] = &&label_RAND_S16_S16_S16_ARR;
		op_handlers[QB_MT_RAND_S16_S16_S16_VAR] = &&label_MT_RAND_S16_S16_S16_VAR;
		op_handlers[QB_MT_RAND_S16_S16_S16_ELV] = &&label_MT_RAND_S16_S16_S16_ELV;
		op_handlers[QB_MT_RAND_S16_S16_S16_ARR] = &&label_MT_RAND_S16_S16_S16_ARR;
		op_handlers[QB_PRN_S16_VAR] = &&label_PRN_S16_VAR;
		op_handlers[QB_PRN_S16_ELV] = &&label_PRN_S16_ELV;
		op_handlers[QB_PRN_S16_ARR] = &&label_PRN_S16_ARR;
		op_handlers[QB_PRN_DIM_S16_U32] = &&label_PRN_DIM_S16_U32;
		op_handlers[QB_CAT_S16_U08_VAR] = &&label_CAT_S16_U08_VAR;
		op_handlers[QB_CAT_S16_U08_ELV] = &&label_CAT_S16_U08_ELV;
		op_handlers[QB_CAT_S16_U08_ARR] = &&label_CAT_S16_U08_ARR;
		op_handlers[QB_CAT_DIM_S16_U32_U08] = &&label_CAT_DIM_S16_U32_U08;
		op_handlers[QB_PACK_LE_I16_U08_VAR] = &&label_PACK_LE_I16_U08_VAR;
		op_handlers[QB_PACK_LE_I16_U08_ELV] = &&label_PACK_LE_I16_U08_ELV;
		op_handlers[QB_PACK_BE_I16_U08_VAR] = &&label_PACK_BE_I16_U08_VAR;
		op_handlers[QB_PACK_BE_I16_U08_ELV] = &&label_PACK_BE_I16_U08_ELV;
		op_handlers[QB_UNPACK_LE_U08_I16_VAR] = &&label_UNPACK_LE_U08_I16_VAR;
		op_handlers[QB_UNPACK_LE_U08_I16_ELV] = &&label_UNPACK_LE_U08_I16_ELV;
		op_handlers[QB_UNPACK_BE_U08_I16_VAR] = &&label_UNPACK_BE_U08_I16_VAR;
		op_handlers[QB_UNPACK_BE_U08_I16_ELV] = &&label_UNPACK_BE_U08_I16_ELV;
		op_handlers[QB_SORT_S16] = &&label_SORT_S16;
		op_handlers[QB_RSORT_S16] = &&label_RSORT_S16;
		op_handlers[QB_AMIN_S16_S16_VAR] = &&label_AMIN_S16_S16_VAR;
		op_handlers[QB_AMAX_S16_S16_VAR] = &&label_AMAX_S16_S16_VAR;
		op_handlers[QB_APROD_S16_S16_VAR] = &&label_APROD_S16_S16_VAR;
		op_handlers[QB_ASUM_S16_S16_VAR] = &&label_ASUM_S16_S16_VAR;
		op_handlers[QB_RANGE_S16_S16_S16_S16_VAR] = &&label_RANGE_S16_S16_S16_S16_VAR;
		op_handlers[QB_AMIN_S16_S16_ELV] = &&label_AMIN_S16_S16_ELV;
		op_handlers[QB_AMAX_S16_S16_ELV] = &&label_AMAX_S16_S16_ELV;
		op_handlers[QB_APROD_S16_S16_ELV] = &&label_APROD_S16_S16_ELV;
		op_handlers[QB_ASUM_S16_S16_ELV] = &&label_ASUM_S16_S16_ELV;
		op_handlers[QB_RANGE_S16_S16_S16_S16_ELV] = &&label_RANGE_S16_S16_S16_S16_ELV;
		op_handlers[QB_AFIND_IDX_I16_I16_I32_VAR] = &&label_AFIND_IDX_I16_I16_I32_VAR;
		op_handlers[QB_AFIND_IDX_I16_I16_I32_ELV] = &&label_AFIND_IDX_I16_I16_I32_ELV;
		op_handlers[QB_AFIND_IDX_I16_I16_I32_ARR] = &&label_AFIND_IDX_I16_I16_I32_ARR;
		op_handlers[QB_AFIND_I16_I16_I32_VAR] = &&label_AFIND_I16_I16_I32_VAR;
		op_handlers[QB_AFIND_I16_I16_I32_ELV] = &&label_AFIND_I16_I16_I32_ELV;
		op_handlers[QB_AFIND_I16_I16_I32_ARR] = &&label_AFIND_I16_I16_I32_ARR;
		op_handlers[QB_APOS_I16_I16_I32_I32] = &&label_APOS_I16_I16_I32_I32;
		op_handlers[QB_ARPOS_I16_I16_I32_I32] = &&label_ARPOS_I16_I16_I32_I32;
		op_handlers[QB_AREV_I16_U32_I16] = &&label_AREV_I16_U32_I16;
		op_handlers[QB_AINS_I16_U32_I16] = &&label_AINS_I16_U32_I16;
		op_handlers[QB_AUNIQ_I16_U32_I16] = &&label_AUNIQ_I16_U32_I16;
		op_handlers[QB_IF_LT_U16_U16_VAR] = &&label_IF_LT_U16_U16_VAR;
		op_handlers[QB_IF_LT_U16_U16_ELV] = &&label_IF_LT_U16_U16_ELV;
		op_handlers[QB_IF_GT_U16_U16_VAR] = &&label_IF_GT_U16_U16_VAR;
		op_handlers[QB_IF_GT_U16_U16_ELV] = &&label_IF_GT_U16_U16_ELV;
		op_handlers[QB_IF_LE_U16_U16_VAR] = &&label_IF_LE_U16_U16_VAR;
		op_handlers[QB_IF_LE_U16_U16_ELV] = &&label_IF_LE_U16_U16_ELV;
		op_handlers[QB_IF_GE_U16_U16_VAR] = &&label_IF_GE_U16_U16_VAR;
		op_handlers[QB_IF_GE_U16_U16_ELV] = &&label_IF_GE_U16_U16_ELV;
		op_handlers[QB_MUL_U16_U16_U16_VAR] = &&label_MUL_U16_U16_U16_VAR;
		op_handlers[QB_MUL_U16_U16_U16_ELV] = &&label_MUL_U16_U16_U16_ELV;
		op_handlers[QB_MUL_U16_U16_U16_ARR] = &&label_MUL_U16_U16_U16_ARR;
		op_handlers[QB_DIV_U16_U16_U16_VAR] = &&label_DIV_U16_U16_U16_VAR;
		op_handlers[QB_DIV_U16_U16_U16_ELV] = &&label_DIV_U16_U16_U16_ELV;
		op_handlers[QB_DIV_U16_U16_U16_ARR] = &&label_DIV_U16_U16_U16_ARR;
		op_handlers[QB_MOD_U16_U16_U16_VAR] = &&label_MOD_U16_U16_U16_VAR;
		op_handlers[QB_MOD_U16_U16_U16_ELV] = &&label_MOD_U16_U16_U16_ELV;
		op_handlers[QB_MOD_U16_U16_U16_ARR] = &&label_MOD_U16_U16_U16_ARR;
		op_handlers[QB_LT_U16_U16_I32_VAR] = &&label_LT_U16_U16_I32_VAR;
		op_handlers[QB_LT_U16_U16_I32_ELV] = &&label_LT_U16_U16_I32_ELV;
		op_handlers[QB_LT_U16_U16_I32_ARR] = &&label_LT_U16_U16_I32_ARR;
		op_handlers[QB_LE_U16_U16_I32_VAR] = &&label_LE_U16_U16_I32_VAR;
		op_handlers[QB_LE_U16_U16_I32_ELV] = &&label_LE_U16_U16_I32_ELV;
		op_handlers[QB_LE_U16_U16_I32_ARR] = &&label_LE_U16_U16_I32_ARR;
		op_handlers[QB_LT_SET_U16_U16_I32] = &&label_LT_SET_U16_U16_I32;
		op_handlers[QB_LE_SET_U16_U16_I32] = &&label_LE_SET_U16_U16_I32;
		op_handlers[QB_SHL_U16_U16_U16_VAR] = &&label_SHL_U16_U16_U16_VAR;
		op_handlers[QB_SHL_U16_U16_U16_ELV] = &&label_SHL_U16_U16_U16_ELV;
		op_handlers[QB_SHL_U16_U16_U16_ARR] = &&label_SHL_U16_U16_U16_ARR;
		op_handlers[QB_SHR_U16_U16_U16_VAR] = &&label_SHR_U16_U16_U16_VAR;
		op_handlers[QB_SHR_U16_U16_U16_ELV] = &&label_SHR_U16_U16_U16_ELV;
		op_handlers[QB_SHR_U16_U16_U16_ARR] = &&label_SHR_U16_U16_U16_ARR;
		op_handlers[QB_MOV_U16_I32_VAR] = &&label_MOV_U16_I32_VAR;
		op_handlers[QB_MOV_U16_I32_ELV] = &&label_MOV_U16_I32_ELV;
		op_handlers[QB_MOV_U16_I32_ARR] = &&label_MOV_U16_I32_ARR;
		op_handlers[QB_MOV_U16_I64_VAR] = &&label_MOV_U16_I64_VAR;
		op_handlers[QB_MOV_U16_I64_ELV] = &&label_MOV_U16_I64_ELV;
		op_handlers[QB_MOV_U16_I64_ARR] = &&label_MOV_U16_I64_ARR;
		op_handlers[QB_MOV_U16_F32_VAR] = &&label_MOV_U16_F32_VAR;
		op_handlers[QB_MOV_U16_F32_ELV] = &&label_MOV_U16_F32_ELV;
		op_handlers[QB_MOV_U16_F32_ARR] = &&label_MOV_U16_F32_ARR;
		op_handlers[QB_MOV_U16_F64_VAR] = &&label_MOV_U16_F64_VAR;
		op_handlers[QB_MOV_U16_F64_ELV] = &&label_MOV_U16_F64_ELV;
		op_handlers[QB_MOV_U16_F64_ARR] = &&label_MOV_U16_F64_ARR;
		op_handlers[QB_MIN_U16_U16_U16_VAR] = &&label_MIN_U16_U16_U16_VAR;
		op_handlers[QB_MIN_U16_U16_U16_ELV] = &&label_MIN_U16_U16_U16_ELV;
		op_handlers[QB_MIN_U16_U16_U16_ARR] = &&label_MIN_U16_U16_U16_ARR;
		op_handlers[QB_MAX_U16_U16_U16_VAR] = &&label_MAX_U16_U16_U16_VAR;
		op_handlers[QB_MAX_U16_U16_U16_ELV] = &&label_MAX_U16_U16_U16_ELV;
		op_handlers[QB_MAX_U16_U16_U16_ARR] = &&label_MAX_U16_U16_U16_ARR;
		op_handlers[QB_RAND_U16_U16_U16_VAR] = &&label_RAND_U16_U16_U16_VAR;
		op_handlers[QB_RAND_U16_U16_U16_ELV] = &&label_RAND_U16_U16_U16_ELV;
		op_handlers[QB_RAND_U16_U16_U16_ARR] = &&label_RAND_U16_U16_U16_ARR;
		op_handlers[QB_MT_RAND_U16_U16_U16_VAR] = &&label_MT_RAND_U16_U16_U16_VAR;
		op_handlers[QB_MT_RAND_U16_U16_U16_ELV] = &&label_MT_RAND_U16_U16_U16_ELV;
		op_handlers[QB_MT_RAND_U16_U16_U16_ARR] = &&label_MT_RAND_U16_U16_U16_ARR;
		op_handlers[QB_UTF8_DEC_U08_U16] = &&label_UTF8_DEC_U08_U16;
		op_handlers[QB_UTF8_ENC_U16_U08] = &&label_UTF8_ENC_U16_U08;
		op_handlers[QB_PRN_U16_VAR] = &&label_PRN_U16_VAR;
		op_handlers[QB_PRN_U16_ELV] = &&label_PRN_U16_ELV;
		op_handlers[QB_PRN_U16_ARR] = &&label_PRN_U16_ARR;
		op_handlers[QB_PRN_DIM_U16_U32] = &&label_PRN_DIM_U16_U32;
		op_handlers[QB_CAT_U16_U08_VAR] = &&label_CAT_U16_U08_VAR;
		op_handlers[QB_CAT_U16_U08_ELV] = &&label_CAT_U16_U08_ELV;
		op_handlers[QB_CAT_U16_U08_ARR] = &&label_CAT_U16_U08_ARR;
		op_handlers[QB_CAT_DIM_U16_U32_U08] = &&label_CAT_DIM_U16_U32_U08;
		op_handlers[QB_SORT_U16] = &&label_SORT_U16;
		op_handlers[QB_RSORT_U16] = &&label_RSORT_U16;
		op_handlers[QB_AMIN_U16_U16_VAR] = &&label_AMIN_U16_U16_VAR;
		op_handlers[QB_AMAX_U16_U16_VAR] = &&label_AMAX_U16_U16_VAR;
		op_handlers[QB_APROD_U16_U16_VAR] = &&label_APROD_U16_U16_VAR;
		op_handlers[QB_ASUM_U16_U16_VAR] = &&label_ASUM_U16_U16_VAR;
		op_handlers[QB_RANGE_U16_U16_S16_U16_VAR] = &&label_RANGE_U16_U16_S16_U16_VAR;
		op_handlers[QB_AMIN_U16_U16_ELV] = &&label_AMIN_U16_U16_ELV;
		op_handlers[QB_AMAX_U16_U16_ELV] = &&label_AMAX_U16_U16_ELV;
		op_handlers[QB_APROD_U16_U16_ELV] = &&label_APROD_U16_U16_ELV;
		op_handlers[QB_ASUM_U16_U16_ELV] = &&label_ASUM_U16_U16_ELV;
		op_handlers[QB_RANGE_U16_U16_S16_U16_ELV] = &&label_RANGE_U16_U16_S16_U16_ELV;
		op_handlers[QB_IF_EQ_I64_I64_VAR] = &&label_IF_EQ_I64_I64_VAR;
		op_handlers[QB_IF_EQ_I64_I64_ELV] = &&label_IF_EQ_I64_I64_ELV;
		op_handlers[QB_IF_NE_I64_I64_VAR] = &&label_IF_NE_I64_I64_VAR;
		op_handlers[QB_IF_NE_I64_I64_ELV] = &&label_IF_NE_I64_I64_ELV;
		op_handlers[QB_IF_LT_S64_S64_VAR] = &&label_IF_LT_S64_S64_VAR;
		op_handlers[QB_IF_LT_S64_S64_ELV] = &&label_IF_LT_S64_S64_ELV;
		op_handlers[QB_IF_GT_S64_S64_VAR] = &&label_IF_GT_S64_S64_VAR;
		op_handlers[QB_IF_GT_S64_S64_ELV] = &&label_IF_GT_S64_S64_ELV;
		op_handlers[QB_IF_LE_S64_S64_VAR] = &&label_IF_LE_S64_S64_VAR;
		op_handlers[QB_IF_LE_S64_S64_ELV] = &&label_IF_LE_S64_S64_ELV;
		op_handlers[QB_IF_GE_S64_S64_VAR] = &&label_IF_GE_S64_S64_VAR;
		op_handlers[QB_IF_GE_S64_S64_ELV] = &&label_IF_GE_S64_S64_ELV;
		op_handlers[QB_ADD_I64_I64_I64_VAR] = &&label_ADD_I64_I64_I64_VAR;
		op_handlers[QB_ADD_I64_I64_I64_ELV] = &&label_ADD_I64_I64_I64_ELV;
		op_handlers[QB_ADD_I64_I64_I64_ARR] = &&label_ADD_I64_I64_I64_ARR;
		op_handlers[QB_SUB_I64_I64_I64_VAR] = &&label_SUB_I64_I64_I64_VAR;
		op_handlers[QB_SUB_I64_I64_I64_ELV] = &&label_SUB_I64_I64_I64_ELV;
		op_handlers[QB_SUB_I64_I64_I64_ARR] = &&label_SUB_I64_I64_I64_ARR;
		op_handlers[QB_MUL_S64_S64_S64_VAR] = &&label_MUL_S64_S64_S64_VAR;
		op_handlers[QB_MUL_S64_S64_S64_ELV] = &&label_MUL_S64_S64_S64_ELV;
		op_handlers[QB_MUL_S64_S64_S64_ARR] = &&label_MUL_S64_S64_S64_ARR;
		op_handlers[QB_DIV_S64_S64_S64_VAR] = &&label_DIV_S64_S64_S64_VAR;
		op_handlers[QB_DIV_S64_S64_S64_ELV] = &&label_DIV_S64_S64_S64_ELV;
		op_handlers[QB_DIV_S64_S64_S64_ARR] = &&label_DIV_S64_S64_S64_ARR;
		op_handlers[QB_MOD_S64_S64_S64_VAR] = &&label_MOD_S64_S64_S64_VAR;
		op_handlers[QB_MOD_S64_S64_S64_ELV] = &&label_MOD_S64_S64_S64_ELV;
		op_handlers[QB_MOD_S64_S64_S64_ARR] = &&label_MOD_S64_S64_S64_ARR;
		op_handlers[QB_MAC_S64_S64_S64_S64_VAR] = &&label_MAC_S64_S64_S64_S64_VAR;
		op_handlers[QB_MAC_S64_S64_S64_S64_ELV] = &&label_MAC_S64_S64_S64_S64_ELV;
		op_handlers[QB_MAC_S64_S64_S64_S64_ARR] = &&label_MAC_S64_S64_S64_S64_ARR;
		op_handlers[QB_NEG_I64_I64_VAR] = &&label_NEG_I64_I64_VAR;
		op_handlers[QB_NEG_I64_I64_ELV] = &&label_NEG_I64_I64_ELV;
		op_handlers[QB_NEG_I64_I64_ARR] = &&label_NEG_I64_I64_ARR;
		op_handlers[QB_MOV_I64_I64_VAR] = &&label_MOV_I64_I64_VAR;
		op_handlers[QB_MOV_I64_I64_ELV] = &&label_MOV_I64_I64_ELV;
		op_handlers[QB_MOV_I64_I64_ARR] = &&label_MOV_I64_I64_ARR;
		op_handlers[QB_INC_I64_VAR] = &&label_INC_I64_VAR;
		op_handlers[QB_INC_I64_ELV] = &&label_INC_I64_ELV;
		op_handlers[QB_INC_I64_ARR] = &&label_INC_I64_ARR;
		op_handlers[QB_DEC_I64_VAR] = &&label_DEC_I64_VAR;
		op_handlers[QB_DEC_I64_ELV] = &&label_DEC_I64_ELV;
		op_handlers[QB_DEC_I64_ARR] = &&label_DEC_I64_ARR;
		op_handlers[QB_EQ_I64_I64_I32_VAR] = &&label_EQ_I64_I64_I32_VAR;
		op_handlers[QB_EQ_I64_I64_I32_ELV] = &&label_EQ_I64_I64_I32_ELV;
		op_handlers[QB_EQ_I64_I64_I32_ARR] = &&label_EQ_I64_I64_I32_ARR;
		op_handlers[QB_NE_I64_I64_I32_VAR] = &&label_NE_I64_I64_I32_VAR;
		op_handlers[QB_NE_I64_I64_I32_ELV] = &&label_NE_I64_I64_I32_ELV;
		op_handlers[QB_NE_I64_I64_I32_ARR] = &&label_NE_I64_I64_I32_ARR;
		op_handlers[QB_LT_S64_S64_I32_VAR] = &&label_LT_S64_S64_I32_VAR;
		op_handlers[QB_LT_S64_S64_I32_ELV] = &&label_LT_S64_S64_I32_ELV;
		op_handlers[QB_LT_S64_S64_I32_ARR] = &&label_LT_S64_S64_I32_ARR;
		op_handlers[QB_LE_S64_S64_I32_VAR] = &&label_LE_S64_S64_I32_VAR;
		op_handlers[QB_LE_S64_S64_I32_ELV] = &&label_LE_S64_S64_I32_ELV;
		op_handlers[QB_LE_S64_S64_I32_ARR] = &&label_LE_S64_S64_I32_ARR;
		op_handlers[QB_EQ_SET_I64_I64_I32] = &&label_EQ_SET_I64_I64_I32;
		op_handlers[QB_NE_SET_I64_I64_I32] = &&label_NE_SET_I64_I64_I32;
		op_handlers[QB_LT_SET_S64_S64_I32] = &&label_LT_SET_S64_S64_I32;
		op_handlers[QB_LE_SET_S64_S64_I32] = &&label_LE_SET_S64_S64_I32;
		op_handlers[QB_BW_AND_I64_I64_I64_VAR] = &&label_BW_AND_I64_I64_I64_VAR;
		op_handlers[QB_BW_AND_I64_I64_I64_ELV] = &&label_BW_AND_I64_I64_I64_ELV;
		op_handlers[QB_BW_AND_I64_I64_I64_ARR] = &&label_BW_AND_I64_I64_I64_ARR;
		op_handlers[QB_BW_OR_I64_I64_I64_VAR] = &&label_BW_OR_I64_I64_I64_VAR;
		op_handlers[QB_BW_OR_I64_I64_I64_ELV] = &&label_BW_OR_I64_I64_I64_ELV;
		op_handlers[QB_BW_OR_I64_I64_I64_ARR] = &&label_BW_OR_I64_I64_I64_ARR;
		op_handlers[QB_BW_XOR_I64_I64_I64_VAR] = &&label_BW_XOR_I64_I64_I64_VAR;
		op_handlers[QB_BW_XOR_I64_I64_I64_ELV] = &&label_BW_XOR_I64_I64_I64_ELV;
		op_handlers[QB_BW_XOR_I64_I64_I64_ARR] = &&label_BW_XOR_I64_I64_I64_ARR;
		op_handlers[QB_BW_NOT_I64_I64_VAR] = &&label_BW_NOT_I64_I64_VAR;
		op_handlers[QB_BW_NOT_I64_I64_ELV] = &&label_BW_NOT_I64_I64_ELV;
		op_handlers[QB_BW_NOT_I64_I64_ARR] = &&label_BW_NOT_I64_I64_ARR;
		op_handlers[QB_SHL_S64_S64_S64_VAR] = &&label_SHL_S64_S64_S64_VAR;
		op_handlers[QB_SHL_S64_S64_S64_ELV] = &&label_SHL_S64_S64_S64_ELV;
		op_handlers[QB_SHL_S64_S64_S64_ARR] = &&label_SHL_S64_S64_S64_ARR;
		op_handlers[QB_SHR_S64_S64_S64_VAR] = &&label_SHR_S64_S64_S64_VAR;
		op_handlers[QB_SHR_S64_S64_S64_ELV] = &&label_SHR_S64_S64_S64_ELV;
		op_handlers[QB_SHR_S64_S64_S64_ARR] = &&label_SHR_S64_S64_S64_ARR;
		op_handlers[QB_ISSET_I64_I32_ELV] = &&label_ISSET_I64_I32_ELV;
		op_handlers[QB_UNSET_I64_VAR] = &&label_UNSET_I64_VAR;
		op_handlers[QB_UNSET_I64_ELV] = &&label_UNSET_I64_ELV;
		op_handlers[QB_UNSET_I64_ARR] = &&label_UNSET_I64_ARR;
		op_handlers[QB_MOV_I64_I32_VAR] = &&label_MOV_I64_I32_VAR;
		op_handlers[QB_MOV_I64_I32_ELV] = &&label_MOV_I64_I32_ELV;
		op_handlers[QB_MOV_I64_I32_ARR] = &&label_MOV_I64_I32_ARR;
		op_handlers[QB_MOV_I64_I08_VAR] = &&label_MOV_I64_I08_VAR;
		op_handlers[QB_MOV_I64_I08_ELV] = &&label_MOV_I64_I08_ELV;
		op_handlers[QB_MOV_I64_I08_ARR] = &&label_MOV_I64_I08_ARR;
		op_handlers[QB_MOV_I64_I16_VAR] = &&label_MOV_I64_I16_VAR;
		op_handlers[QB_MOV_I64_I16_ELV] = &&label_MOV_I64_I16_ELV;
		op_handlers[QB_MOV_I64_I16_ARR] = &&label_MOV_I64_I16_ARR;
		op_handlers[QB_MOV_S64_F32_VAR] = &&label_MOV_S64_F32_VAR;
		op_handlers[QB_MOV_S64_F32_ELV] = &&label_MOV_S64_F32_ELV;
		op_handlers[QB_MOV_S64_F32_ARR] = &&label_MOV_S64_F32_ARR;
		op_handlers[QB_MOV_S64_F64_VAR] = &&label_MOV_S64_F64_VAR;
		op_handlers[QB_MOV_S64_F64_ELV] = &&label_MOV_S64_F64_ELV;
		op_handlers[QB_MOV_S64_F64_ARR] = &&label_MOV_S64_F64_ARR;
		op_handlers[QB_BOOL_I64_I32_VAR] = &&label_BOOL_I64_I32_VAR;
		op_handlers[QB_BOOL_I64_I32_ELV] = &&label_BOOL_I64_I32_ELV;
		op_handlers[QB_BOOL_I64_I32_ARR] = &&label_BOOL_I64_I32_ARR;
		op_handlers[QB_ABS_S64_S64_VAR] = &&label_ABS_S64_S64_VAR;
		op_handlers[QB_ABS_S64_S64_ELV] = &&label_ABS_S64_S64_ELV;
		op_handlers[QB_ABS_S64_S64_ARR] = &&label_ABS_S64_S64_ARR;
		op_handlers[QB_MIN_S64_S64_S64_VAR] = &&label_MIN_S64_S64_S64_VAR;
		op_handlers[QB_MIN_S64_S64_S64_ELV] = &&label_MIN_S64_S64_S64_ELV;
		op_handlers[QB_MIN_S64_S64_S64_ARR] = &&label_MIN_S64_S64_S64_ARR;
		op_handlers[QB_MAX_S64_S64_S64_VAR] = &&label_MAX_S64_S64_S64_VAR;
		op_handlers[QB_MAX_S64_S64_S64_ELV] = &&label_MAX_S64_S64_S64_ELV;
		op_handlers[QB_MAX_S64_S64_S64_ARR] = &&label_MAX_S64_S64_S64_ARR;
		op_handlers[QB_RAND_S64_S64_S64_VAR] = &&label_RAND_S64_S64_S64_VAR;
		op_handlers[QB_RAND_S64_S64_S64_ELV] = &&label_RAND_S64_S64_S64_ELV;
		op_handlers[QB_RAND_S64_S64_S64_ARR] = &&label_RAND_S64_S64_S64_ARR;
		op_handlers[QB_MT_RAND_S64_S64_S64_VAR] = &&label_MT_RAND_S64_S64_S64_VAR;
		op_handlers[QB_MT_RAND_S64_S64_S64_ELV] = &&label_MT_RAND_S64_S64_S64_ELV;
		op_handlers[QB_MT_RAND_S64_S64_S64_ARR] = &&label_MT_RAND_S64_S64_S64_ARR;
		op_handlers[QB_PRN_S64_VAR] = &&label_PRN_S64_VAR;
		op_handlers[QB_PRN_S64_ELV] = &&label_PRN_S64_ELV;
		op_handlers[QB_PRN_S64_ARR] = &&label_PRN_S64_ARR;
		op_handlers[QB_PRN_DIM_S64_U32] = &&label_PRN_DIM_S64_U32;
		op_handlers[QB_CAT_S64_U08_VAR] = &&label_CAT_S64_U08_VAR;
		op_handlers[QB_CAT_S64_U08_ELV] = &&label_CAT_S64_U08_ELV;
		op_handlers[QB_CAT_S64_U08_ARR] = &&label_CAT_S64_U08_ARR;
		op_handlers[QB_CAT_DIM_S64_U32_U08] = &&label_CAT_DIM_S64_U32_U08;
		op_handlers[QB_PACK_LE_I64_U08_VAR] = &&label_PACK_LE_I64_U08_VAR;
		op_handlers[QB_PACK_LE_I64_U08_ELV] = &&label_PACK_LE_I64_U08_ELV;
		op_handlers[QB_PACK_BE_I64_U08_VAR] = &&label_PACK_BE_I64_U08_VAR;
		op_handlers[QB_PACK_BE_I64_U08_ELV] = &&label_PACK_BE_I64_U08_ELV;
		op_handlers[QB_UNPACK_LE_U08_I64_VAR] = &&label_UNPACK_LE_U08_I64_VAR;
		op_handlers[QB_UNPACK_LE_U08_I64_ELV] = &&label_UNPACK_LE_U08_I64_ELV;
		op_handlers[QB_UNPACK_BE_U08_I64_VAR] = &&label_UNPACK_BE_U08_I64_VAR;
		op_handlers[QB_UNPACK_BE_U08_I64_ELV] = &&label_UNPACK_BE_U08_I64_ELV;
		op_handlers[QB_SORT_S64] = &&label_SORT_S64;
		op_handlers[QB_RSORT_S64] = &&label_RSORT_S64;
		op_handlers[QB_AMIN_S64_S64_VAR] = &&label_AMIN_S64_S64_VAR;
		op_handlers[QB_AMAX_S64_S64_VAR] = &&label_AMAX_S64_S64_VAR;
		op_handlers[QB_APROD_S64_S64_VAR] = &&label_APROD_S64_S64_VAR;
		op_handlers[QB_ASUM_S64_S64_VAR] = &&label_ASUM_S64_S64_VAR;
		op_handlers[QB_RANGE_S64_S64_S64_S64_VAR] = &&label_RANGE_S64_S64_S64_S64_VAR;
		op_handlers[QB_AMIN_S64_S64_ELV] = &&label_AMIN_S64_S64_ELV;
		op_handlers[QB_AMAX_S64_S64_ELV] = &&label_AMAX_S64_S64_ELV;
		op_handlers[QB_APROD_S64_S64_ELV] = &&label_APROD_S64_S64_ELV;
		op_handlers[QB_ASUM_S64_S64_ELV] = &&label_ASUM_S64_S64_ELV;
		op_handlers[QB_RANGE_S64_S64_S64_S64_ELV] = &&label_RANGE_S64_S64_S64_S64_ELV;
		op_handlers[QB_AFIND_IDX_I64_I64_I32_VAR] = &&label_AFIND_IDX_I64_I64_I32_VAR;
		op_handlers[QB_AFIND_IDX_I64_I64_I32_ELV] = &&label_AFIND_IDX_I64_I64_I32_ELV;
		op_handlers[QB_AFIND_IDX_I64_I64_I32_ARR] = &&label_AFIND_IDX_I64_I64_I32_ARR;
		op_handlers[QB_AFIND_I64_I64_I32_VAR] = &&label_AFIND_I64_I64_I32_VAR;
		op_handlers[QB_AFIND_I64_I64_I32_ELV] = &&label_AFIND_I64_I64_I32_ELV;
		op_handlers[QB_AFIND_I64_I64_I32_ARR] = &&label_AFIND_I64_I64_I32_ARR;
		op_handlers[QB_APOS_I64_I64_I32_I32] = &&label_APOS_I64_I64_I32_I32;
		op_handlers[QB_ARPOS_I64_I64_I32_I32] = &&label_ARPOS_I64_I64_I32_I32;
		op_handlers[QB_AREV_I64_U32_I64] = &&label_AREV_I64_U32_I64;
		op_handlers[QB_AINS_I64_U32_I64] = &&label_AINS_I64_U32_I64;
		op_handlers[QB_AUNIQ_I64_U32_I64] = &&label_AUNIQ_I64_U32_I64;
		op_handlers[QB_IF_LT_U64_U64_VAR] = &&label_IF_LT_U64_U64_VAR;
		op_handlers[QB_IF_LT_U64_U64_ELV] = &&label_IF_LT_U64_U64_ELV;
		op_handlers[QB_IF_GT_U64_U64_VAR] = &&label_IF_GT_U64_U64_VAR;
		op_handlers[QB_IF_GT_U64_U64_ELV] = &&label_IF_GT_U64_U64_ELV;
		op_handlers[QB_IF_LE_U64_U64_VAR] = &&label_IF_LE_U64_U64_VAR;
		op_handlers[QB_IF_LE_U64_U64_ELV] = &&label_IF_LE_U64_U64_ELV;
		op_handlers[QB_IF_GE_U64_U64_VAR] = &&label_IF_GE_U64_U64_VAR;
		op_handlers[QB_IF_GE_U64_U64_ELV] = &&label_IF_GE_U64_U64_ELV;
		op_handlers[QB_MUL_U64_U64_U64_VAR] = &&label_MUL_U64_U64_U64_VAR;
		op_handlers[QB_MUL_U64_U64_U64_ELV] = &&label_MUL_U64_U64_U64_ELV;
		op_handlers[QB_MUL_U64_U64_U64_ARR] = &&label_MUL_U64_U64_U64_ARR;
		op_handlers[QB_DIV_U64_U64_U64_VAR] = &&label_DIV_U64_U64_U64_VAR;
		op_handlers[QB_DIV_U64_U64_U64_ELV] = &&label_DIV_U64_U64_U64_ELV;
		op_handlers[QB_DIV_U64_U64_U64_ARR] = &&label_DIV_U64_U64_U64_ARR;
		op_handlers[QB_MOD_U64_U64_U64_VAR] = &&label_MOD_U64_U64_U64_VAR;
		op_handlers[QB_MOD_U64_U64_U64_ELV] = &&label_MOD_U64_U64_U64_ELV;
		op_handlers[QB_MOD_U64_U64_U64_ARR] = &&label_MOD_U64_U64_U64_ARR;
		op_handlers[QB_MAC_U64_U64_U64_U64_VAR] = &&label_MAC_U64_U64_U64_U64_VAR;
		op_handlers[QB_MAC_U64_U64_U64_U64_ELV] = &&label_MAC_U64_U64_U64_U64_ELV;
		op_handlers[QB_MAC_U64_U64_U64_U64_ARR] = &&label_MAC_U64_U64_U64_U64_ARR;
		op_handlers[QB_LT_U64_U64_I32_VAR] = &&label_LT_U64_U64_I32_VAR;
		op_handlers[QB_LT_U64_U64_I32_ELV] = &&label_LT_U64_U64_I32_ELV;
		op_handlers[QB_LT_U64_U64_I32_ARR] = &&label_LT_U64_U64_I32_ARR;
		op_handlers[QB_LE_U64_U64_I32_VAR] = &&label_LE_U64_U64_I32_VAR;
		op_handlers[QB_LE_U64_U64_I32_ELV] = &&label_LE_U64_U64_I32_ELV;
		op_handlers[QB_LE_U64_U64_I32_ARR] = &&label_LE_U64_U64_I32_ARR;
		op_handlers[QB_LT_SET_U64_U64_I32] = &&label_LT_SET_U64_U64_I32;
		op_handlers[QB_LE_SET_U64_U64_I32] = &&label_LE_SET_U64_U64_I32;
		op_handlers[QB_SHL_U64_U64_U64_VAR] = &&label_SHL_U64_U64_U64_VAR;
		op_handlers[QB_SHL_U64_U64_U64_ELV] = &&label_SHL_U64_U64_U64_ELV;
		op_handlers[QB_SHL_U64_U64_U64_ARR] = &&label_SHL_U64_U64_U64_ARR;
		op_handlers[QB_SHR_U64_U64_U64_VAR] = &&label_SHR_U64_U64_U64_VAR;
		op_handlers[QB_SHR_U64_U64_U64_ELV] = &&label_SHR_U64_U64_U64_ELV;
		op_handlers[QB_SHR_U64_U64_U64_ARR] = &&label_SHR_U64_U64_U64_ARR;
		op_handlers[QB_MOV_U64_F32_VAR] = &&label_MOV_U64_F32_VAR;
		op_handlers[QB_MOV_U64_F32_ELV] = &&label_MOV_U64_F32_ELV;
		op_handlers[QB_MOV_U64_F32_ARR] = &&label_MOV_U64_F32_ARR;
		op_handlers[QB_MOV_U64_F64_VAR] = &&label_MOV_U64_F64_VAR;
		op_handlers[QB_MOV_U64_F64_ELV] = &&label_MOV_U64_F64_ELV;
		op_handlers[QB_MOV_U64_F64_ARR] = &&label_MOV_U64_F64_ARR;
		op_handlers[QB_MIN_U64_U64_U64_VAR] = &&label_MIN_U64_U64_U64_VAR;
		op_handlers[QB_MIN_U64_U64_U64_ELV] = &&label_MIN_U64_U64_U64_ELV;
		op_handlers[QB_MIN_U64_U64_U64_ARR] = &&label_MIN_U64_U64_U64_ARR;
		op_handlers[QB_MAX_U64_U64_U64_VAR] = &&label_MAX_U64_U64_U64_VAR;
		op_handlers[QB_MAX_U64_U64_U64_ELV] = &&label_MAX_U64_U64_U64_ELV;
		op_handlers[QB_MAX_U64_U64_U64_ARR] = &&label_MAX_U64_U64_U64_ARR;
		op_handlers[QB_RAND_U64_U64_U64_VAR] = &&label_RAND_U64_U64_U64_VAR;
		op_handlers[QB_RAND_U64_U64_U64_ELV] = &&label_RAND_U64_U64_U64_ELV;
		op_handlers[QB_RAND_U64_U64_U64_ARR] = &&label_RAND_U64_U64_U64_ARR;
		op_handlers[QB_MT_RAND_U64_U64_U64_VAR] = &&label_MT_RAND_U64_U64_U64_VAR;
		op_handlers[QB_MT_RAND_U64_U64_U64_ELV] = &&label_MT_RAND_U64_U64_U64_ELV;
		op_handlers[QB_MT_RAND_U64_U64_U64_ARR] = &&label_MT_RAND_U64_U64_U64_ARR;
		op_handlers[QB_PRN_U64_VAR] = &&label_PRN_U64_VAR;
		op_handlers[QB_PRN_U64_ELV] = &&label_PRN_U64_ELV;
		op_handlers[QB_PRN_U64_ARR] = &&label_PRN_U64_ARR;
		op_handlers[QB_PRN_DIM_U64_U32] = &&label_PRN_DIM_U64_U32;
		op_handlers[QB_CAT_U64_U08_VAR] = &&label_CAT_U64_U08_VAR;
		op_handlers[QB_CAT_U64_U08_ELV] = &&label_CAT_U64_U08_ELV;
		op_handlers[QB_CAT_U64_U08_ARR] = &&label_CAT_U64_U08_ARR;
		op_handlers[QB_CAT_DIM_U64_U32_U08] = &&label_CAT_DIM_U64_U32_U08;
		op_handlers[QB_SORT_U64] = &&label_SORT_U64;
		op_handlers[QB_RSORT_U64] = &&label_RSORT_U64;
		op_handlers[QB_AMIN_U64_U64_VAR] = &&label_AMIN_U64_U64_VAR;
		op_handlers[QB_AMAX_U64_U64_VAR] = &&label_AMAX_U64_U64_VAR;
		op_handlers[QB_APROD_U64_U64_VAR] = &&label_APROD_U64_U64_VAR;
		op_handlers[QB_ASUM_U64_U64_VAR] = &&label_ASUM_U64_U64_VAR;
		op_handlers[QB_RANGE_U64_U64_S64_U64_VAR] = &&label_RANGE_U64_U64_S64_U64_VAR;
		op_handlers[QB_AMIN_U64_U64_ELV] = &&label_AMIN_U64_U64_ELV;
		op_handlers[QB_AMAX_U64_U64_ELV] = &&label_AMAX_U64_U64_ELV;
		op_handlers[QB_APROD_U64_U64_ELV] = &&label_APROD_U64_U64_ELV;
		op_handlers[QB_ASUM_U64_U64_ELV] = &&label_ASUM_U64_U64_ELV;
		op_handlers[QB_RANGE_U64_U64_S64_U64_ELV] = &&label_RANGE_U64_U64_S64_U64_ELV;
		op_handlers[QB_IF_EQ_F32_F32_VAR] = &&label_IF_EQ_F32_F32_VAR;
		op_handlers[QB_IF_EQ_F32_F32_ELV] = &&label_IF_EQ_F32_F32_ELV;
		op_handlers[QB_IF_NE_F32_F32_VAR] = &&label_IF_NE_F32_F32_VAR;
		op_handlers[QB_IF_NE_F32_F32_ELV] = &&label_IF_NE_F32_F32_ELV;
		op_handlers[QB_IF_LT_F32_F32_VAR] = &&label_IF_LT_F32_F32_VAR;
		op_handlers[QB_IF_LT_F32_F32_ELV] = &&label_IF_LT_F32_F32_ELV;
		op_handlers[QB_IF_GT_F32_F32_VAR] = &&label_IF_GT_F32_F32_VAR;
		op_handlers[QB_IF_GT_F32_F32_ELV] = &&label_IF_GT_F32_F32_ELV;
		op_handlers[QB_IF_LE_F32_F32_VAR] = &&label_IF_LE_F32_F32_VAR;
		op_handlers[QB_IF_LE_F32_F32_ELV] = &&label_IF_LE_F32_F32_ELV;
		op_handlers[QB_IF_GE_F32_F32_VAR] = &&label_IF_GE_F32_F32_VAR;
		op_handlers[QB_IF_GE_F32_F32_ELV] = &&label_IF_GE_F32_F32_ELV;
		op_handlers[QB_ADD_F32_F32_F32_VAR] = &&label_ADD_F32_F32_F32_VAR;
		op_handlers[QB_ADD_F32_F32_F32_ELV] = &&label_ADD_F32_F32_F32_ELV;
		op_handlers[QB_ADD_F32_F32_F32_ARR] = &&label_ADD_F32_F32_F32_ARR;
		op_handlers[QB_SUB_F32_F32_F32_VAR] = &&label_SUB_F32_F32_F32_VAR;
		op_handlers[QB_SUB_F32_F32_F32_ELV] = &&label_SUB_F32_F32_F32_ELV;
		op_handlers[QB_SUB_F32_F32_F32_ARR] = &&label_SUB_F32_F32_F32_ARR;
		op_handlers[QB_MUL_F32_F32_F32_VAR] = &&label_MUL_F32_F32_F32_VAR;
		op_handlers[QB_MUL_F32_F32_F32_ELV] = &&label_MUL_F32_F32_F32_ELV;
		op_handlers[QB_MUL_F32_F32_F32_ARR] = &&label_MUL_F32_F32_F32_ARR;
		op_handlers[QB_DIV_F32_F32_F32_VAR] = &&label_DIV_F32_F32_F32_VAR;
		op_handlers[QB_DIV_F32_F32_F32_ELV] = &&label_DIV_F32_F32_F32_ELV;
		op_handlers[QB_DIV_F32_F32_F32_ARR] = &&label_DIV_F32_F32_F32_ARR;
		op_handlers[QB_MOD_F32_F32_F32_VAR] = &&label_MOD_F32_F32_F32_VAR;
		op_handlers[QB_MOD_F32_F32_F32_ELV] = &&label_MOD_F32_F32_F32_ELV;
		op_handlers[QB_MOD_F32_F32_F32_ARR] = &&label_MOD_F32_F32_F32_ARR;
		op_handlers[QB_MAC_F32_F32_F32_F32_VAR] = &&label_MAC_F32_F32_F32_F32_VAR;
		op_handlers[QB_MAC_F32_F32_F32_F32_ELV] = &&label_MAC_F32_F32_F32_F32_ELV;
		op_handlers[QB_MAC_F32_F32_F32_F32_ARR] = &&label_MAC_F32_F32_F32_F32_ARR;
		op_handlers[QB_MOD_FLR_F32_F32_F32_VAR] = &&label_MOD_FLR_F32_F32_F32_VAR;
		op_handlers[QB_MOD_FLR_F32_F32_F32_ELV] = &&label_MOD_FLR_F32_F32_F32_ELV;
		op_handlers[QB_MOD_FLR_F32_F32_F32_ARR] = &&label_MOD_FLR_F32_F32_F32_ARR;
		op_handlers[QB_NEG_F32_F32_VAR] = &&label_NEG_F32_F32_VAR;
		op_handlers[QB_NEG_F32_F32_ELV] = &&label_NEG_F32_F32_ELV;
		op_handlers[QB_NEG_F32_F32_ARR] = &&label_NEG_F32_F32_ARR;
		op_handlers[QB_MOV_F32_F32_VAR] = &&label_MOV_F32_F32_VAR;
		op_handlers[QB_MOV_F32_F32_ELV] = &&label_MOV_F32_F32_ELV;
		op_handlers[QB_MOV_F32_F32_ARR] = &&label_MOV_F32_F32_ARR;
		op_handlers[QB_INC_F32_VAR] = &&label_INC_F32_VAR;
		op_handlers[QB_INC_F32_ELV] = &&label_INC_F32_ELV;
		op_handlers[QB_INC_F32_ARR] = &&label_INC_F32_ARR;
		op_handlers[QB_DEC_F32_VAR] = &&label_DEC_F32_VAR;
		op_handlers[QB_DEC_F32_ELV] = &&label_DEC_F32_ELV;
		op_handlers[QB_DEC_F32_ARR] = &&label_DEC_F32_ARR;
		op_handlers[QB_EQ_F32_F32_I32_VAR] = &&label_EQ_F32_F32_I32_VAR;
		op_handlers[QB_EQ_F32_F32_I32_ELV] = &&label_EQ_F32_F32_I32_ELV;
		op_handlers[QB_EQ_F32_F32_I32_ARR] = &&label_EQ_F32_F32_I32_ARR;
		op_handlers[QB_NE_F32_F32_I32_VAR] = &&label_NE_F32_F32_I32_VAR;
		op_handlers[QB_NE_F32_F32_I32_ELV] = &&label_NE_F32_F32_I32_ELV;
		op_handlers[QB_NE_F32_F32_I32_ARR] = &&label_NE_F32_F32_I32_ARR;
		op_handlers[QB_LT_F32_F32_I32_VAR] = &&label_LT_F32_F32_I32_VAR;
		op_handlers[QB_LT_F32_F32_I32_ELV] = &&label_LT_F32_F32_I32_ELV;
		op_handlers[QB_LT_F32_F32_I32_ARR] = &&label_LT_F32_F32_I32_ARR;
		op_handlers[QB_LE_F32_F32_I32_VAR] = &&label_LE_F32_F32_I32_VAR;
		op_handlers[QB_LE_F32_F32_I32_ELV] = &&label_LE_F32_F32_I32_ELV;
		op_handlers[QB_LE_F32_F32_I32_ARR] = &&label_LE_F32_F32_I32_ARR;
		op_handlers[QB_EQ_SET_F32_F32_I32] = &&label_EQ_SET_F32_F32_I32;
		op_handlers[QB_NE_SET_F32_F32_I32] = &&label_NE_SET_F32_F32_I32;
		op_handlers[QB_LT_SET_F32_F32_I32] = &&label_LT_SET_F32_F32_I32;
		op_handlers[QB_LE_SET_F32_F32_I32] = &&label_LE_SET_F32_F32_I32;
		op_handlers[QB_ISSET_F32_I32_ELV] = &&label_ISSET_F32_I32_ELV;
		op_handlers[QB_UNSET_F32_VAR] = &&label_UNSET_F32_VAR;
		op_handlers[QB_UNSET_F32_ELV] = &&label_UNSET_F32_ELV;
		op_handlers[QB_UNSET_F32_ARR] = &&label_UNSET_F32_ARR;
		op_handlers[QB_MOV_F32_S32_VAR] = &&label_MOV_F32_S32_VAR;
		op_handlers[QB_MOV_F32_S32_ELV] = &&label_MOV_F32_S32_ELV;
		op_handlers[QB_MOV_F32_S32_ARR] = &&label_MOV_F32_S32_ARR;
		op_handlers[QB_MOV_F32_U32_VAR] = &&label_MOV_F32_U32_VAR;
		op_handlers[QB_MOV_F32_U32_ELV] = &&label_MOV_F32_U32_ELV;
		op_handlers[QB_MOV_F32_U32_ARR] = &&label_MOV_F32_U32_ARR;
		op_handlers[QB_MOV_F32_S08_VAR] = &&label_MOV_F32_S08_VAR;
		op_handlers[QB_MOV_F32_S08_ELV] = &&label_MOV_F32_S08_ELV;
		op_handlers[QB_MOV_F32_S08_ARR] = &&label_MOV_F32_S08_ARR;
		op_handlers[QB_MOV_F32_U08_VAR] = &&label_MOV_F32_U08_VAR;
		op_handlers[QB_MOV_F32_U08_ELV] = &&label_MOV_F32_U08_ELV;
		op_handlers[QB_MOV_F32_U08_ARR] = &&label_MOV_F32_U08_ARR;
		op_handlers[QB_MOV_F32_S16_VAR] = &&label_MOV_F32_S16_VAR;
		op_handlers[QB_MOV_F32_S16_ELV] = &&label_MOV_F32_S16_ELV;
		op_handlers[QB_MOV_F32_S16_ARR] = &&label_MOV_F32_S16_ARR;
		op_handlers[QB_MOV_F32_U16_VAR] = &&label_MOV_F32_U16_VAR;
		op_handlers[QB_MOV_F32_U16_ELV] = &&label_MOV_F32_U16_ELV;
		op_handlers[QB_MOV_F32_U16_ARR] = &&label_MOV_F32_U16_ARR;
		op_handlers[QB_MOV_F32_S64_VAR] = &&label_MOV_F32_S64_VAR;
		op_handlers[QB_MOV_F32_S64_ELV] = &&label_MOV_F32_S64_ELV;
		op_handlers[QB_MOV_F32_S64_ARR] = &&label_MOV_F32_S64_ARR;
		op_handlers[QB_MOV_F32_U64_VAR] = &&label_MOV_F32_U64_VAR;
		op_handlers[QB_MOV_F32_U64_ELV] = &&label_MOV_F32_U64_ELV;
		op_handlers[QB_MOV_F32_U64_ARR] = &&label_MOV_F32_U64_ARR;
		op_handlers[QB_MOV_F32_F64_VAR] = &&label_MOV_F32_F64_VAR;
		op_handlers[QB_MOV_F32_F64_ELV] = &&label_MOV_F32_F64_ELV;
		op_handlers[QB_MOV_F32_F64_ARR] = &&label_MOV_F32_F64_ARR;
		op_handlers[QB_BOOL_F32_I32_VAR] = &&label_BOOL_F32_I32_VAR;
		op_handlers[QB_BOOL_F32_I32_ELV] = &&label_BOOL_F32_I32_ELV;
		op_handlers[QB_BOOL_F32_I32_ARR] = &&label_BOOL_F32_I32_ARR;
		op_handlers[QB_ABS_F32_F32_VAR] = &&label_ABS_F32_F32_VAR;
		op_handlers[QB_ABS_F32_F32_ELV] = &&label_ABS_F32_F32_ELV;
		op_handlers[QB_ABS_F32_F32_ARR] = &&label_ABS_F32_F32_ARR;
		op_handlers[QB_MIN_F32_F32_F32_VAR] = &&label_MIN_F32_F32_F32_VAR;
		op_handlers[QB_MIN_F32_F32_F32_ELV] = &&label_MIN_F32_F32_F32_ELV;
		op_handlers[QB_MIN_F32_F32_F32_ARR] = &&label_MIN_F32_F32_F32_ARR;
		op_handlers[QB_MAX_F32_F32_F32_VAR] = &&label_MAX_F32_F32_F32_VAR;
		op_handlers[QB_MAX_F32_F32_F32_ELV] = &&label_MAX_F32_F32_F32_ELV;
		op_handlers[QB_MAX_F32_F32_F32_ARR] = &&label_MAX_F32_F32_F32_ARR;
		op_handlers[QB_SIN_F32_F32_VAR] = &&label_SIN_F32_F32_VAR;
		op_handlers[QB_SIN_F32_F32_ELV] = &&label_SIN_F32_F32_ELV;
		op_handlers[QB_SIN_F32_F32_ARR] = &&label_SIN_F32_F32_ARR;
		op_handlers[QB_ASIN_F32_F32_VAR] = &&label_ASIN_F32_F32_VAR;
		op_handlers[QB_ASIN_F32_F32_ELV] = &&label_ASIN_F32_F32_ELV;
		op_handlers[QB_ASIN_F32_F32_ARR] = &&label_ASIN_F32_F32_ARR;
		op_handlers[QB_COS_F32_F32_VAR] = &&label_COS_F32_F32_VAR;
		op_handlers[QB_COS_F32_F32_ELV] = &&label_COS_F32_F32_ELV;
		op_handlers[QB_COS_F32_F32_ARR] = &&label_COS_F32_F32_ARR;
		op_handlers[QB_ACOS_F32_F32_VAR] = &&label_ACOS_F32_F32_VAR;
		op_handlers[QB_ACOS_F32_F32_ELV] = &&label_ACOS_F32_F32_ELV;
		op_handlers[QB_ACOS_F32_F32_ARR] = &&label_ACOS_F32_F32_ARR;
		op_handlers[QB_TAN_F32_F32_VAR] = &&label_TAN_F32_F32_VAR;
		op_handlers[QB_TAN_F32_F32_ELV] = &&label_TAN_F32_F32_ELV;
		op_handlers[QB_TAN_F32_F32_ARR] = &&label_TAN_F32_F32_ARR;
		op_handlers[QB_ATAN_F32_F32_VAR] = &&label_ATAN_F32_F32_VAR;
		op_handlers[QB_ATAN_F32_F32_ELV] = &&label_ATAN_F32_F32_ELV;
		op_handlers[QB_ATAN_F32_F32_ARR] = &&label_ATAN_F32_F32_ARR;
		op_handlers[QB_ATAN2_F32_F32_F32_VAR] = &&label_ATAN2_F32_F32_F32_VAR;
		op_handlers[QB_ATAN2_F32_F32_F32_ELV] = &&label_ATAN2_F32_F32_F32_ELV;
		op_handlers[QB_ATAN2_F32_F32_F32_ARR] = &&label_ATAN2_F32_F32_F32_ARR;
		op_handlers[QB_SINH_F32_F32_VAR] = &&label_SINH_F32_F32_VAR;
		op_handlers[QB_SINH_F32_F32_ELV] = &&label_SINH_F32_F32_ELV;
		op_handlers[QB_SINH_F32_F32_ARR] = &&label_SINH_F32_F32_ARR;
		op_handlers[QB_ASINH_F32_F32_VAR] = &&label_ASINH_F32_F32_VAR;
		op_handlers[QB_ASINH_F32_F32_ELV] = &&label_ASINH_F32_F32_ELV;
		op_handlers[QB_ASINH_F32_F32_ARR] = &&label_ASINH_F32_F32_ARR;
		op_handlers[QB_COSH_F32_F32_VAR] = &&label_COSH_F32_F32_VAR;
		op_handlers[QB_COSH_F32_F32_ELV] = &&label_COSH_F32_F32_ELV;
		op_handlers[QB_COSH_F32_F32_ARR] = &&label_COSH_F32_F32_ARR;
		op_handlers[QB_ACOSH_F32_F32_VAR] = &&label_ACOSH_F32_F32_VAR;
		op_handlers[QB_ACOSH_F32_F32_ELV] = &&label_ACOSH_F32_F32_ELV;
		op_handlers[QB_ACOSH_F32_F32_ARR] = &&label_ACOSH_F32_F32_ARR;
		op_handlers[QB_TANH_F32_F32_VAR] = &&label_TANH_F32_F32_VAR;
		op_handlers[QB_TANH_F32_F32_ELV] = &&label_TANH_F32_F32_ELV;
		op_handlers[QB_TANH_F32_F32_ARR] = &&label_TANH_F32_F32_ARR;
		op_handlers[QB_ATANH_F32_F32_VAR] = &&label_ATANH_F32_F32_VAR;
		op_handlers[QB_ATANH_F32_F32_ELV] = &&label_ATANH_F32_F32_ELV;
		op_handlers[QB_ATANH_F32_F32_ARR] = &&label_ATANH_F32_F32_ARR;
		op_handlers[QB_CEIL_F32_F32_VAR] = &&label_CEIL_F32_F32_VAR;
		op_handlers[QB_CEIL_F32_F32_ELV] = &&label_CEIL_F32_F32_ELV;
		op_handlers[QB_CEIL_F32_F32_ARR] = &&label_CEIL_F32_F32_ARR;
		op_handlers[QB_FLOOR_F32_F32_VAR] = &&label_FLOOR_F32_F32_VAR;
		op_handlers[QB_FLOOR_F32_F32_ELV] = &&label_FLOOR_F32_F32_ELV;
		op_handlers[QB_FLOOR_F32_F32_ARR] = &&label_FLOOR_F32_F32_ARR;
		op_handlers[QB_ROUND_F32_I32_I32_F32_VAR] = &&label_ROUND_F32_I32_I32_F32_VAR;
		op_handlers[QB_ROUND_F32_I32_I32_F32_ELV] = &&label_ROUND_F32_I32_I32_F32_ELV;
		op_handlers[QB_ROUND_F32_I32_I32_F32_ARR] = &&label_ROUND_F32_I32_I32_F32_ARR;
		op_handlers[QB_LOG_F32_F32_VAR] = &&label_LOG_F32_F32_VAR;
		op_handlers[QB_LOG_F32_F32_ELV] = &&label_LOG_F32_F32_ELV;
		op_handlers[QB_LOG_F32_F32_ARR] = &&label_LOG_F32_F32_ARR;
		op_handlers[QB_LOG1P_F32_F32_VAR] = &&label_LOG1P_F32_F32_VAR;
		op_handlers[QB_LOG1P_F32_F32_ELV] = &&label_LOG1P_F32_F32_ELV;
		op_handlers[QB_LOG1P_F32_F32_ARR] = &&label_LOG1P_F32_F32_ARR;
		op_handlers[QB_LOG2_F32_F32_VAR] = &&label_LOG2_F32_F32_VAR;
		op_handlers[QB_LOG2_F32_F32_ELV] = &&label_LOG2_F32_F32_ELV;
		op_handlers[QB_LOG2_F32_F32_ARR] = &&label_LOG2_F32_F32_ARR;
		op_handlers[QB_LOG10_F32_F32_VAR] = &&label_LOG10_F32_F32_VAR;
		op_handlers[QB_LOG10_F32_F32_ELV] = &&label_LOG10_F32_F32_ELV;
		op_handlers[QB_LOG10_F32_F32_ARR] = &&label_LOG10_F32_F32_ARR;
		op_handlers[QB_EXP_F32_F32_VAR] = &&label_EXP_F32_F32_VAR;
		op_handlers[QB_EXP_F32_F32_ELV] = &&label_EXP_F32_F32_ELV;
		op_handlers[QB_EXP_F32_F32_ARR] = &&label_EXP_F32_F32_ARR;
		op_handlers[QB_EXPM1_F32_F32_VAR] = &&label_EXPM1_F32_F32_VAR;
		op_handlers[QB_EXPM1_F32_F32_ELV] = &&label_EXPM1_F32_F32_ELV;
		op_handlers[QB_EXPM1_F32_F32_ARR] = &&label_EXPM1_F32_F32_ARR;
		op_handlers[QB_EXP2_F32_F32_VAR] = &&label_EXP2_F32_F32_VAR;
		op_handlers[QB_EXP2_F32_F32_ELV] = &&label_EXP2_F32_F32_ELV;
		op_handlers[QB_EXP2_F32_F32_ARR] = &&label_EXP2_F32_F32_ARR;
		op_handlers[QB_POW_F32_F32_F32_VAR] = &&label_POW_F32_F32_F32_VAR;
		op_handlers[QB_POW_F32_F32_F32_ELV] = &&label_POW_F32_F32_F32_ELV;
		op_handlers[QB_POW_F32_F32_F32_ARR] = &&label_POW_F32_F32_F32_ARR;
		op_handlers[QB_SQRT_F32_F32_VAR] = &&label_SQRT_F32_F32_VAR;
		op_handlers[QB_SQRT_F32_F32_ELV] = &&label_SQRT_F32_F32_ELV;
		op_handlers[QB_SQRT_F32_F32_ARR] = &&label_SQRT_F32_F32_ARR;
		op_handlers[QB_HYPOT_F32_F32_F32_VAR] = &&label_HYPOT_F32_F32_F32_VAR;
		op_handlers[QB_HYPOT_F32_F32_F32_ELV] = &&label_HYPOT_F32_F32_F32_ELV;
		op_handlers[QB_HYPOT_F32_F32_F32_ARR] = &&label_HYPOT_F32_F32_F32_ARR;
		op_handlers[QB_LCG_F32_VAR] = &&label_LCG_F32_VAR;
		op_handlers[QB_LCG_F32_ELV] = &&label_LCG_F32_ELV;
		op_handlers[QB_LCG_F32_ARR] = &&label_LCG_F32_ARR;
		op_handlers[QB_FIN_F32_I32_VAR] = &&label_FIN_F32_I32_VAR;
		op_handlers[QB_FIN_F32_I32_ELV] = &&label_FIN_F32_I32_ELV;
		op_handlers[QB_FIN_F32_I32_ARR] = &&label_FIN_F32_I32_ARR;
		op_handlers[QB_INF_F32_I32_VAR] = &&label_INF_F32_I32_VAR;
		op_handlers[QB_INF_F32_I32_ELV] = &&label_INF_F32_I32_ELV;
		op_handlers[QB_INF_F32_I32_ARR] = &&label_INF_F32_I32_ARR;
		op_handlers[QB_NAN_F32_I32_VAR] = &&label_NAN_F32_I32_VAR;
		op_handlers[QB_NAN_F32_I32_ELV] = &&label_NAN_F32_I32_ELV;
		op_handlers[QB_NAN_F32_I32_ARR] = &&label_NAN_F32_I32_ARR;
		op_handlers[QB_RSQRT_F32_F32_VAR] = &&label_RSQRT_F32_F32_VAR;
		op_handlers[QB_RSQRT_F32_F32_ELV] = &&label_RSQRT_F32_F32_ELV;
		op_handlers[QB_RSQRT_F32_F32_ARR] = &&label_RSQRT_F32_F32_ARR;
		op_handlers[QB_CLAMP_F32_F32_F32_F32_VAR] = &&label_CLAMP_F32_F32_F32_F32_VAR;
		op_handlers[QB_CLAMP_F32_F32_F32_F32_ELV] = &&label_CLAMP_F32_F32_F32_F32_ELV;
		op_handlers[QB_CLAMP_F32_F32_F32_F32_ARR] = &&label_CLAMP_F32_F32_F32_F32_ARR;
		op_handlers[QB_FRACT_F32_F32_VAR] = &&label_FRACT_F32_F32_VAR;
		op_handlers[QB_FRACT_F32_F32_ELV] = &&label_FRACT_F32_F32_ELV;
		op_handlers[QB_FRACT_F32_F32_ARR] = &&label_FRACT_F32_F32_ARR;
		op_handlers[QB_MIX_F32_F32_F32_F32_VAR] = &&label_MIX_F32_F32_F32_F32_VAR;
		op_handlers[QB_MIX_F32_F32_F32_F32_ELV] = &&label_MIX_F32_F32_F32_F32_ELV;
		op_handlers[QB_MIX_F32_F32_F32_F32_ARR] = &&label_MIX_F32_F32_F32_F32_ARR;
		op_handlers[QB_SIGN_F32_F32_VAR] = &&label_SIGN_F32_F32_VAR;
		op_handlers[QB_SIGN_F32_F32_ELV] = &&label_SIGN_F32_F32_ELV;
		op_handlers[QB_SIGN_F32_F32_ARR] = &&label_SIGN_F32_F32_ARR;
		op_handlers[QB_STEP_F32_F32_F32_VAR] = &&label_STEP_F32_F32_F32_VAR;
		op_handlers[QB_STEP_F32_F32_F32_ELV] = &&label_STEP_F32_F32_F32_ELV;
		op_handlers[QB_STEP_F32_F32_F32_ARR] = &&label_STEP_F32_F32_F32_ARR;
		op_handlers[QB_SSTEP_F32_F32_F32_F32_VAR] = &&label_SSTEP_F32_F32_F32_F32_VAR;
		op_handlers[QB_SSTEP_F32_F32_F32_F32_ELV] = &&label_SSTEP_F32_F32_F32_F32_ELV;
		op_handlers[QB_SSTEP_F32_F32_F32_F32_ARR] = &&label_SSTEP_F32_F32_F32_F32_ARR;
		op_handlers[QB_RAD2DEG_F32_F32_VAR] = &&label_RAD2DEG_F32_F32_VAR;
		op_handlers[QB_RAD2DEG_F32_F32_ELV] = &&label_RAD2DEG_F32_F32_ELV;
		op_handlers[QB_RAD2DEG_F32_F32_ARR] = &&label_RAD2DEG_F32_F32_ARR;
		op_handlers[QB_DEG2RAD_F32_F32_VAR] = &&label_DEG2RAD_F32_F32_VAR;
		op_handlers[QB_DEG2RAD_F32_F32_ELV] = &&label_DEG2RAD_F32_F32_ELV;
		op_handlers[QB_DEG2RAD_F32_F32_ARR] = &&label_DEG2RAD_F32_F32_ARR;
		op_handlers[QB_PRN_F32_VAR] = &&label_PRN_F32_VAR;
		op_handlers[QB_PRN_F32_ELV] = &&label_PRN_F32_ELV;
		op_handlers[QB_PRN_F32_ARR] = &&label_PRN_F32_ARR;
		op_handlers[QB_PRN_DIM_F32_U32] = &&label_PRN_DIM_F32_U32;
		op_handlers[QB_CAT_F32_U08_VAR] = &&label_CAT_F32_U08_VAR;
		op_handlers[QB_CAT_F32_U08_ELV] = &&label_CAT_F32_U08_ELV;
		op_handlers[QB_CAT_F32_U08_ARR] = &&label_CAT_F32_U08_ARR;
		op_handlers[QB_CAT_DIM_F32_U32_U08] = &&label_CAT_DIM_F32_U32_U08;
		op_handlers[QB_PACK_LE_F32_U08_VAR] = &&label_PACK_LE_F32_U08_VAR;
		op_handlers[QB_PACK_LE_F32_U08_ELV] = &&label_PACK_LE_F32_U08_ELV;
		op_handlers[QB_PACK_BE_F32_U08_VAR] = &&label_PACK_BE_F32_U08_VAR;
		op_handlers[QB_PACK_BE_F32_U08_ELV] = &&label_PACK_BE_F32_U08_ELV;
		op_handlers[QB_UNPACK_LE_U08_F32_VAR] = &&label_UNPACK_LE_U08_F32_VAR;
		op_handlers[QB_UNPACK_LE_U08_F32_ELV] = &&label_UNPACK_LE_U08_F32_ELV;
		op_handlers[QB_UNPACK_BE_U08_F32_VAR] = &&label_UNPACK_BE_U08_F32_VAR;
		op_handlers[QB_UNPACK_BE_U08_F32_ELV] = &&label_UNPACK_BE_U08_F32_ELV;
		op_handlers[QB_SORT_F32] = &&label_SORT_F32;
		op_handlers[QB_RSORT_F32] = &&label_RSORT_F32;
		op_handlers[QB_AMIN_F32_F32_VAR] = &&label_AMIN_F32_F32_VAR;
		op_handlers[QB_AMAX_F32_F32_VAR] = &&label_AMAX_F32_F32_VAR;
		op_handlers[QB_APROD_F32_F32_VAR] = &&label_APROD_F32_F32_VAR;
		op_handlers[QB_ASUM_F32_F32_VAR] = &&label_ASUM_F32_F32_VAR;
		op_handlers[QB_RANGE_F32_F32_F32_F32_VAR] = &&label_RANGE_F32_F32_F32_F32_VAR;
		op_handlers[QB_AMIN_F32_F32_ELV] = &&label_AMIN_F32_F32_ELV;
		op_handlers[QB_AMAX_F32_F32_ELV] = &&label_AMAX_F32_F32_ELV;
		op_handlers[QB_APROD_F32_F32_ELV] = &&label_APROD_F32_F32_ELV;
		op_handlers[QB_ASUM_F32_F32_ELV] = &&label_ASUM_F32_F32_ELV;
		op_handlers[QB_RANGE_F32_F32_F32_F32_ELV] = &&label_RANGE_F32_F32_F32_F32_ELV;
		op_handlers[QB_AFIND_IDX_F32_F32_I32_VAR] = &&label_AFIND_IDX_F32_F32_I32_VAR;
		op_handlers[QB_AFIND_IDX_F32_F32_I32_ELV] = &&label_AFIND_IDX_F32_F32_I32_ELV;
		op_handlers[QB_AFIND_IDX_F32_F32_I32_ARR] = &&label_AFIND_IDX_F32_F32_I32_ARR;
		op_handlers[QB_AFIND_F32_F32_I32_VAR] = &&label_AFIND_F32_F32_I32_VAR;
		op_handlers[QB_AFIND_F32_F32_I32_ELV] = &&label_AFIND_F32_F32_I32_ELV;
		op_handlers[QB_AFIND_F32_F32_I32_ARR] = &&label_AFIND_F32_F32_I32_ARR;
		op_handlers[QB_APOS_F32_F32_I32_I32] = &&label_APOS_F32_F32_I32_I32;
		op_handlers[QB_ARPOS_F32_F32_I32_I32] = &&label_ARPOS_F32_F32_I32_I32;
		op_handlers[QB_AREV_F32_U32_F32] = &&label_AREV_F32_U32_F32;
		op_handlers[QB_AINS_F32_U32_F32] = &&label_AINS_F32_U32_F32;
		op_handlers[QB_AUNIQ_F32_U32_F32] = &&label_AUNIQ_F32_U32_F32;
		op_handlers[QB_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_VAR] = &&label_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_VAR;
		op_handlers[QB_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_ELV] = &&label_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_ELV;
		op_handlers[QB_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_ARR] = &&label_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_ARR;
		op_handlers[QB_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_VAR] = &&label_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_VAR;
		op_handlers[QB_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_ELV] = &&label_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_ELV;
		op_handlers[QB_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_ARR] = &&label_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_ARR;
		op_handlers[QB_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_VAR] = &&label_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_VAR;
		op_handlers[QB_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_ELV] = &&label_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_ELV;
		op_handlers[QB_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_ARR] = &&label_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_ARR;
		op_handlers[QB_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_VAR] = &&label_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_VAR;
		op_handlers[QB_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_ELV] = &&label_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_ELV;
		op_handlers[QB_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_ARR] = &&label_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_ARR;
		op_handlers[QB_BLEND_F32_F32_F32] = &&label_BLEND_F32_F32_F32;
		op_handlers[QB_PREMULT_F32_F32] = &&label_PREMULT_F32_F32;
		op_handlers[QB_UNPREMULT_F32_F32] = &&label_UNPREMULT_F32_F32;
		op_handlers[QB_MUL_MM_4X_F32_F32_F32] = &&label_MUL_MM_4X_F32_F32_F32;
		op_handlers[QB_MUL_MM_4X_F32_F32_F32_ARR] = &&label_MUL_MM_4X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_MV_4X_F32_F32_F32] = &&label_MUL_MV_4X_F32_F32_F32;
		op_handlers[QB_MUL_MV_4X_F32_F32_F32_ARR] = &&label_MUL_MV_4X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_VM_4X_F32_F32_F32] = &&label_MUL_VM_4X_F32_F32_F32;
		op_handlers[QB_MUL_VM_4X_F32_F32_F32_ARR] = &&label_MUL_VM_4X_F32_F32_F32_ARR;
		op_handlers[QB_MTRAN_4X_F32_F32] = &&label_MTRAN_4X_F32_F32;
		op_handlers[QB_MTRAN_4X_F32_F32_ARR] = &&label_MTRAN_4X_F32_F32_ARR;
		op_handlers[QB_MDET_4X_F32_F32_VAR] = &&label_MDET_4X_F32_F32_VAR;
		op_handlers[QB_MDET_4X_F32_F32_ELV] = &&label_MDET_4X_F32_F32_ELV;
		op_handlers[QB_MDET_4X_F32_F32_ARR] = &&label_MDET_4X_F32_F32_ARR;
		op_handlers[QB_MINV_4X_F32_F32] = &&label_MINV_4X_F32_F32;
		op_handlers[QB_MINV_4X_F32_F32_ARR] = &&label_MINV_4X_F32_F32_ARR;
		op_handlers[QB_DOT_4X_F32_F32_F32_VAR] = &&label_DOT_4X_F32_F32_F32_VAR;
		op_handlers[QB_DOT_4X_F32_F32_F32_ELV] = &&label_DOT_4X_F32_F32_F32_ELV;
		op_handlers[QB_DOT_4X_F32_F32_F32_ARR] = &&label_DOT_4X_F32_F32_F32_ARR;
		op_handlers[QB_LEN_4X_F32_F32_VAR] = &&label_LEN_4X_F32_F32_VAR;
		op_handlers[QB_LEN_4X_F32_F32_ELV] = &&label_LEN_4X_F32_F32_ELV;
		op_handlers[QB_LEN_4X_F32_F32_ARR] = &&label_LEN_4X_F32_F32_ARR;
		op_handlers[QB_DIS_4X_F32_F32_F32_VAR] = &&label_DIS_4X_F32_F32_F32_VAR;
		op_handlers[QB_DIS_4X_F32_F32_F32_ELV] = &&label_DIS_4X_F32_F32_F32_ELV;
		op_handlers[QB_DIS_4X_F32_F32_F32_ARR] = &&label_DIS_4X_F32_F32_F32_ARR;
		op_handlers[QB_NORM_4X_F32_F32] = &&label_NORM_4X_F32_F32;
		op_handlers[QB_NORM_4X_F32_F32_ARR] = &&label_NORM_4X_F32_F32_ARR;
		op_handlers[QB_CROSS_4X_F32_F32_F32_F32] = &&label_CROSS_4X_F32_F32_F32_F32;
		op_handlers[QB_CROSS_4X_F32_F32_F32_F32_ARR] = &&label_CROSS_4X_F32_F32_F32_F32_ARR;
		op_handlers[QB_FORE_4X_F32_F32_F32] = &&label_FORE_4X_F32_F32_F32;
		op_handlers[QB_FORE_4X_F32_F32_F32_ARR] = &&label_FORE_4X_F32_F32_F32_ARR;
		op_handlers[QB_REFL_4X_F32_F32_F32] = &&label_REFL_4X_F32_F32_F32;
		op_handlers[QB_REFL_4X_F32_F32_F32_ARR] = &&label_REFL_4X_F32_F32_F32_ARR;
		op_handlers[QB_REFR_4X_F32_F32_F32_F32] = &&label_REFR_4X_F32_F32_F32_F32;
		op_handlers[QB_REFR_4X_F32_F32_F32_F32_ARR] = &&label_REFR_4X_F32_F32_F32_F32_ARR;
		op_handlers[QB_TRAN_4X_F32_F32_F32] = &&label_TRAN_4X_F32_F32_F32;
		op_handlers[QB_TRAN_4X_F32_F32_F32_ARR] = &&label_TRAN_4X_F32_F32_F32_ARR;
		op_handlers[QB_TRAN_RM_4X_F32_F32_F32] = &&label_TRAN_RM_4X_F32_F32_F32;
		op_handlers[QB_TRAN_RM_4X_F32_F32_F32_ARR] = &&label_TRAN_RM_4X_F32_F32_F32_ARR;
		op_handlers[QB_MOV_4X_F32_F32] = &&label_MOV_4X_F32_F32;
		op_handlers[QB_MOV_4X_F32_F32_ARR] = &&label_MOV_4X_F32_F32_ARR;
		op_handlers[QB_ADD_4X_F32_F32_F32] = &&label_ADD_4X_F32_F32_F32;
		op_handlers[QB_ADD_4X_F32_F32_F32_ARR] = &&label_ADD_4X_F32_F32_F32_ARR;
		op_handlers[QB_SUB_4X_F32_F32_F32] = &&label_SUB_4X_F32_F32_F32;
		op_handlers[QB_SUB_4X_F32_F32_F32_ARR] = &&label_SUB_4X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_4X_F32_F32_F32] = &&label_MUL_4X_F32_F32_F32;
		op_handlers[QB_MUL_4X_F32_F32_F32_ARR] = &&label_MUL_4X_F32_F32_F32_ARR;
		op_handlers[QB_DIV_4X_F32_F32_F32] = &&label_DIV_4X_F32_F32_F32;
		op_handlers[QB_DIV_4X_F32_F32_F32_ARR] = &&label_DIV_4X_F32_F32_F32_ARR;
		op_handlers[QB_MOD_4X_F32_F32_F32] = &&label_MOD_4X_F32_F32_F32;
		op_handlers[QB_MOD_4X_F32_F32_F32_ARR] = &&label_MOD_4X_F32_F32_F32_ARR;
		op_handlers[QB_NEG_4X_F32_F32] = &&label_NEG_4X_F32_F32;
		op_handlers[QB_NEG_4X_F32_F32_ARR] = &&label_NEG_4X_F32_F32_ARR;
		op_handlers[QB_INC_4X_F32] = &&label_INC_4X_F32;
		op_handlers[QB_INC_4X_F32_ARR] = &&label_INC_4X_F32_ARR;
		op_handlers[QB_DEC_4X_F32] = &&label_DEC_4X_F32;
		op_handlers[QB_DEC_4X_F32_ARR] = &&label_DEC_4X_F32_ARR;
		op_handlers[QB_MAC_4X_F32_F32_F32_F32] = &&label_MAC_4X_F32_F32_F32_F32;
		op_handlers[QB_MAC_4X_F32_F32_F32_F32_ARR] = &&label_MAC_4X_F32_F32_F32_F32_ARR;
		op_handlers[QB_MUL_MM_3X_F32_F32_F32] = &&label_MUL_MM_3X_F32_F32_F32;
		op_handlers[QB_MUL_MM_3X_F32_F32_F32_ARR] = &&label_MUL_MM_3X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_MV_3X_F32_F32_F32] = &&label_MUL_MV_3X_F32_F32_F32;
		op_handlers[QB_MUL_MV_3X_F32_F32_F32_ARR] = &&label_MUL_MV_3X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_VM_3X_F32_F32_F32] = &&label_MUL_VM_3X_F32_F32_F32;
		op_handlers[QB_MUL_VM_3X_F32_F32_F32_ARR] = &&label_MUL_VM_3X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_MM_3XP_F32_F32_F32] = &&label_MUL_MM_3XP_F32_F32_F32;
		op_handlers[QB_MUL_MV_3XP_F32_F32_F32] = &&label_MUL_MV_3XP_F32_F32_F32;
		op_handlers[QB_MUL_VM_3XP_F32_F32_F32] = &&label_MUL_VM_3XP_F32_F32_F32;
		op_handlers[QB_MTRAN_3X_F32_F32] = &&label_MTRAN_3X_F32_F32;
		op_handlers[QB_MTRAN_3X_F32_F32_ARR] = &&label_MTRAN_3X_F32_F32_ARR;
		op_handlers[QB_MINV_3X_F32_F32] = &&label_MINV_3X_F32_F32;
		op_handlers[QB_MINV_3X_F32_F32_ARR] = &&label_MINV_3X_F32_F32_ARR;
		op_handlers[QB_MDET_3X_F32_F32_VAR] = &&label_MDET_3X_F32_F32_VAR;
		op_handlers[QB_MDET_3X_F32_F32_ELV] = &&label_MDET_3X_F32_F32_ELV;
		op_handlers[QB_MDET_3X_F32_F32_ARR] = &&label_MDET_3X_F32_F32_ARR;
		op_handlers[QB_DOT_3X_F32_F32_F32_VAR] = &&label_DOT_3X_F32_F32_F32_VAR;
		op_handlers[QB_DOT_3X_F32_F32_F32_ELV] = &&label_DOT_3X_F32_F32_F32_ELV;
		op_handlers[QB_DOT_3X_F32_F32_F32_ARR] = &&label_DOT_3X_F32_F32_F32_ARR;
		op_handlers[QB_LEN_3X_F32_F32_VAR] = &&label_LEN_3X_F32_F32_VAR;
		op_handlers[QB_LEN_3X_F32_F32_ELV] = &&label_LEN_3X_F32_F32_ELV;
		op_handlers[QB_LEN_3X_F32_F32_ARR] = &&label_LEN_3X_F32_F32_ARR;
		op_handlers[QB_DIS_3X_F32_F32_F32_VAR] = &&label_DIS_3X_F32_F32_F32_VAR;
		op_handlers[QB_DIS_3X_F32_F32_F32_ELV] = &&label_DIS_3X_F32_F32_F32_ELV;
		op_handlers[QB_DIS_3X_F32_F32_F32_ARR] = &&label_DIS_3X_F32_F32_F32_ARR;
		op_handlers[QB_NORM_3X_F32_F32] = &&label_NORM_3X_F32_F32;
		op_handlers[QB_NORM_3X_F32_F32_ARR] = &&label_NORM_3X_F32_F32_ARR;
		op_handlers[QB_CROSS_3X_F32_F32_F32] = &&label_CROSS_3X_F32_F32_F32;
		op_handlers[QB_CROSS_3X_F32_F32_F32_ARR] = &&label_CROSS_3X_F32_F32_F32_ARR;
		op_handlers[QB_FORE_3X_F32_F32_F32] = &&label_FORE_3X_F32_F32_F32;
		op_handlers[QB_FORE_3X_F32_F32_F32_ARR] = &&label_FORE_3X_F32_F32_F32_ARR;
		op_handlers[QB_REFL_3X_F32_F32_F32] = &&label_REFL_3X_F32_F32_F32;
		op_handlers[QB_REFL_3X_F32_F32_F32_ARR] = &&label_REFL_3X_F32_F32_F32_ARR;
		op_handlers[QB_REFR_3X_F32_F32_F32_F32] = &&label_REFR_3X_F32_F32_F32_F32;
		op_handlers[QB_REFR_3X_F32_F32_F32_F32_ARR] = &&label_REFR_3X_F32_F32_F32_F32_ARR;
		op_handlers[QB_TRAN_3X_F32_F32_F32] = &&label_TRAN_3X_F32_F32_F32;
		op_handlers[QB_TRAN_3X_F32_F32_F32_ARR] = &&label_TRAN_3X_F32_F32_F32_ARR;
		op_handlers[QB_TRAN_RM_3X_F32_F32_F32] = &&label_TRAN_RM_3X_F32_F32_F32;
		op_handlers[QB_TRAN_RM_3X_F32_F32_F32_ARR] = &&label_TRAN_RM_3X_F32_F32_F32_ARR;
		op_handlers[QB_MOV_3X_F32_F32] = &&label_MOV_3X_F32_F32;
		op_handlers[QB_MOV_3X_F32_F32_ARR] = &&label_MOV_3X_F32_F32_ARR;
		op_handlers[QB_ADD_3X_F32_F32_F32] = &&label_ADD_3X_F32_F32_F32;
		op_handlers[QB_ADD_3X_F32_F32_F32_ARR] = &&label_ADD_3X_F32_F32_F32_ARR;
		op_handlers[QB_SUB_3X_F32_F32_F32] = &&label_SUB_3X_F32_F32_F32;
		op_handlers[QB_SUB_3X_F32_F32_F32_ARR] = &&label_SUB_3X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_3X_F32_F32_F32] = &&label_MUL_3X_F32_F32_F32;
		op_handlers[QB_MUL_3X_F32_F32_F32_ARR] = &&label_MUL_3X_F32_F32_F32_ARR;
		op_handlers[QB_DIV_3X_F32_F32_F32] = &&label_DIV_3X_F32_F32_F32;
		op_handlers[QB_DIV_3X_F32_F32_F32_ARR] = &&label_DIV_3X_F32_F32_F32_ARR;
		op_handlers[QB_MOD_3X_F32_F32_F32] = &&label_MOD_3X_F32_F32_F32;
		op_handlers[QB_MOD_3X_F32_F32_F32_ARR] = &&label_MOD_3X_F32_F32_F32_ARR;
		op_handlers[QB_NEG_3X_F32_F32] = &&label_NEG_3X_F32_F32;
		op_handlers[QB_NEG_3X_F32_F32_ARR] = &&label_NEG_3X_F32_F32_ARR;
		op_handlers[QB_INC_3X_F32] = &&label_INC_3X_F32;
		op_handlers[QB_INC_3X_F32_ARR] = &&label_INC_3X_F32_ARR;
		op_handlers[QB_DEC_3X_F32] = &&label_DEC_3X_F32;
		op_handlers[QB_DEC_3X_F32_ARR] = &&label_DEC_3X_F32_ARR;
		op_handlers[QB_MAC_3X_F32_F32_F32_F32] = &&label_MAC_3X_F32_F32_F32_F32;
		op_handlers[QB_MAC_3X_F32_F32_F32_F32_ARR] = &&label_MAC_3X_F32_F32_F32_F32_ARR;
		op_handlers[QB_MUL_MM_2X_F32_F32_F32] = &&label_MUL_MM_2X_F32_F32_F32;
		op_handlers[QB_MUL_MM_2X_F32_F32_F32_ARR] = &&label_MUL_MM_2X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_MV_2X_F32_F32_F32] = &&label_MUL_MV_2X_F32_F32_F32;
		op_handlers[QB_MUL_MV_2X_F32_F32_F32_ARR] = &&label_MUL_MV_2X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_VM_2X_F32_F32_F32] = &&label_MUL_VM_2X_F32_F32_F32;
		op_handlers[QB_MUL_VM_2X_F32_F32_F32_ARR] = &&label_MUL_VM_2X_F32_F32_F32_ARR;
		op_handlers[QB_MTRAN_2X_F32_F32] = &&label_MTRAN_2X_F32_F32;
		op_handlers[QB_MTRAN_2X_F32_F32_ARR] = &&label_MTRAN_2X_F32_F32_ARR;
		op_handlers[QB_MINV_2X_F32_F32] = &&label_MINV_2X_F32_F32;
		op_handlers[QB_MINV_2X_F32_F32_ARR] = &&label_MINV_2X_F32_F32_ARR;
		op_handlers[QB_MDET_2X_F32_F32_VAR] = &&label_MDET_2X_F32_F32_VAR;
		op_handlers[QB_MDET_2X_F32_F32_ELV] = &&label_MDET_2X_F32_F32_ELV;
		op_handlers[QB_MDET_2X_F32_F32_ARR] = &&label_MDET_2X_F32_F32_ARR;
		op_handlers[QB_DOT_2X_F32_F32_F32_VAR] = &&label_DOT_2X_F32_F32_F32_VAR;
		op_handlers[QB_DOT_2X_F32_F32_F32_ELV] = &&label_DOT_2X_F32_F32_F32_ELV;
		op_handlers[QB_DOT_2X_F32_F32_F32_ARR] = &&label_DOT_2X_F32_F32_F32_ARR;
		op_handlers[QB_LEN_2X_F32_F32_VAR] = &&label_LEN_2X_F32_F32_VAR;
		op_handlers[QB_LEN_2X_F32_F32_ELV] = &&label_LEN_2X_F32_F32_ELV;
		op_handlers[QB_LEN_2X_F32_F32_ARR] = &&label_LEN_2X_F32_F32_ARR;
		op_handlers[QB_DIS_2X_F32_F32_F32_VAR] = &&label_DIS_2X_F32_F32_F32_VAR;
		op_handlers[QB_DIS_2X_F32_F32_F32_ELV] = &&label_DIS_2X_F32_F32_F32_ELV;
		op_handlers[QB_DIS_2X_F32_F32_F32_ARR] = &&label_DIS_2X_F32_F32_F32_ARR;
		op_handlers[QB_NORM_2X_F32_F32] = &&label_NORM_2X_F32_F32;
		op_handlers[QB_NORM_2X_F32_F32_ARR] = &&label_NORM_2X_F32_F32_ARR;
		op_handlers[QB_CROSS_2X_F32_F32_F32] = &&label_CROSS_2X_F32_F32_F32;
		op_handlers[QB_CROSS_2X_F32_F32_F32_ARR] = &&label_CROSS_2X_F32_F32_F32_ARR;
		op_handlers[QB_FORE_2X_F32_F32_F32] = &&label_FORE_2X_F32_F32_F32;
		op_handlers[QB_FORE_2X_F32_F32_F32_ARR] = &&label_FORE_2X_F32_F32_F32_ARR;
		op_handlers[QB_REFL_2X_F32_F32_F32] = &&label_REFL_2X_F32_F32_F32;
		op_handlers[QB_REFL_2X_F32_F32_F32_ARR] = &&label_REFL_2X_F32_F32_F32_ARR;
		op_handlers[QB_REFR_2X_F32_F32_F32_F32] = &&label_REFR_2X_F32_F32_F32_F32;
		op_handlers[QB_REFR_2X_F32_F32_F32_F32_ARR] = &&label_REFR_2X_F32_F32_F32_F32_ARR;
		op_handlers[QB_TRAN_2X_F32_F32_F32] = &&label_TRAN_2X_F32_F32_F32;
		op_handlers[QB_TRAN_2X_F32_F32_F32_ARR] = &&label_TRAN_2X_F32_F32_F32_ARR;
		op_handlers[QB_TRAN_RM_2X_F32_F32_F32] = &&label_TRAN_RM_2X_F32_F32_F32;
		op_handlers[QB_TRAN_RM_2X_F32_F32_F32_ARR] = &&label_TRAN_RM_2X_F32_F32_F32_ARR;
		op_handlers[QB_MOV_2X_F32_F32] = &&label_MOV_2X_F32_F32;
		op_handlers[QB_MOV_2X_F32_F32_ARR] = &&label_MOV_2X_F32_F32_ARR;
		op_handlers[QB_ADD_2X_F32_F32_F32] = &&label_ADD_2X_F32_F32_F32;
		op_handlers[QB_ADD_2X_F32_F32_F32_ARR] = &&label_ADD_2X_F32_F32_F32_ARR;
		op_handlers[QB_SUB_2X_F32_F32_F32] = &&label_SUB_2X_F32_F32_F32;
		op_handlers[QB_SUB_2X_F32_F32_F32_ARR] = &&label_SUB_2X_F32_F32_F32_ARR;
		op_handlers[QB_MUL_2X_F32_F32_F32] = &&label_MUL_2X_F32_F32_F32;
		op_handlers[QB_MUL_2X_F32_F32_F32_ARR] = &&label_MUL_2X_F32_F32_F32_ARR;
		op_handlers[QB_DIV_2X_F32_F32_F32] = &&label_DIV_2X_F32_F32_F32;
		op_handlers[QB_DIV_2X_F32_F32_F32_ARR] = &&label_DIV_2X_F32_F32_F32_ARR;
		op_handlers[QB_MOD_2X_F32_F32_F32] = &&label_MOD_2X_F32_F32_F32;
		op_handlers[QB_MOD_2X_F32_F32_F32_ARR] = &&label_MOD_2X_F32_F32_F32_ARR;
		op_handlers[QB_NEG_2X_F32_F32] = &&label_NEG_2X_F32_F32;
		op_handlers[QB_NEG_2X_F32_F32_ARR] = &&label_NEG_2X_F32_F32_ARR;
		op_handlers[QB_INC_2X_F32] = &&label_INC_2X_F32;
		op_handlers[QB_INC_2X_F32_ARR] = &&label_INC_2X_F32_ARR;
		op_handlers[QB_DEC_2X_F32] = &&label_DEC_2X_F32;
		op_handlers[QB_DEC_2X_F32_ARR] = &&label_DEC_2X_F32_ARR;
		op_handlers[QB_MAC_2X_F32_F32_F32_F32] = &&label_MAC_2X_F32_F32_F32_F32;
		op_handlers[QB_MAC_2X_F32_F32_F32_F32_ARR] = &&label_MAC_2X_F32_F32_F32_F32_ARR;
		op_handlers[QB_MUL_MM_F32_F32_F32] = &&label_MUL_MM_F32_F32_F32;
		op_handlers[QB_MUL_MM_F32_F32_F32_ARR] = &&label_MUL_MM_F32_F32_F32_ARR;
		op_handlers[QB_MUL_MV_F32_F32_F32] = &&label_MUL_MV_F32_F32_F32;
		op_handlers[QB_MUL_MV_F32_F32_F32_ARR] = &&label_MUL_MV_F32_F32_F32_ARR;
		op_handlers[QB_MUL_VM_F32_F32_F32] = &&label_MUL_VM_F32_F32_F32;
		op_handlers[QB_MUL_VM_F32_F32_F32_ARR] = &&label_MUL_VM_F32_F32_F32_ARR;
		op_handlers[QB_MTRAN_F32_F32] = &&label_MTRAN_F32_F32;
		op_handlers[QB_MTRAN_F32_F32_ARR] = &&label_MTRAN_F32_F32_ARR;
		op_handlers[QB_MINV_F32_F32] = &&label_MINV_F32_F32;
		op_handlers[QB_MINV_F32_F32_ARR] = &&label_MINV_F32_F32_ARR;
		op_handlers[QB_MDET_F32_F32_VAR] = &&label_MDET_F32_F32_VAR;
		op_handlers[QB_MDET_F32_F32_ELV] = &&label_MDET_F32_F32_ELV;
		op_handlers[QB_MDET_F32_F32_ARR] = &&label_MDET_F32_F32_ARR;
		op_handlers[QB_DOT_F32_F32_F32_VAR] = &&label_DOT_F32_F32_F32_VAR;
		op_handlers[QB_DOT_F32_F32_F32_ELV] = &&label_DOT_F32_F32_F32_ELV;
		op_handlers[QB_DOT_F32_F32_F32_ARR] = &&label_DOT_F32_F32_F32_ARR;
		op_handlers[QB_LEN_F32_F32_VAR] = &&label_LEN_F32_F32_VAR;
		op_handlers[QB_LEN_F32_F32_ELV] = &&label_LEN_F32_F32_ELV;
		op_handlers[QB_LEN_F32_F32_ARR] = &&label_LEN_F32_F32_ARR;
		op_handlers[QB_DIS_F32_F32_F32_VAR] = &&label_DIS_F32_F32_F32_VAR;
		op_handlers[QB_DIS_F32_F32_F32_ELV] = &&label_DIS_F32_F32_F32_ELV;
		op_handlers[QB_DIS_F32_F32_F32_ARR] = &&label_DIS_F32_F32_F32_ARR;
		op_handlers[QB_NORM_F32_F32] = &&label_NORM_F32_F32;
		op_handlers[QB_NORM_F32_F32_ARR] = &&label_NORM_F32_F32_ARR;
		op_handlers[QB_FORE_F32_F32_F32] = &&label_FORE_F32_F32_F32;
		op_handlers[QB_FORE_F32_F32_F32_ARR] = &&label_FORE_F32_F32_F32_ARR;
		op_handlers[QB_REFL_F32_F32_F32] = &&label_REFL_F32_F32_F32;
		op_handlers[QB_REFL_F32_F32_F32_ARR] = &&label_REFL_F32_F32_F32_ARR;
		op_handlers[QB_REFR_F32_F32_F32_F32] = &&label_REFR_F32_F32_F32_F32;
		op_handlers[QB_REFR_F32_F32_F32_F32_ARR] = &&label_REFR_F32_F32_F32_F32_ARR;
		op_handlers[QB_CABS_F32_F32] = &&label_CABS_F32_F32;
		op_handlers[QB_CABS_F32_F32_ARR] = &&label_CABS_F32_F32_ARR;
		op_handlers[QB_CARG_F32_F32] = &&label_CARG_F32_F32;
		op_handlers[QB_CARG_F32_F32_ARR] = &&label_CARG_F32_F32_ARR;
		op_handlers[QB_CMUL_F32_F32_F32] = &&label_CMUL_F32_F32_F32;
		op_handlers[QB_CMUL_F32_F32_F32_ARR] = &&label_CMUL_F32_F32_F32_ARR;
		op_handlers[QB_CDIV_F32_F32_F32] = &&label_CDIV_F32_F32_F32;
		op_handlers[QB_CDIV_F32_F32_F32_ARR] = &&label_CDIV_F32_F32_F32_ARR;
		op_handlers[QB_CEXP_F32_F32] = &&label_CEXP_F32_F32;
		op_handlers[QB_CEXP_F32_F32_ARR] = &&label_CEXP_F32_F32_ARR;
		op_handlers[QB_CLOG_F32_F32] = &&label_CLOG_F32_F32;
		op_handlers[QB_CLOG_F32_F32_ARR] = &&label_CLOG_F32_F32_ARR;
		op_handlers[QB_CSQRT_F32_F32] = &&label_CSQRT_F32_F32;
		op_handlers[QB_CSQRT_F32_F32_ARR] = &&label_CSQRT_F32_F32_ARR;
		op_handlers[QB_CPOW_F32_F32_F32] = &&label_CPOW_F32_F32_F32;
		op_handlers[QB_CPOW_F32_F32_F32_ARR] = &&label_CPOW_F32_F32_F32_ARR;
		op_handlers[QB_CSIN_F32_F32] = &&label_CSIN_F32_F32;
		op_handlers[QB_CSIN_F32_F32_ARR] = &&label_CSIN_F32_F32_ARR;
		op_handlers[QB_CCOS_F32_F32] = &&label_CCOS_F32_F32;
		op_handlers[QB_CCOS_F32_F32_ARR] = &&label_CCOS_F32_F32_ARR;
		op_handlers[QB_CTAN_F32_F32] = &&label_CTAN_F32_F32;
		op_handlers[QB_CTAN_F32_F32_ARR] = &&label_CTAN_F32_F32_ARR;
		op_handlers[QB_CSINH_F32_F32] = &&label_CSINH_F32_F32;
		op_handlers[QB_CSINH_F32_F32_ARR] = &&label_CSINH_F32_F32_ARR;
		op_handlers[QB_CCOSH_F32_F32] = &&label_CCOSH_F32_F32;
		op_handlers[QB_CCOSH_F32_F32_ARR] = &&label_CCOSH_F32_F32_ARR;
		op_handlers[QB_CTANH_F32_F32] = &&label_CTANH_F32_F32;
		op_handlers[QB_CTANH_F32_F32_ARR] = &&label_CTANH_F32_F32_ARR;
		op_handlers[QB_IF_EQ_F64_F64_VAR] = &&label_IF_EQ_F64_F64_VAR;
		op_handlers[QB_IF_EQ_F64_F64_ELV] = &&label_IF_EQ_F64_F64_ELV;
		op_handlers[QB_IF_NE_F64_F64_VAR] = &&label_IF_NE_F64_F64_VAR;
		op_handlers[QB_IF_NE_F64_F64_ELV] = &&label_IF_NE_F64_F64_ELV;
		op_handlers[QB_IF_LT_F64_F64_VAR] = &&label_IF_LT_F64_F64_VAR;
		op_handlers[QB_IF_LT_F64_F64_ELV] = &&label_IF_LT_F64_F64_ELV;
		op_handlers[QB_IF_GT_F64_F64_VAR] = &&label_IF_GT_F64_F64_VAR;
		op_handlers[QB_IF_GT_F64_F64_ELV] = &&label_IF_GT_F64_F64_ELV;
		op_handlers[QB_IF_LE_F64_F64_VAR] = &&label_IF_LE_F64_F64_VAR;
		op_handlers[QB_IF_LE_F64_F64_ELV] = &&label_IF_LE_F64_F64_ELV;
		op_handlers[QB_IF_GE_F64_F64_VAR] = &&label_IF_GE_F64_F64_VAR;
		op_handlers[QB_IF_GE_F64_F64_ELV] = &&label_IF_GE_F64_F64_ELV;
		op_handlers[QB_ADD_F64_F64_F64_VAR] = &&label_ADD_F64_F64_F64_VAR;
		op_handlers[QB_ADD_F64_F64_F64_ELV] = &&label_ADD_F64_F64_F64_ELV;
		op_handlers[QB_ADD_F64_F64_F64_ARR] = &&label_ADD_F64_F64_F64_ARR;
		op_handlers[QB_SUB_F64_F64_F64_VAR] = &&label_SUB_F64_F64_F64_VAR;
		op_handlers[QB_SUB_F64_F64_F64_ELV] = &&label_SUB_F64_F64_F64_ELV;
		op_handlers[QB_SUB_F64_F64_F64_ARR] = &&label_SUB_F64_F64_F64_ARR;
		op_handlers[QB_MUL_F64_F64_F64_VAR] = &&label_MUL_F64_F64_F64_VAR;
		op_handlers[QB_MUL_F64_F64_F64_ELV] = &&label_MUL_F64_F64_F64_ELV;
		op_handlers[QB_MUL_F64_F64_F64_ARR] = &&label_MUL_F64_F64_F64_ARR;
		op_handlers[QB_DIV_F64_F64_F64_VAR] = &&label_DIV_F64_F64_F64_VAR;
		op_handlers[QB_DIV_F64_F64_F64_ELV] = &&label_DIV_F64_F64_F64_ELV;
		op_handlers[QB_DIV_F64_F64_F64_ARR] = &&label_DIV_F64_F64_F64_ARR;
		op_handlers[QB_MOD_F64_F64_F64_VAR] = &&label_MOD_F64_F64_F64_VAR;
		op_handlers[QB_MOD_F64_F64_F64_ELV] = &&label_MOD_F64_F64_F64_ELV;
		op_handlers[QB_MOD_F64_F64_F64_ARR] = &&label_MOD_F64_F64_F64_ARR;
		op_handlers[QB_MAC_F64_F64_F64_F64_VAR] = &&label_MAC_F64_F64_F64_F64_VAR;
		op_handlers[QB_MAC_F64_F64_F64_F64_ELV] = &&label_MAC_F64_F64_F64_F64_ELV;
		op_handlers[QB_MAC_F64_F64_F64_F64_ARR] = &&label_MAC_F64_F64_F64_F64_ARR;
		op_handlers[QB_MOD_FLR_F64_F64_F64_VAR] = &&label_MOD_FLR_F64_F64_F64_VAR;
		op_handlers[QB_MOD_FLR_F64_F64_F64_ELV] = &&label_MOD_FLR_F64_F64_F64_ELV;
		op_handlers[QB_MOD_FLR_F64_F64_F64_ARR] = &&label_MOD_FLR_F64_F64_F64_ARR;
		op_handlers[QB_NEG_F64_F64_VAR] = &&label_NEG_F64_F64_VAR;
		op_handlers[QB_NEG_F64_F64_ELV] = &&label_NEG_F64_F64_ELV;
		op_handlers[QB_NEG_F64_F64_ARR] = &&label_NEG_F64_F64_ARR;
		op_handlers[QB_MOV_F64_F64_VAR] = &&label_MOV_F64_F64_VAR;
		op_handlers[QB_MOV_F64_F64_ELV] = &&label_MOV_F64_F64_ELV;
		op_handlers[QB_MOV_F64_F64_ARR] = &&label_MOV_F64_F64_ARR;
		op_handlers[QB_INC_F64_VAR] = &&label_INC_F64_VAR;
		op_handlers[QB_INC_F64_ELV] = &&label_INC_F64_ELV;
		op_handlers[QB_INC_F64_ARR] = &&label_INC_F64_ARR;
		op_handlers[QB_DEC_F64_VAR] = &&label_DEC_F64_VAR;
		op_handlers[QB_DEC_F64_ELV] = &&label_DEC_F64_ELV;
		op_handlers[QB_DEC_F64_ARR] = &&label_DEC_F64_ARR;
		op_handlers[QB_EQ_F64_F64_I32_VAR] = &&label_EQ_F64_F64_I32_VAR;
		op_handlers[QB_EQ_F64_F64_I32_ELV] = &&label_EQ_F64_F64_I32_ELV;
		op_handlers[QB_EQ_F64_F64_I32_ARR] = &&label_EQ_F64_F64_I32_ARR;
		op_handlers[QB_NE_F64_F64_I32_VAR] = &&label_NE_F64_F64_I32_VAR;
		op_handlers[QB_NE_F64_F64_I32_ELV] = &&label_NE_F64_F64_I32_ELV;
		op_handlers[QB_NE_F64_F64_I32_ARR] = &&label_NE_F64_F64_I32_ARR;
		op_handlers[QB_LT_F64_F64_I32_VAR] = &&label_LT_F64_F64_I32_VAR;
		op_handlers[QB_LT_F64_F64_I32_ELV] = &&label_LT_F64_F64_I32_ELV;
		op_handlers[QB_LT_F64_F64_I32_ARR] = &&label_LT_F64_F64_I32_ARR;
		op_handlers[QB_LE_F64_F64_I32_VAR] = &&label_LE_F64_F64_I32_VAR;
		op_handlers[QB_LE_F64_F64_I32_ELV] = &&label_LE_F64_F64_I32_ELV;
		op_handlers[QB_LE_F64_F64_I32_ARR] = &&label_LE_F64_F64_I32_ARR;
		op_handlers[QB_EQ_SET_F64_F64_I32] = &&label_EQ_SET_F64_F64_I32;
		op_handlers[QB_NE_SET_F64_F64_I32] = &&label_NE_SET_F64_F64_I32;
		op_handlers[QB_LT_SET_F64_F64_I32] = &&label_LT_SET_F64_F64_I32;
		op_handlers[QB_LE_SET_F64_F64_I32] = &&label_LE_SET_F64_F64_I32;
		op_handlers[QB_ISSET_F64_I32_ELV] = &&label_ISSET_F64_I32_ELV;
		op_handlers[QB_UNSET_F64_VAR] = &&label_UNSET_F64_VAR;
		op_handlers[QB_UNSET_F64_ELV] = &&label_UNSET_F64_ELV;
		op_handlers[QB_UNSET_F64_ARR] = &&label_UNSET_F64_ARR;
		op_handlers[QB_MOV_F64_S32_VAR] = &&label_MOV_F64_S32_VAR;
		op_handlers[QB_MOV_F64_S32_ELV] = &&label_MOV_F64_S32_ELV;
		op_handlers[QB_MOV_F64_S32_ARR] = &&label_MOV_F64_S32_ARR;
		op_handlers[QB_MOV_F64_U32_VAR] = &&label_MOV_F64_U32_VAR;
		op_handlers[QB_MOV_F64_U32_ELV] = &&label_MOV_F64_U32_ELV;
		op_handlers[QB_MOV_F64_U32_ARR] = &&label_MOV_F64_U32_ARR;
		op_handlers[QB_MOV_F64_S08_VAR] = &&label_MOV_F64_S08_VAR;
		op_handlers[QB_MOV_F64_S08_ELV] = &&label_MOV_F64_S08_ELV;
		op_handlers[QB_MOV_F64_S08_ARR] = &&label_MOV_F64_S08_ARR;
		op_handlers[QB_MOV_F64_U08_VAR] = &&label_MOV_F64_U08_VAR;
		op_handlers[QB_MOV_F64_U08_ELV] = &&label_MOV_F64_U08_ELV;
		op_handlers[QB_MOV_F64_U08_ARR] = &&label_MOV_F64_U08_ARR;
		op_handlers[QB_MOV_F64_S16_VAR] = &&label_MOV_F64_S16_VAR;
		op_handlers[QB_MOV_F64_S16_ELV] = &&label_MOV_F64_S16_ELV;
		op_handlers[QB_MOV_F64_S16_ARR] = &&label_MOV_F64_S16_ARR;
		op_handlers[QB_MOV_F64_U16_VAR] = &&label_MOV_F64_U16_VAR;
		op_handlers[QB_MOV_F64_U16_ELV] = &&label_MOV_F64_U16_ELV;
		op_handlers[QB_MOV_F64_U16_ARR] = &&label_MOV_F64_U16_ARR;
		op_handlers[QB_MOV_F64_S64_VAR] = &&label_MOV_F64_S64_VAR;
		op_handlers[QB_MOV_F64_S64_ELV] = &&label_MOV_F64_S64_ELV;
		op_handlers[QB_MOV_F64_S64_ARR] = &&label_MOV_F64_S64_ARR;
		op_handlers[QB_MOV_F64_U64_VAR] = &&label_MOV_F64_U64_VAR;
		op_handlers[QB_MOV_F64_U64_ELV] = &&label_MOV_F64_U64_ELV;
		op_handlers[QB_MOV_F64_U64_ARR] = &&label_MOV_F64_U64_ARR;
		op_handlers[QB_MOV_F64_F32_VAR] = &&label_MOV_F64_F32_VAR;
		op_handlers[QB_MOV_F64_F32_ELV] = &&label_MOV_F64_F32_ELV;
		op_handlers[QB_MOV_F64_F32_ARR] = &&label_MOV_F64_F32_ARR;
		op_handlers[QB_BOOL_F64_I32_VAR] = &&label_BOOL_F64_I32_VAR;
		op_handlers[QB_BOOL_F64_I32_ELV] = &&label_BOOL_F64_I32_ELV;
		op_handlers[QB_BOOL_F64_I32_ARR] = &&label_BOOL_F64_I32_ARR;
		op_handlers[QB_ABS_F64_F64_VAR] = &&label_ABS_F64_F64_VAR;
		op_handlers[QB_ABS_F64_F64_ELV] = &&label_ABS_F64_F64_ELV;
		op_handlers[QB_ABS_F64_F64_ARR] = &&label_ABS_F64_F64_ARR;
		op_handlers[QB_MIN_F64_F64_F64_VAR] = &&label_MIN_F64_F64_F64_VAR;
		op_handlers[QB_MIN_F64_F64_F64_ELV] = &&label_MIN_F64_F64_F64_ELV;
		op_handlers[QB_MIN_F64_F64_F64_ARR] = &&label_MIN_F64_F64_F64_ARR;
		op_handlers[QB_MAX_F64_F64_F64_VAR] = &&label_MAX_F64_F64_F64_VAR;
		op_handlers[QB_MAX_F64_F64_F64_ELV] = &&label_MAX_F64_F64_F64_ELV;
		op_handlers[QB_MAX_F64_F64_F64_ARR] = &&label_MAX_F64_F64_F64_ARR;
		op_handlers[QB_SIN_F64_F64_VAR] = &&label_SIN_F64_F64_VAR;
		op_handlers[QB_SIN_F64_F64_ELV] = &&label_SIN_F64_F64_ELV;
		op_handlers[QB_SIN_F64_F64_ARR] = &&label_SIN_F64_F64_ARR;
		op_handlers[QB_ASIN_F64_F64_VAR] = &&label_ASIN_F64_F64_VAR;
		op_handlers[QB_ASIN_F64_F64_ELV] = &&label_ASIN_F64_F64_ELV;
		op_handlers[QB_ASIN_F64_F64_ARR] = &&label_ASIN_F64_F64_ARR;
		op_handlers[QB_COS_F64_F64_VAR] = &&label_COS_F64_F64_VAR;
		op_handlers[QB_COS_F64_F64_ELV] = &&label_COS_F64_F64_ELV;
		op_handlers[QB_COS_F64_F64_ARR] = &&label_COS_F64_F64_ARR;
		op_handlers[QB_ACOS_F64_F64_VAR] = &&label_ACOS_F64_F64_VAR;
		op_handlers[QB_ACOS_F64_F64_ELV] = &&label_ACOS_F64_F64_ELV;
		op_handlers[QB_ACOS_F64_F64_ARR] = &&label_ACOS_F64_F64_ARR;
		op_handlers[QB_TAN_F64_F64_VAR] = &&label_TAN_F64_F64_VAR;
		op_handlers[QB_TAN_F64_F64_ELV] = &&label_TAN_F64_F64_ELV;
		op_handlers[QB_TAN_F64_F64_ARR] = &&label_TAN_F64_F64_ARR;
		op_handlers[QB_ATAN_F64_F64_VAR] = &&label_ATAN_F64_F64_VAR;
		op_handlers[QB_ATAN_F64_F64_ELV] = &&label_ATAN_F64_F64_ELV;
		op_handlers[QB_ATAN_F64_F64_ARR] = &&label_ATAN_F64_F64_ARR;
		op_handlers[QB_ATAN2_F64_F64_F64_VAR] = &&label_ATAN2_F64_F64_F64_VAR;
		op_handlers[QB_ATAN2_F64_F64_F64_ELV] = &&label_ATAN2_F64_F64_F64_ELV;
		op_handlers[QB_ATAN2_F64_F64_F64_ARR] = &&label_ATAN2_F64_F64_F64_ARR;
		op_handlers[QB_SINH_F64_F64_VAR] = &&label_SINH_F64_F64_VAR;
		op_handlers[QB_SINH_F64_F64_ELV] = &&label_SINH_F64_F64_ELV;
		op_handlers[QB_SINH_F64_F64_ARR] = &&label_SINH_F64_F64_ARR;
		op_handlers[QB_ASINH_F64_F64_VAR] = &&label_ASINH_F64_F64_VAR;
		op_handlers[QB_ASINH_F64_F64_ELV] = &&label_ASINH_F64_F64_ELV;
		op_handlers[QB_ASINH_F64_F64_ARR] = &&label_ASINH_F64_F64_ARR;
		op_handlers[QB_COSH_F64_F64_VAR] = &&label_COSH_F64_F64_VAR;
		op_handlers[QB_COSH_F64_F64_ELV] = &&label_COSH_F64_F64_ELV;
		op_handlers[QB_COSH_F64_F64_ARR] = &&label_COSH_F64_F64_ARR;
		op_handlers[QB_ACOSH_F64_F64_VAR] = &&label_ACOSH_F64_F64_VAR;
		op_handlers[QB_ACOSH_F64_F64_ELV] = &&label_ACOSH_F64_F64_ELV;
		op_handlers[QB_ACOSH_F64_F64_ARR] = &&label_ACOSH_F64_F64_ARR;
		op_handlers[QB_TANH_F64_F64_VAR] = &&label_TANH_F64_F64_VAR;
		op_handlers[QB_TANH_F64_F64_ELV] = &&label_TANH_F64_F64_ELV;
		op_handlers[QB_TANH_F64_F64_ARR] = &&label_TANH_F64_F64_ARR;
		op_handlers[QB_ATANH_F64_F64_VAR] = &&label_ATANH_F64_F64_VAR;
		op_handlers[QB_ATANH_F64_F64_ELV] = &&label_ATANH_F64_F64_ELV;
		op_handlers[QB_ATANH_F64_F64_ARR] = &&label_ATANH_F64_F64_ARR;
		op_handlers[QB_CEIL_F64_F64_VAR] = &&label_CEIL_F64_F64_VAR;
		op_handlers[QB_CEIL_F64_F64_ELV] = &&label_CEIL_F64_F64_ELV;
		op_handlers[QB_CEIL_F64_F64_ARR] = &&label_CEIL_F64_F64_ARR;
		op_handlers[QB_FLOOR_F64_F64_VAR] = &&label_FLOOR_F64_F64_VAR;
		op_handlers[QB_FLOOR_F64_F64_ELV] = &&label_FLOOR_F64_F64_ELV;
		op_handlers[QB_FLOOR_F64_F64_ARR] = &&label_FLOOR_F64_F64_ARR;
		op_handlers[QB_ROUND_F64_I32_I32_F64_VAR] = &&label_ROUND_F64_I32_I32_F64_VAR;
		op_handlers[QB_ROUND_F64_I32_I32_F64_ELV] = &&label_ROUND_F64_I32_I32_F64_ELV;
		op_handlers[QB_ROUND_F64_I32_I32_F64_ARR] = &&label_ROUND_F64_I32_I32_F64_ARR;
		op_handlers[QB_LOG_F64_F64_VAR] = &&label_LOG_F64_F64_VAR;
		op_handlers[QB_LOG_F64_F64_ELV] = &&label_LOG_F64_F64_ELV;
		op_handlers[QB_LOG_F64_F64_ARR] = &&label_LOG_F64_F64_ARR;
		op_handlers[QB_LOG1P_F64_F64_VAR] = &&label_LOG1P_F64_F64_VAR;
		op_handlers[QB_LOG1P_F64_F64_ELV] = &&label_LOG1P_F64_F64_ELV;
		op_handlers[QB_LOG1P_F64_F64_ARR] = &&label_LOG1P_F64_F64_ARR;
		op_handlers[QB_LOG2_F64_F64_VAR] = &&label_LOG2_F64_F64_VAR;
		op_handlers[QB_LOG2_F64_F64_ELV] = &&label_LOG2_F64_F64_ELV;
		op_handlers[QB_LOG2_F64_F64_ARR] = &&label_LOG2_F64_F64_ARR;
		op_handlers[QB_LOG10_F64_F64_VAR] = &&label_LOG10_F64_F64_VAR;
		op_handlers[QB_LOG10_F64_F64_ELV] = &&label_LOG10_F64_F64_ELV;
		op_handlers[QB_LOG10_F64_F64_ARR] = &&label_LOG10_F64_F64_ARR;
		op_handlers[QB_EXP_F64_F64_VAR] = &&label_EXP_F64_F64_VAR;
		op_handlers[QB_EXP_F64_F64_ELV] = &&label_EXP_F64_F64_ELV;
		op_handlers[QB_EXP_F64_F64_ARR] = &&label_EXP_F64_F64_ARR;
		op_handlers[QB_EXPM1_F64_F64_VAR] = &&label_EXPM1_F64_F64_VAR;
		op_handlers[QB_EXPM1_F64_F64_ELV] = &&label_EXPM1_F64_F64_ELV;
		op_handlers[QB_EXPM1_F64_F64_ARR] = &&label_EXPM1_F64_F64_ARR;
		op_handlers[QB_EXP2_F64_F64_VAR] = &&label_EXP2_F64_F64_VAR;
		op_handlers[QB_EXP2_F64_F64_ELV] = &&label_EXP2_F64_F64_ELV;
		op_handlers[QB_EXP2_F64_F64_ARR] = &&label_EXP2_F64_F64_ARR;
		op_handlers[QB_POW_F64_F64_F64_VAR] = &&label_POW_F64_F64_F64_VAR;
		op_handlers[QB_POW_F64_F64_F64_ELV] = &&label_POW_F64_F64_F64_ELV;
		op_handlers[QB_POW_F64_F64_F64_ARR] = &&label_POW_F64_F64_F64_ARR;
		op_handlers[QB_SQRT_F64_F64_VAR] = &&label_SQRT_F64_F64_VAR;
		op_handlers[QB_SQRT_F64_F64_ELV] = &&label_SQRT_F64_F64_ELV;
		op_handlers[QB_SQRT_F64_F64_ARR] = &&label_SQRT_F64_F64_ARR;
		op_handlers[QB_HYPOT_F64_F64_F64_VAR] = &&label_HYPOT_F64_F64_F64_VAR;
		op_handlers[QB_HYPOT_F64_F64_F64_ELV] = &&label_HYPOT_F64_F64_F64_ELV;
		op_handlers[QB_HYPOT_F64_F64_F64_ARR] = &&label_HYPOT_F64_F64_F64_ARR;
		op_handlers[QB_LCG_F64_VAR] = &&label_LCG_F64_VAR;
		op_handlers[QB_LCG_F64_ELV] = &&label_LCG_F64_ELV;
		op_handlers[QB_LCG_F64_ARR] = &&label_LCG_F64_ARR;
		op_handlers[QB_FIN_F64_I32_VAR] = &&label_FIN_F64_I32_VAR;
		op_handlers[QB_FIN_F64_I32_ELV] = &&label_FIN_F64_I32_ELV;
		op_handlers[QB_FIN_F64_I32_ARR] = &&label_FIN_F64_I32_ARR;
		op_handlers[QB_INF_F64_I32_VAR] = &&label_INF_F64_I32_VAR;
		op_handlers[QB_INF_F64_I32_ELV] = &&label_INF_F64_I32_ELV;
		op_handlers[QB_INF_F64_I32_ARR] = &&label_INF_F64_I32_ARR;
		op_handlers[QB_NAN_F64_I32_VAR] = &&label_NAN_F64_I32_VAR;
		op_handlers[QB_NAN_F64_I32_ELV] = &&label_NAN_F64_I32_ELV;
		op_handlers[QB_NAN_F64_I32_ARR] = &&label_NAN_F64_I32_ARR;
		op_handlers[QB_RSQRT_F64_F64_VAR] = &&label_RSQRT_F64_F64_VAR;
		op_handlers[QB_RSQRT_F64_F64_ELV] = &&label_RSQRT_F64_F64_ELV;
		op_handlers[QB_RSQRT_F64_F64_ARR] = &&label_RSQRT_F64_F64_ARR;
		op_handlers[QB_CLAMP_F64_F64_F64_F64_VAR] = &&label_CLAMP_F64_F64_F64_F64_VAR;
		op_handlers[QB_CLAMP_F64_F64_F64_F64_ELV] = &&label_CLAMP_F64_F64_F64_F64_ELV;
		op_handlers[QB_CLAMP_F64_F64_F64_F64_ARR] = &&label_CLAMP_F64_F64_F64_F64_ARR;
		op_handlers[QB_FRACT_F64_F64_VAR] = &&label_FRACT_F64_F64_VAR;
		op_handlers[QB_FRACT_F64_F64_ELV] = &&label_FRACT_F64_F64_ELV;
		op_handlers[QB_FRACT_F64_F64_ARR] = &&label_FRACT_F64_F64_ARR;
		op_handlers[QB_MIX_F64_F64_F64_F64_VAR] = &&label_MIX_F64_F64_F64_F64_VAR;
		op_handlers[QB_MIX_F64_F64_F64_F64_ELV] = &&label_MIX_F64_F64_F64_F64_ELV;
		op_handlers[QB_MIX_F64_F64_F64_F64_ARR] = &&label_MIX_F64_F64_F64_F64_ARR;
		op_handlers[QB_SIGN_F64_F64_VAR] = &&label_SIGN_F64_F64_VAR;
		op_handlers[QB_SIGN_F64_F64_ELV] = &&label_SIGN_F64_F64_ELV;
		op_handlers[QB_SIGN_F64_F64_ARR] = &&label_SIGN_F64_F64_ARR;
		op_handlers[QB_STEP_F64_F64_F64_VAR] = &&label_STEP_F64_F64_F64_VAR;
		op_handlers[QB_STEP_F64_F64_F64_ELV] = &&label_STEP_F64_F64_F64_ELV;
		op_handlers[QB_STEP_F64_F64_F64_ARR] = &&label_STEP_F64_F64_F64_ARR;
		op_handlers[QB_SSTEP_F64_F64_F64_F64_VAR] = &&label_SSTEP_F64_F64_F64_F64_VAR;
		op_handlers[QB_SSTEP_F64_F64_F64_F64_ELV] = &&label_SSTEP_F64_F64_F64_F64_ELV;
		op_handlers[QB_SSTEP_F64_F64_F64_F64_ARR] = &&label_SSTEP_F64_F64_F64_F64_ARR;
		op_handlers[QB_RAD2DEG_F64_F64_VAR] = &&label_RAD2DEG_F64_F64_VAR;
		op_handlers[QB_RAD2DEG_F64_F64_ELV] = &&label_RAD2DEG_F64_F64_ELV;
		op_handlers[QB_RAD2DEG_F64_F64_ARR] = &&label_RAD2DEG_F64_F64_ARR;
		op_handlers[QB_DEG2RAD_F64_F64_VAR] = &&label_DEG2RAD_F64_F64_VAR;
		op_handlers[QB_DEG2RAD_F64_F64_ELV] = &&label_DEG2RAD_F64_F64_ELV;
		op_handlers[QB_DEG2RAD_F64_F64_ARR] = &&label_DEG2RAD_F64_F64_ARR;
		op_handlers[QB_PRN_F64_VAR] = &&label_PRN_F64_VAR;
		op_handlers[QB_PRN_F64_ELV] = &&label_PRN_F64_ELV;
		op_handlers[QB_PRN_F64_ARR] = &&label_PRN_F64_ARR;
		op_handlers[QB_PRN_DIM_F64_U32] = &&label_PRN_DIM_F64_U32;
		op_handlers[QB_CAT_F64_U08_VAR] = &&label_CAT_F64_U08_VAR;
		op_handlers[QB_CAT_F64_U08_ELV] = &&label_CAT_F64_U08_ELV;
		op_handlers[QB_CAT_F64_U08_ARR] = &&label_CAT_F64_U08_ARR;
		op_handlers[QB_CAT_DIM_F64_U32_U08] = &&label_CAT_DIM_F64_U32_U08;
		op_handlers[QB_PACK_LE_F64_U08_VAR] = &&label_PACK_LE_F64_U08_VAR;
		op_handlers[QB_PACK_LE_F64_U08_ELV] = &&label_PACK_LE_F64_U08_ELV;
		op_handlers[QB_PACK_BE_F64_U08_VAR] = &&label_PACK_BE_F64_U08_VAR;
		op_handlers[QB_PACK_BE_F64_U08_ELV] = &&label_PACK_BE_F64_U08_ELV;
		op_handlers[QB_UNPACK_LE_U08_F64_VAR] = &&label_UNPACK_LE_U08_F64_VAR;
		op_handlers[QB_UNPACK_LE_U08_F64_ELV] = &&label_UNPACK_LE_U08_F64_ELV;
		op_handlers[QB_UNPACK_BE_U08_F64_VAR] = &&label_UNPACK_BE_U08_F64_VAR;
		op_handlers[QB_UNPACK_BE_U08_F64_ELV] = &&label_UNPACK_BE_U08_F64_ELV;
		op_handlers[QB_SORT_F64] = &&label_SORT_F64;
		op_handlers[QB_RSORT_F64] = &&label_RSORT_F64;
		op_handlers[QB_AMIN_F64_F64_VAR] = &&label_AMIN_F64_F64_VAR;
		op_handlers[QB_AMAX_F64_F64_VAR] = &&label_AMAX_F64_F64_VAR;
		op_handlers[QB_APROD_F64_F64_VAR] = &&label_APROD_F64_F64_VAR;
		op_handlers[QB_ASUM_F64_F64_VAR] = &&label_ASUM_F64_F64_VAR;
		op_handlers[QB_RANGE_F64_F64_F64_F64_VAR] = &&label_RANGE_F64_F64_F64_F64_VAR;
		op_handlers[QB_AMIN_F64_F64_ELV] = &&label_AMIN_F64_F64_ELV;
		op_handlers[QB_AMAX_F64_F64_ELV] = &&label_AMAX_F64_F64_ELV;
		op_handlers[QB_APROD_F64_F64_ELV] = &&label_APROD_F64_F64_ELV;
		op_handlers[QB_ASUM_F64_F64_ELV] = &&label_ASUM_F64_F64_ELV;
		op_handlers[QB_RANGE_F64_F64_F64_F64_ELV] = &&label_RANGE_F64_F64_F64_F64_ELV;
		op_handlers[QB_AFIND_IDX_F64_F64_I32_VAR] = &&label_AFIND_IDX_F64_F64_I32_VAR;
		op_handlers[QB_AFIND_IDX_F64_F64_I32_ELV] = &&label_AFIND_IDX_F64_F64_I32_ELV;
		op_handlers[QB_AFIND_IDX_F64_F64_I32_ARR] = &&label_AFIND_IDX_F64_F64_I32_ARR;
		op_handlers[QB_AFIND_F64_F64_I32_VAR] = &&label_AFIND_F64_F64_I32_VAR;
		op_handlers[QB_AFIND_F64_F64_I32_ELV] = &&label_AFIND_F64_F64_I32_ELV;
		op_handlers[QB_AFIND_F64_F64_I32_ARR] = &&label_AFIND_F64_F64_I32_ARR;
		op_handlers[QB_APOS_F64_F64_I32_I32] = &&label_APOS_F64_F64_I32_I32;
		op_handlers[QB_ARPOS_F64_F64_I32_I32] = &&label_ARPOS_F64_F64_I32_I32;
		op_handlers[QB_AREV_F64_U32_F64] = &&label_AREV_F64_U32_F64;
		op_handlers[QB_AINS_F64_U32_F64] = &&label_AINS_F64_U32_F64;
		op_handlers[QB_AUNIQ_F64_U32_F64] = &&label_AUNIQ_F64_U32_F64;
		op_handlers[QB_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_VAR] = &&label_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_VAR;
		op_handlers[QB_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_ELV] = &&label_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_ELV;
		op_handlers[QB_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_ARR] = &&label_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_ARR;
		op_handlers[QB_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_VAR] = &&label_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_VAR;
		op_handlers[QB_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_ELV] = &&label_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_ELV;
		op_handlers[QB_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_ARR] = &&label_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_ARR;
		op_handlers[QB_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_VAR] = &&label_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_VAR;
		op_handlers[QB_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_ELV] = &&label_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_ELV;
		op_handlers[QB_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_ARR] = &&label_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_ARR;
		op_handlers[QB_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_VAR] = &&label_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_VAR;
		op_handlers[QB_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_ELV] = &&label_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_ELV;
		op_handlers[QB_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_ARR] = &&label_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_ARR;
		op_handlers[QB_BLEND_F64_F64_F64] = &&label_BLEND_F64_F64_F64;
		op_handlers[QB_PREMULT_F64_F64] = &&label_PREMULT_F64_F64;
		op_handlers[QB_UNPREMULT_F64_F64] = &&label_UNPREMULT_F64_F64;
		op_handlers[QB_MUL_MM_4X_F64_F64_F64] = &&label_MUL_MM_4X_F64_F64_F64;
		op_handlers[QB_MUL_MM_4X_F64_F64_F64_ARR] = &&label_MUL_MM_4X_F64_F64_F64_ARR;
		op_handlers[QB_MUL_MV_4X_F64_F64_F64] = &&label_MUL_MV_4X_F64_F64_F64;
		op_handlers[QB_MUL_MV_4X_F64_F64_F64_ARR] = &&label_MUL_MV_4X_F64_F64_F64_ARR;
		op_handlers[QB_MUL_VM_4X_F64_F64_F64] = &&label_MUL_VM_4X_F64_F64_F64;
		op_handlers[QB_MUL_VM_4X_F64_F64_F64_ARR] = &&label_MUL_VM_4X_F64_F64_F64_ARR;
		op_handlers[QB_MTRAN_4X_F64_F64] = &&label_MTRAN_4X_F64_F64;
		op_handlers[QB_MTRAN_4X_F64_F64_ARR] = &&label_MTRAN_4X_F64_F64_ARR;
		op_handlers[QB_MDET_4X_F64_F64_VAR] = &&label_MDET_4X_F64_F64_VAR;
		op_handlers[QB_MDET_4X_F64_F64_ELV] = &&label_MDET_4X_F64_F64_ELV;
		op_handlers[QB_MDET_4X_F64_F64_ARR] = &&label_MDET_4X_F64_F64_ARR;
		op_handlers[QB_MINV_4X_F64_F64] = &&label_MINV_4X_F64_F64;
		op_handlers[QB_MINV_4X_F64_F64_ARR] = &&label_MINV_4X_F64_F64_ARR;
		op_handlers[QB_DOT_4X_F64_F64_F64_VAR] = &&label_DOT_4X_F64_F64_F64_VAR;
		op_handlers[QB_DOT_4X_F64_F64_F64_ELV] = &&label_DOT_4X_F64_F64_F64_ELV;
		op_handlers[QB_DOT_4X_F64_F64_F64_ARR] = &&label_DOT_4X_F64_F64_F64_ARR;
		op_handlers[QB_LEN_4X_F64_F64_VAR] = &&label_LEN_4X_F64_F64_VAR;
		op_handlers[QB_LEN_4X_F64_F64_ELV] = &&label_LEN_4X_F64_F64_ELV;
		op_handlers[QB_LEN_4X_F64_F64_ARR] = &&label_LEN_4X_F64_F64_ARR;
		op_handlers[QB_DIS_4X_F64_F64_F64_VAR] = &&label_DIS_4X_F64_F64_F64_VAR;
		op_handlers[QB_DIS_4X_F64_F64_F64_ELV] = &&label_DIS_4X_F64_F64_F64_ELV;
		op_handlers[QB_DIS_4X_F64_F64_F64_ARR] = &&label_DIS_4X_F64_F64_F64_ARR;
		op_handlers[QB_NORM_4X_F64_F64] = &&label_NORM_4X_F64_F64;
		op_handlers[QB_NORM_4X_F64_F64_ARR] = &&label_NORM_4X_F64_F64_ARR;
		op_handlers[QB_CROSS_4X_F64_F64_F64_F64] = &&label_CROSS_4X_F64_F64_F64_F64;
		op_handlers[QB_CROSS_4X_F64_F64_F64_F64_ARR] = &&label_CROSS_4X_F64_F64_F64_F64_ARR;
		op_handlers[QB_FORE_4X_F64_F64_F64] = &&label_FORE_4X_F64_F64_F64;
		op_handlers[QB_FORE_4X_F64_F64_F64_ARR] = &&label_FORE_4X_F64_F64_F64_ARR;
		op_handlers[QB_REFL_4X_F64_F64_F64] = &&label_REFL_4X_F64_F64_F64;
		op_handlers[QB_REFL_4X_F64_F64_F64_ARR] = &&label_REFL_4X_F64_F64_F64_ARR;
		op_handlers[QB_REFR_4X_F64_F64_F64_F64] = &&label_REFR_4X_F64_F64_F64_F64;
		op_handlers[QB_REFR_4X_F64_F64_F64_F64_ARR] = &&label_REFR_4X_F64_F64_F64_F64_ARR;
		op_handlers[QB_TRAN_4X_F64_F64_F64] = &&label_TRAN_4X_F64_F64_F64;
		op_handlers[QB_TRAN_4X_F64_F64_F64_ARR] = &&label_TRAN_4X_F64_F64_F64_ARR;
		op_handlers[QB_TRAN_RM_4X_F64_F64_F64] = &&label_TRAN_RM_4X_F64_F64_F64;
		op_handlers[QB_TRAN_RM_4X_F64_F64_F64_ARR] = &&label_TRAN_RM_4X_F64_F64_F64_ARR;
		op_handlers[QB_MOV_4X_F64_F64] = &&label_MOV_4X_F64_F64;
		op_handlers[QB_MOV_4X_F64_F64_ARR] = &&label_MOV_4X_F64_F64_ARR;
		op_handlers[QB_ADD_4X_F64_F64_F64] = &&label_ADD_4X_F64_F64_F64;
		op_handlers[QB_ADD_4X_F64_F64_F64_ARR] = &&label_ADD_4X_F64_F64_F64_ARR;
		op_handlers[QB_SUB_4X_F64_F64_F64] = &&label_SUB_4X_F64_F64_F64;
		op_handlers[QB_SUB_4X_F64_F64_F64_ARR] = &&label_SUB_4X_F64_F64_F64_ARR;
		op_handlers[QB_MUL_4X_F64_F64_F64] = &&label_MUL_4X_F64_F64_F64;
		op_handlers[QB_MUL_4X_F64_F64_F64_ARR] = &&label_MUL_4X_F64_F64_F64_ARR;
		op_handlers[QB_DIV_4X_F64_F64_F64] = &&label_DIV_4X_F64_F64_F64;
		op_handlers[QB_DIV_4X_F64_F64_F64_ARR] = &&label_DIV_4X_F64_F64_F64_ARR;
		op_handlers[QB_MOD_4X_F64_F64_F64] = &&label_MOD_4X_F64_F64_F64;
		op_handlers[QB_MOD_4X_F64_F64_F64_ARR] = &&label_MOD_4X_F64_F64_F64_ARR;
		op_handlers[QB_NEG_4X_F64_F64] = &&label_NEG_4X_F64_F64;
		op_handlers[QB_NEG_4X_F64_F64_ARR] = &&label_NEG_4X_F64_F64_ARR;
		op_handlers[QB_INC_4X_F64] = &&label_INC_4X_F64;
		op_handlers[QB_INC_4X_F64_ARR] = &&label_INC_4X_F64_ARR;
		op_handlers[QB_DEC_4X_F64] = &&label_DEC_4X_F64;
		op_handlers[QB_DEC_4X_F64_ARR] = &&label_DEC_4X_F64_ARR;
		op_handlers[QB_MAC_4X_F64_F64_F64_F64] = &&label_MAC_4X_F64_F64_F64_F64;
		op_handlers[QB_MAC_4X_F64_F64_F64_F64_ARR] = &&label_MAC_4X_F64_F64_F64_F64_ARR;
		op_handlers[QB_MUL_MM_3X_F64_F64_F64] = &&label_MUL_MM_3X_F64_F64_F64;
		op_handlers[QB_MUL_MM_3X_F64_F64_F64_ARR] = &&label_MUL_MM_3X_F64_F64_F64_ARR;
		op_handlers[QB_MUL_MV_3X_F64_F64_F64] = &&label_MUL_MV_3X_F64_F64_F64;
		op_handlers[QB_MUL_MV_3X_F64_F64_F64_ARR] = &&label_MUL_MV_3X_F64_F64_F64_ARR;
		op_handlers[QB_MUL_VM_3X_F64_F64_F64] = &&label_MUL_VM_3X_F64_F64_F64;
		op_handlers[QB_MUL_VM_3X_F64_F64_F64_ARR] = &&label_MUL_VM_3X_F64_F64_F64_ARR;
		op_handlers[QB_MTRAN_3X_F64_F64] = &&label_MTRAN_3X_F64_F64;
		op_handlers[QB_MTRAN_3X_F64_F64_ARR] = &&label_MTRAN_3X_F64_F64_ARR;
		op_handlers[QB_MINV_3X_F64_F64] = &&label_MINV_3X_F64_F64;
		op_handlers[QB_MINV_3X_F64_F64_ARR] = &&label_MINV_3X_F64_F64_ARR;
		op_handlers[QB_MDET_3X_F64_F64_VAR] = &&label_MDET_3X_F64_F64_VAR;
		op_handlers[QB_MDET_3X_F64_F64_ELV] = &&label_MDET_3X_F64_F64_ELV;
		op_handlers[QB_MDET_3X_F64_F64_ARR] = &&label_MDET_3X_F64_F64_ARR;
		op_handlers[QB_DOT_3X_F64_F64_F64_VAR] = &&label_DOT_3X_F64_F64_F64_VAR;
		op_handlers[QB_DOT_3X_F64_F64_F64_ELV] = &&label_DOT_3X_F64_F64_F64_ELV;
		op_handlers[QB_DOT_3X_F64_F64_F64_ARR] = &&label_DOT_3X_F64_F64_F64_ARR;
		op_handlers[QB_LEN_3X_F64_F64_VAR] = &&label_LEN_3X_F64_F64_VAR;
		op_handlers[QB_LEN_3X_F64_F64_ELV] = &&label_LEN_3X_F64_F64_ELV;
		op_handlers[QB_LEN_3X_F64_F64_ARR] = &&label_LEN_3X_F64_F64_ARR;
		op_handlers[QB_DIS_3X_F64_F64_F64_VAR] = &&label_DIS_3X_F64_F64_F64_VAR;
		op_handlers[QB_DIS_3X_F64_F64_F64_ELV] = &&label_DIS_3X_F64_F64_F64_ELV;
		op_handlers[QB_DIS_3X_F64_F64_F64_ARR] = &&label_DIS_3X_F64_F64_F64_ARR;
		op_handlers[QB_NORM_3X_F64_F64] = &&label_NORM_3X_F64_F64;
		op_handlers[QB_NORM_3X_F64_F64_ARR] = &&label_NORM_3X_F64_F64_ARR;
		op_handlers[QB_CROSS_3X_F64_F64_F64] = &&label_CROSS_3X_F64_F64_F64;
		op_handlers[QB_CROSS_3X_F64_F64_F64_ARR] = &&label_CROSS_3X_F64_F64_F64_ARR;
		op_handlers[QB_FORE_3X_F64_F64_F64] = &&label_FORE_3X_F64_F64_F64;
		op_handlers[QB_FORE_3X_F64_F64_F64_ARR] = &&label_FORE_3X_F64_F64_F64_ARR;
		op_handlers[QB_REFL_3X_F64_F64_F64] = &&label_REFL_3X_F64_F64_F64;
		op_handlers[QB_REFL_3X_F64_F64_F64_ARR] = &&label_REFL_3X_F64_F64_F64_ARR;
		op_handlers[QB_REFR_3X_F64_F64_F64_F64] = &&label_REFR_3X_F64_F64_F64_F64;
		op_handlers[QB_REFR_3X_F64_F64_F64_F64_ARR] = &&label_REFR_3X_F64_F64_F64_F64_ARR;
		op_handlers[QB_TRAN_3X_F64_F64_F64] = &&label_TRAN_3X_F64_F64_F64;
		op_handlers[QB_TRAN_3X_F64_F64_F64_ARR] = &&label_TRAN_3X_F64_F64_F64_ARR;
		op_handlers[QB_TRAN_RM_3X_F64_F64_F64] = &&label_TRAN_RM_3X_F64_F64_F64;
		op_handlers[QB_TRAN_RM_3X_F64_F64_F64_ARR] = &&label_TRAN_RM_3X_F64_F64_F64_ARR;
		op_handlers[QB_MOV_3X_F64_F64] = &&label_MOV_3X_F64_F64;
		op_handlers[QB_MOV_3X_F64_F64_ARR] = &&label_MOV_3X_F64_F64_ARR;
		op_handlers[QB_ADD_3X_F64_F64_F64] = &&label_ADD_3X_F64_F64_F64;
		op_handlers[QB_ADD_3X_F64_F64_F64_ARR] = &&label_ADD_3X_F64_F64_F64_ARR;
		op_handlers[QB_SUB_3X_F64_F64_F64] = &&label_SUB_3X_F64_F64_F64;
		op_handlers[QB_SUB_3X_F64_F64_F64_ARR] = &&label_SUB_3X_F64_F64_F64_ARR;
		op_handlers[QB_MUL_3X_F64_F64_F64] = &&label_MUL_3X_F64_F64_F64;
		op_handlers[QB_MUL_3X_F64_F64_F64_ARR] = &&label_MUL_3X_F64_F64_F64_ARR;
		op_handlers[QB_DIV_3X_F64_F64_F64] = &&label_DIV_3X_F64_F64_F64;
		op_handlers[QB_DIV_3X_F64_F64_F64_ARR] = &&label_DIV_3X_F64_F64_F64_ARR;
		op_handlers[QB_MOD_3X_F64_F64_F64] = &&label_MOD_3X_F64_F64_F64;
		op_handlers[QB_MOD_3X_F64_F64_F64_ARR] = &&label_MOD_3X_F64_F64_F64_ARR;
		op_handlers[QB_NEG_3X_F64_F64] = &&label_NEG_3X_F64_F64;
		op_handlers[QB_NEG_3X_F64_F64_ARR] = &&label_NEG_3X_F64_F64_ARR;
		op_handlers[QB_INC_3X_F64] = &&label_INC_3X_F64;
		op_handlers[QB_INC_3X_F64_ARR] = &&label_INC_3X_F64_ARR;
		op_handlers[QB_DEC_3X_F64] = &&label_DEC_3X_F64;
		op_handlers[QB_DEC_3X_F64_ARR] = &&label_DEC_3X_F64_ARR;
		op_handlers[QB_MAC_3X_F64_F64_F64_F64] = &&label_MAC_3X_F64_F64_F64_F64;
		op_handlers[QB_MAC_3X_F64_F64_F64_F64_ARR] = &&label_MAC_3X_F64_F64_F64_F64_ARR;
		op_handlers[QB_MUL_MM_2X_F64_F64_F64] = &&label_MUL_MM_2X_F64_F64_F64;
		op_handlers[QB_MUL_MM_2X_F64_F64_F64_ARR] = &&label_MUL_MM_2X_F64_F64_F64_ARR;
		op_handlers[QB_MUL_MV_2X_F64_F64_F64] = &&label_MUL_MV_2X_F64_F64_F64;
		op_handlers[QB_MUL_MV_2X_F64_F64_F64_ARR] = &&label_MUL_MV_2X_F64_F64_F64_ARR;
		op_handlers[QB_MUL_VM_2X_F64_F64_F64] = &&label_MUL_VM_2X_F64_F64_F64;
		op_handlers[QB_MUL_VM_2X_F64_F64_F64_ARR] = &&label_MUL_VM_2X_F64_F64_F64_ARR;
		op_handlers[QB_MTRAN_2X_F64_F64] = &&label_MTRAN_2X_F64_F64;
		op_handlers[QB_MTRAN_2X_F64_F64_ARR] = &&label_MTRAN_2X_F64_F64_ARR;
		op_handlers[QB_MINV_2X_F64_F64] = &&label_MINV_2X_F64_F64;
		op_handlers[QB_MINV_2X_F64_F64_ARR] = &&label_MINV_2X_F64_F64_ARR;
		op_handlers[QB_MDET_2X_F64_F64_VAR] = &&label_MDET_2X_F64_F64_VAR;
		op_handlers[QB_MDET_2X_F64_F64_ELV] = &&label_MDET_2X_F64_F64_ELV;
		op_handlers[QB_MDET_2X_F64_F64_ARR] = &&label_MDET_2X_F64_F64_ARR;
		op_handlers[QB_DOT_2X_F64_F64_F64_VAR] = &&label_DOT_2X_F64_F64_F64_VAR;
		op_handlers[QB_DOT_2X_F64_F64_F64_ELV] = &&label_DOT_2X_F64_F64_F64_ELV;
		op_handlers[QB_DOT_2X_F64_F64_F64_ARR] = &&label_DOT_2X_F64_F64_F64_ARR;
		op_handlers[QB_LEN_2X_F64_F64_VAR] = &&label_LEN_2X_F64_F64_VAR;
		op_handlers[QB_LEN_2X_F64_F64_ELV] = &&label_LEN_2X_F64_F64_ELV;
		op_handlers[QB_LEN_2X_F64_F64_ARR] = &&label_LEN_2X_F64_F64_ARR;
		op_handlers[QB_DIS_2X_F64_F64_F64_VAR] = &&label_DIS_2X_F64_F64_F64_VAR;
		op_handlers[QB_DIS_2X_F64_F64_F64_ELV] = &&label_DIS_2X_F64_F64_F64_ELV;
		op_handlers[QB_DIS_2X_F64_F64_F64_ARR] = &&label_DIS_2X_F64_F64_F64_ARR;
		op_handlers[QB_NORM_2X_F64_F64] = &&label_NORM_2X_F64_F64;
		op_handlers[QB_NORM_2X_F64_F64_ARR] = &&label_NORM_2X_F64_F64_ARR;
		op_handlers[QB_CROSS_2X_F64_F64_F64] = &&label_CROSS_2X_F64_F64_F64;
		op_handlers[QB_CROSS_2X_F64_F64_F64_ARR] = &&label_CROSS_2X_F64_F64_F64_ARR;
		op_handlers[QB_FORE_2X_F64_F64_F64] = &&label_FORE_2X_F64_F64_F64;
		op_handlers[QB_FORE_2X_F64_F64_F64_ARR] = &&label_FORE_2X_F64_F64_F64_ARR;
		op_handlers[QB_REFL_2X_F64_F64_F64] = &&label_REFL_2X_F64_F64_F64;
		op_handlers[QB_REFL_2X_F64_F64_F64_ARR] = &&label_REFL_2X_F64_F64_F64_ARR;
		op_handlers[QB_REFR_2X_F64_F64_F64_F64] = &&label_REFR_2X_F64_F64_F64_F64;
		op_handlers[QB_REFR_2X_F64_F64_F64_F64_ARR] = &&label_REFR_2X_F64_F64_F64_F64_ARR;
		op_handlers[QB_TRAN_2X_F64_F64_F64] = &&label_TRAN_2X_F64_F64_F64;
		op_handlers[QB_TRAN_2X_F64_F64_F64_ARR] = &&label_TRAN_2X_F64_F64_F64_ARR;
		op_handlers[QB_TRAN_RM_2X_F64_F64_F64] = &&label_TRAN_RM_2X_F64_F64_F64;
		op_handlers[QB_TRAN_RM_2X_F64_F64_F64_ARR] = &&label_TRAN_RM_2X_F64_F64_F64_ARR;
		op_handlers[QB_MOV_2X_F64_F64] = &&label_MOV_2X_F64_F64;
		op_handlers[QB_MOV_2X_F64_F64_ARR] = &&label_MOV_2X_F64_F64_ARR;
		op_handlers[QB_ADD_2X_F64_F64_F64] = &&label_ADD_2X_F64_F64_F64;
		op_handlers[QB_ADD_2X_F64_F64_F64_ARR] = &&label_ADD_2X_F64_F64_F64_ARR;
		op_handlers[QB_SUB_2X_F64_F64_F64] = &&label_SUB_2X_F64_F64_F64;
		op_handlers[QB_SUB_2X_F64_F64_F64_ARR] = &&label_SUB_2X_F64_F64_F64_ARR;
		op_handlers[QB_MUL_2X_F64_F64_F64] = &&label_MUL_2X_F64_F64_F64;
		op_handlers[QB_MUL_2X_F64_F64_F64_ARR] = &&label_MUL_2X_F64_F64_F64_ARR;
		op_handlers[QB_DIV_2X_F64_F64_F64] = &&label_DIV_2X_F64_F64_F64;
		op_handlers[QB_DIV_2X_F64_F64_F64_ARR] = &&label_DIV_2X_F64_F64_F64_ARR;
		op_handlers[QB_MOD_2X_F64_F64_F64] = &&label_MOD_2X_F64_F64_F64;
		op_handlers[QB_MOD_2X_F64_F64_F64_ARR] = &&label_MOD_2X_F64_F64_F64_ARR;
		op_handlers[QB_NEG_2X_F64_F64] = &&label_NEG_2X_F64_F64;
		op_handlers[QB_NEG_2X_F64_F64_ARR] = &&label_NEG_2X_F64_F64_ARR;
		op_handlers[QB_INC_2X_F64] = &&label_INC_2X_F64;
		op_handlers[QB_INC_2X_F64_ARR] = &&label_INC_2X_F64_ARR;
		op_handlers[QB_DEC_2X_F64] = &&label_DEC_2X_F64;
		op_handlers[QB_DEC_2X_F64_ARR] = &&label_DEC_2X_F64_ARR;
		op_handlers[QB_MAC_2X_F64_F64_F64_F64] = &&label_MAC_2X_F64_F64_F64_F64;
		op_handlers[QB_MAC_2X_F64_F64_F64_F64_ARR] = &&label_MAC_2X_F64_F64_F64_F64_ARR;
		op_handlers[QB_MUL_MM_F64_F64_F64] = &&label_MUL_MM_F64_F64_F64;
		op_handlers[QB_MUL_MM_F64_F64_F64_ARR] = &&label_MUL_MM_F64_F64_F64_ARR;
		op_handlers[QB_MUL_MV_F64_F64_F64] = &&label_MUL_MV_F64_F64_F64;
		op_handlers[QB_MUL_MV_F64_F64_F64_ARR] = &&label_MUL_MV_F64_F64_F64_ARR;
		op_handlers[QB_MUL_VM_F64_F64_F64] = &&label_MUL_VM_F64_F64_F64;
		op_handlers[QB_MUL_VM_F64_F64_F64_ARR] = &&label_MUL_VM_F64_F64_F64_ARR;
		op_handlers[QB_MTRAN_F64_F64] = &&label_MTRAN_F64_F64;
		op_handlers[QB_MTRAN_F64_F64_ARR] = &&label_MTRAN_F64_F64_ARR;
		op_handlers[QB_MINV_F64_F64] = &&label_MINV_F64_F64;
		op_handlers[QB_MINV_F64_F64_ARR] = &&label_MINV_F64_F64_ARR;
		op_handlers[QB_MDET_F64_F64_VAR] = &&label_MDET_F64_F64_VAR;
		op_handlers[QB_MDET_F64_F64_ELV] = &&label_MDET_F64_F64_ELV;
		op_handlers[QB_MDET_F64_F64_ARR] = &&label_MDET_F64_F64_ARR;
		op_handlers[QB_DOT_F64_F64_F64_VAR] = &&label_DOT_F64_F64_F64_VAR;
		op_handlers[QB_DOT_F64_F64_F64_ELV] = &&label_DOT_F64_F64_F64_ELV;
		op_handlers[QB_DOT_F64_F64_F64_ARR] = &&label_DOT_F64_F64_F64_ARR;
		op_handlers[QB_LEN_F64_F64_VAR] = &&label_LEN_F64_F64_VAR;
		op_handlers[QB_LEN_F64_F64_ELV] = &&label_LEN_F64_F64_ELV;
		op_handlers[QB_LEN_F64_F64_ARR] = &&label_LEN_F64_F64_ARR;
		op_handlers[QB_DIS_F64_F64_F64_VAR] = &&label_DIS_F64_F64_F64_VAR;
		op_handlers[QB_DIS_F64_F64_F64_ELV] = &&label_DIS_F64_F64_F64_ELV;
		op_handlers[QB_DIS_F64_F64_F64_ARR] = &&label_DIS_F64_F64_F64_ARR;
		op_handlers[QB_NORM_F64_F64] = &&label_NORM_F64_F64;
		op_handlers[QB_NORM_F64_F64_ARR] = &&label_NORM_F64_F64_ARR;
		op_handlers[QB_FORE_F64_F64_F64] = &&label_FORE_F64_F64_F64;
		op_handlers[QB_FORE_F64_F64_F64_ARR] = &&label_FORE_F64_F64_F64_ARR;
		op_handlers[QB_REFL_F64_F64_F64] = &&label_REFL_F64_F64_F64;
		op_handlers[QB_REFL_F64_F64_F64_ARR] = &&label_REFL_F64_F64_F64_ARR;
		op_handlers[QB_REFR_F64_F64_F64_F64] = &&label_REFR_F64_F64_F64_F64;
		op_handlers[QB_REFR_F64_F64_F64_F64_ARR] = &&label_REFR_F64_F64_F64_F64_ARR;
		op_handlers[QB_CABS_F64_F64] = &&label_CABS_F64_F64;
		op_handlers[QB_CABS_F64_F64_ARR] = &&label_CABS_F64_F64_ARR;
		op_handlers[QB_CARG_F64_F64] = &&label_CARG_F64_F64;
		op_handlers[QB_CARG_F64_F64_ARR] = &&label_CARG_F64_F64_ARR;
		op_handlers[QB_CMUL_F64_F64_F64] = &&label_CMUL_F64_F64_F64;
		op_handlers[QB_CMUL_F64_F64_F64_ARR] = &&label_CMUL_F64_F64_F64_ARR;
		op_handlers[QB_CDIV_F64_F64_F64] = &&label_CDIV_F64_F64_F64;
		op_handlers[QB_CDIV_F64_F64_F64_ARR] = &&label_CDIV_F64_F64_F64_ARR;
		op_handlers[QB_CEXP_F64_F64] = &&label_CEXP_F64_F64;
		op_handlers[QB_CEXP_F64_F64_ARR] = &&label_CEXP_F64_F64_ARR;
		op_handlers[QB_CLOG_F64_F64] = &&label_CLOG_F64_F64;
		op_handlers[QB_CLOG_F64_F64_ARR] = &&label_CLOG_F64_F64_ARR;
		op_handlers[QB_CSQRT_F64_F64] = &&label_CSQRT_F64_F64;
		op_handlers[QB_CSQRT_F64_F64_ARR] = &&label_CSQRT_F64_F64_ARR;
		op_handlers[QB_CPOW_F64_F64_F64] = &&label_CPOW_F64_F64_F64;
		op_handlers[QB_CPOW_F64_F64_F64_ARR] = &&label_CPOW_F64_F64_F64_ARR;
		op_handlers[QB_CSIN_F64_F64] = &&label_CSIN_F64_F64;
		op_handlers[QB_CSIN_F64_F64_ARR] = &&label_CSIN_F64_F64_ARR;
		op_handlers[QB_CCOS_F64_F64] = &&label_CCOS_F64_F64;
		op_handlers[QB_CCOS_F64_F64_ARR] = &&label_CCOS_F64_F64_ARR;
		op_handlers[QB_CTAN_F64_F64] = &&label_CTAN_F64_F64;
		op_handlers[QB_CTAN_F64_F64_ARR] = &&label_CTAN_F64_F64_ARR;
		op_handlers[QB_CSINH_F64_F64] = &&label_CSINH_F64_F64;
		op_handlers[QB_CSINH_F64_F64_ARR] = &&label_CSINH_F64_F64_ARR;
		op_handlers[QB_CCOSH_F64_F64] = &&label_CCOSH_F64_F64;
		op_handlers[QB_CCOSH_F64_F64_ARR] = &&label_CCOSH_F64_F64_ARR;
		op_handlers[QB_CTANH_F64_F64] = &&label_CTANH_F64_F64;
		op_handlers[QB_CTANH_F64_F64_ARR] = &&label_CTANH_F64_F64_ARR;
		op_handlers[QB_EXT_U32] = &&label_EXT_U32;
	}
	
}

void *op_handlers[QB_OPCODE_COUNT];
#if NATIVE_COMPILE_ENABLED && ZEND_DEBUG
#include "qb_native_proc_debug.c"
#ifdef HAVE_NATIVE_PROC_RECORDS
qb_native_proc_record *native_proc_table = native_proc_records;
uint32_t native_proc_table_size = sizeof(native_proc_records) / sizeof(qb_native_proc_record);
#else
qb_native_proc_record *native_proc_table = NULL;
uint32_t native_proc_table_size = 0;
#endif
#endif
