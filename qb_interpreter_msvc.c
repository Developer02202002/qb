/*
  +----------------------------------------------------------------------+
  | PHP Version 5                                                        |
  +----------------------------------------------------------------------+
  | Copyright (c) 1997-2012 The PHP Group                                |
  +----------------------------------------------------------------------+
  | This source file is subject to version 3.01 of the PHP license,      |
  | that is bundled with this package in the file LICENSE, and is        |
  | available through the world-wide-web at the following url:           |
  | http://www.php.net/license/3_01.txt                                  |
  | If you did not receive a copy of the PHP license and are unable to   |
  | obtain it through the world-wide-web, please send a note to          |
  | license@php.net so we can mail you a copy immediately.               |
  +----------------------------------------------------------------------+
  | Author: Chung Leong <cleong@cal.berkeley.edu>                        |
  +----------------------------------------------------------------------+
*/

/* $Id$ */

#pragma pack(push,1)

typedef struct qb_instruction_0 {
	void *next_handler;
} qb_instruction_0;

typedef struct qb_instruction_1 {
	void *next_handler;
	uint32_t operand1;
} qb_instruction_1;

typedef struct qb_instruction_1_lineno {
	void *next_handler;
	uint32_t operand1;
	uint32_t line_number;
} qb_instruction_1_lineno;

typedef struct qb_instruction_2 {
	void *next_handler;
	uint32_t operand1;
	uint32_t operand2;
} qb_instruction_2;

typedef struct qb_instruction_2_lineno {
	void *next_handler;
	uint32_t operand1;
	uint32_t operand2;
	uint32_t line_number;
} qb_instruction_2_lineno;

typedef struct qb_instruction_3 {
	void *next_handler;
	uint32_t operand1;
	uint32_t operand2;
	uint32_t operand3;
} qb_instruction_3;

typedef struct qb_instruction_3_lineno {
	void *next_handler;
	uint32_t operand1;
	uint32_t operand2;
	uint32_t operand3;
	uint32_t line_number;
} qb_instruction_3_lineno;

typedef struct qb_instruction_4 {
	void *next_handler;
	uint32_t operand1;
	uint32_t operand2;
	uint32_t operand3;
	uint32_t operand4;
} qb_instruction_4;

typedef struct qb_instruction_4_lineno {
	void *next_handler;
	uint32_t operand1;
	uint32_t operand2;
	uint32_t operand3;
	uint32_t operand4;
	uint32_t line_number;
} qb_instruction_4_lineno;

typedef struct qb_instruction_5_lineno {
	void *next_handler;
	uint32_t operand1;
	uint32_t operand2;
	uint32_t operand3;
	uint32_t operand4;
	uint32_t operand5;
	uint32_t line_number;
} qb_instruction_5_lineno;

typedef struct qb_instruction_6_lineno {
	void *next_handler;
	uint32_t operand1;
	uint32_t operand2;
	uint32_t operand3;
	uint32_t operand4;
	uint32_t operand5;
	uint32_t operand6;
	uint32_t line_number;
} qb_instruction_6_lineno;

typedef struct qb_instruction_7_lineno {
	void *next_handler;
	uint32_t operand1;
	uint32_t operand2;
	uint32_t operand3;
	uint32_t operand4;
	uint32_t operand5;
	uint32_t operand6;
	uint32_t operand7;
	uint32_t line_number;
} qb_instruction_7_lineno;

typedef struct qb_instruction_branch_0 {
	void *next_handler1;
	int8_t *instruction_pointer1;
	void *next_handler2;
	int8_t *instruction_pointer2;
} qb_instruction_branch_0;

typedef struct qb_instruction_branch_1 {
	void *next_handler1;
	int8_t *instruction_pointer1;
	void *next_handler2;
	int8_t *instruction_pointer2;
	uint32_t operand1;
} qb_instruction_branch_1;

typedef struct qb_instruction_branch_1_lineno {
	void *next_handler1;
	int8_t *instruction_pointer1;
	void *next_handler2;
	int8_t *instruction_pointer2;
	uint32_t operand1;
	uint32_t line_number;
} qb_instruction_branch_1_lineno;

typedef struct qb_instruction_branch_2 {
	void *next_handler1;
	int8_t *instruction_pointer1;
	void *next_handler2;
	int8_t *instruction_pointer2;
	uint32_t operand1;
	uint32_t operand2;
} qb_instruction_branch_2;

typedef struct qb_instruction_branch_2_lineno {
	void *next_handler1;
	int8_t *instruction_pointer1;
	void *next_handler2;
	int8_t *instruction_pointer2;
	uint32_t operand1;
	uint32_t operand2;
	uint32_t line_number;
} qb_instruction_branch_2_lineno;

typedef struct qb_instruction_fcall {
	void *next_handler;
	uint16_t operand_size;
	uint16_t argument_count;
	uint32_t line_number;
	uint32_t symbol_index;
	uint32_t operands[1];
} qb_instruction_fcall;

typedef struct qb_instruction_jump_0 {
	void *next_handler;
	int8_t *instruction_pointer;
} qb_instruction_jump_0;

#pragma pack(pop)

extern void *op_handlers[];

static uint32_t zend_always_inline qb_decode_fcall_variable_operand(qb_interpreter_context *__restrict cxt, int8_t *__restrict *segments, uint32_t *__restrict operands) {
	uint32_t operand1 = operands[0];
	uint32_t var_operand2 = operands[1];
	uint32_t type = operand1 & 0x00FF;
	uint32_t flags = operand1 >> 16;
	uint32_t index = var_operand2;
	cxt->value_address.type = type;
	cxt->value_address.flags = flags;
	cxt->value_address.segment_offset = index << type_size_shifts[type];
	return 2;
}

static uint32_t ZEND_FASTCALL qb_decode_fcall_mix_operand(qb_interpreter_context *__restrict cxt, int8_t *__restrict *segments, uint32_t *__restrict operands) {
	uint32_t operand_count = 0;
	uint32_t operand1 = operands[operand_count++];
	uint32_t type = operand1 & 0x00FF;
	uint32_t dimension = (operand1 >> 8) & 0x00FF;
	uint32_t flags = operand1 >> 16;
	if(dimension > 0) {
		uint32_t vec_operand2 = operands[operand_count++];
		uint32_t selector = vec_operand2 & 0x00FF;
		uint32_t index_index = (vec_operand2 >> 8) & 0x03FF;
		uint32_t array_start_index = ((uint32_t *) segments[0])[index_index];
		uint32_t j;
		cxt->argument_address = &cxt->array_address;
		cxt->array_address.segment_selector = selector;
		cxt->array_address.segment_offset = array_start_index << type_size_shifts[type];
		cxt->array_address.type = type;
		cxt->array_address.flags = flags;
		cxt->array_address.dimension_count = dimension;
		for(j = 0; j < dimension; j++) {
			// the size and dimension always share the same set of flags
			uint32_t flags = operands[operand_count++];
			uint32_t dimension_index = operands[operand_count++];
			uint32_t size_index = operands[operand_count++];
			cxt->array_address.dimension_addresses[j]->flags = flags >> 16;
			cxt->array_address.dimension_addresses[j]->segment_offset = dimension_index * sizeof(uint32_t);
			cxt->array_address.array_size_addresses[j]->flags = flags >> 16;
			cxt->array_address.array_size_addresses[j]->segment_offset = size_index * sizeof(uint32_t);
		}
	} else {
		uint32_t elv_operand2 = operands[operand_count++];
		uint32_t selector = elv_operand2 & 0x00FF;
		uint32_t index_selector = (elv_operand2 >> 8) & 0x00FF;
		uint32_t index_index = elv_operand2 >> 16;
		uint32_t index = ((uint32_t *) segments[index_selector])[index_index];
		cxt->argument_address = &cxt->value_address;
		cxt->value_address.type = type;
		cxt->value_address.flags = flags;
		cxt->value_address.segment_selector = selector;
		cxt->value_address.segment_offset = index << type_size_shifts[type];
	}
	return operand_count;
}

static int32_t ZEND_FASTCALL qb_compare_array_S32(int32_t *op1_start, int32_t *op1_end, int32_t *op2_start, int32_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		int32_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

static int64_t ZEND_FASTCALL qb_rand_S64(qb_interpreter_context *cxt, int64_t lower_limit, uint64_t upper_limit) {
	USE_TSRM
	if(upper_limit > INT32_MAX || lower_limit < INT32_MIN) {
		int32_t number_h = php_rand(TSRMLS_C), upper_limit_h = upper_limit >> 32, lower_limit_h = lower_limit >> 32;
		uint32_t number_l = php_rand(TSRMLS_C), upper_limit_l = 0xFFFFFFFF, lower_limit_l = 0;
		number_h = lower_limit_h + (int32_t) ((double) ( (double) upper_limit_h - lower_limit_h + 1.0) * (number_h / (PHP_RAND_MAX + 1.0)));
		number_l = lower_limit_l + (uint32_t) ((double) ( (double) upper_limit_l - lower_limit_l + 1.0) * (number_l / (PHP_RAND_MAX + 1.0)));
		return (uint64_t) number_h << 32 | number_l;
	} else {
		int32_t number_l = php_rand(TSRMLS_C), upper_limit_l = (int32_t) upper_limit, lower_limit_l = (int32_t) lower_limit;
		number_l = lower_limit_l + (uint32_t) ((double) ( (double) upper_limit_l - lower_limit_l + 1.0) * (number_l / (PHP_RAND_MAX + 1.0)));
		return number_l;
	}
}

static uint64_t ZEND_FASTCALL qb_rand_U64(qb_interpreter_context *cxt, uint64_t lower_limit, uint64_t upper_limit) {
	USE_TSRM
	if(upper_limit > UINT32_MAX) {
		uint32_t number_h = php_rand(TSRMLS_C), upper_limit_h = upper_limit >> 32, lower_limit_h = lower_limit >> 32;
		uint32_t number_l = php_rand(TSRMLS_C), upper_limit_l = 0xFFFFFFFF, lower_limit_l = 0;
		number_h = lower_limit_h + (uint32_t) ((double) ( (double) upper_limit_h - lower_limit_h + 1.0) * (number_h / (PHP_RAND_MAX + 1.0)));
		number_l = lower_limit_l + (uint32_t) ((double) ( (double) upper_limit_l - lower_limit_l + 1.0) * (number_l / (PHP_RAND_MAX + 1.0)));
		return (uint64_t) number_h << 32 | number_l;
	} else {
		uint32_t number_l = php_rand(TSRMLS_C), upper_limit_l = (uint32_t) upper_limit, lower_limit_l = (uint32_t) lower_limit;
		number_l = lower_limit_l + (uint32_t) ((double) ( (double) upper_limit_l - lower_limit_l + 1.0) * (number_l / (PHP_RAND_MAX + 1.0)));
		return number_l;
	}
}

static int64_t ZEND_FASTCALL qb_mt_rand_S64(qb_interpreter_context *cxt, int64_t lower_limit, uint64_t upper_limit) {
	USE_TSRM
	if(upper_limit > INT32_MAX || lower_limit < INT32_MIN) {
		int32_t number_h = php_mt_rand(TSRMLS_C) >> 1, upper_limit_h = upper_limit >> 32, lower_limit_h = lower_limit >> 32;
		uint32_t number_l = php_mt_rand(TSRMLS_C) >> 1, upper_limit_l = 0xFFFFFFFF, lower_limit_l = 0;
		number_h = lower_limit_h + (int32_t) ((double) ( (double) upper_limit_h - lower_limit_h + 1.0) * (number_h / (PHP_MT_RAND_MAX + 1.0)));
		number_l = lower_limit_l + (uint32_t) ((double) ( (double) upper_limit_l - lower_limit_l + 1.0) * (number_l / (PHP_MT_RAND_MAX + 1.0)));
		return (uint64_t) number_h << 32 | number_l;
	} else {
		int32_t number_l = php_mt_rand(TSRMLS_C) >> 1, upper_limit_l = (int32_t) upper_limit, lower_limit_l = (int32_t) lower_limit;
		number_l = lower_limit_l + (uint32_t) ((double) ( (double) upper_limit_l - lower_limit_l + 1.0) * (number_l / (PHP_MT_RAND_MAX + 1.0)));
		return number_l;
	}
}

static uint64_t ZEND_FASTCALL qb_mt_rand_U64(qb_interpreter_context *cxt, uint64_t lower_limit, uint64_t upper_limit) {
	USE_TSRM
	if(upper_limit > UINT32_MAX) {
		uint32_t number_h = php_mt_rand(TSRMLS_C) >> 1, upper_limit_h = upper_limit >> 32, lower_limit_h = lower_limit >> 32;
		uint32_t number_l = php_mt_rand(TSRMLS_C) >> 1, upper_limit_l = 0xFFFFFFFF, lower_limit_l = 0;
		number_h = lower_limit_h + (uint32_t) ((double) ( (double) upper_limit_h - lower_limit_h + 1.0) * (number_h / (PHP_MT_RAND_MAX + 1.0)));
		number_l = lower_limit_l + (uint32_t) ((double) ( (double) upper_limit_l - lower_limit_l + 1.0) * (number_l / (PHP_MT_RAND_MAX + 1.0)));
		return (uint64_t) number_h << 32 | number_l;
	} else {
		uint32_t number_l = php_mt_rand(TSRMLS_C) >> 1, upper_limit_l = (uint32_t) upper_limit, lower_limit_l = (uint32_t) lower_limit;
		number_l = lower_limit_l + (uint32_t) ((double) ( (double) upper_limit_l - lower_limit_l + 1.0) * (number_l / (PHP_MT_RAND_MAX + 1.0)));
		return number_l;
	}
}

int qb_compare_ascending_S32(const void *a, const void *b) {
	if(*((int32_t *) a) < *((int32_t *) b)) {
		return -1;
	} else if(*((int32_t *) a) > *((int32_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_S32(qb_interpreter_context *cxt, int32_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(int32_t), qb_compare_ascending_S32);
}

int qb_compare_descending_S32(const void *a, const void *b) {
	if(*((int32_t *) a) < *((int32_t *) b)) {
		return 1;
	} else if(*((int32_t *) a) > *((int32_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_S32(qb_interpreter_context *cxt, int32_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(int32_t), qb_compare_descending_S32);
}

static int32_t ZEND_FASTCALL qb_calculate_array_min_S32(qb_interpreter_context *__restrict cxt, int32_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		int32_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static int32_t ZEND_FASTCALL qb_calculate_array_max_S32(qb_interpreter_context *__restrict cxt, int32_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		int32_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static int32_t ZEND_FASTCALL qb_calculate_array_product_S32(qb_interpreter_context *__restrict cxt, int32_t *elements, uint32_t count) {
	uint32_t i;
	int32_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static int32_t ZEND_FASTCALL qb_calculate_array_sum_S32(qb_interpreter_context *__restrict cxt, int32_t *elements, uint32_t count) {
	uint32_t i;
	int32_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_find_element_I32(int32_t *elements, uint32_t count, int32_t needle) {
	uint32_t i;
	for(i = 0; i < count; i++) {
		if(elements[i] == needle) {
			return i;
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_find_elements_I32(int32_t *elements, uint32_t count, int32_t *needle, uint32_t needle_width) {
	uint32_t i, j, k;
	for(i = 0, j = 0; j < count; i++, j += needle_width) {
		if(elements[j] == needle[0]) {
			for(k = 1; k < needle_width; k++) {
				if(elements[j + k] != needle[k]) {
					break;
				}
			}
			if(k == needle_width) {
				return i;
			}
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_compare_array_U32(uint32_t *op1_start, uint32_t *op1_end, uint32_t *op2_start, uint32_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		uint32_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

// Copyright (c) 2008-2010 Bjoern Hoehrmann <bjoern@hoehrmann.de>
// See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.

#define UTF8_ACCEPT 0
#define UTF8_REJECT 12

static const uint8_t utf8d[] = {
	  // The first part of the table maps bytes to character classes that
	  // to reduce the size of the transition table and create bitmasks.
	   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,  9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
	   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
	   8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
	  10,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3, 11,6,6,6,5,8,8,8,8,8,8,8,8,8,8,8,
	
	  // The second part is a transition table that maps a combination
	  // of a state of the automaton and a character class to a state.
	   0,12,24,36,60,96,84,12,12,12,48,72, 12,12,12,12,12,12,12,12,12,12,12,12,
	  12, 0,12,12,12,12,12, 0,12, 0,12,12, 12,24,12,12,12,12,12,24,12,24,12,12,
	  12,12,12,12,12,12,12,24,12,12,12,12, 12,24,12,12,12,12,12,12,12,24,12,12,
	  12,12,12,12,12,12,12,36,12,36,12,12, 12,36,12,12,12,12,12,36,12,36,12,12,
	  12,36,12,12,12,12,12,12,12,12,12,12, 
};

uint32_t inline
decode(uint32_t* state, uint32_t* codep, uint32_t byte) {
	  uint32_t type = utf8d[byte];
	
	  *codep = (*state != UTF8_ACCEPT) ?
	    (byte & 0x3fu) | (*codep << 6) :
	    (0xff >> type) & (byte);
	
	  *state = utf8d[256 + *state + type];
	  return *state;
}

uint32_t inline
encode(uint32_t c, uint8_t *bytes) {
		if (c < 0x80) {
				*bytes = c;
				return 1;
		} else {
				int32_t i;
				uint32_t len = c < 0x800 ? 1 : c < 0x10000 ? 2 : 3;
				*bytes++ = (-1 << (7 - len)) | (c >> len * 6);
				for (i = len; i > 0; --i, c >>= 6) {
						*bytes++ = ((c & 0x3f) | 0x80);
				}
				return len + 1;
		}
}

static void ZEND_FASTCALL qb_decode_utf8_U32(qb_interpreter_context *cxt, uint8_t *utf8_chars, uint32_t utf8_length, uint32_t *buffer) {
	uint32_t codepoint, state = 0, i, j;
	for(i = 0, j = 0; i < utf8_length; i++) {
		if(!decode(&state, &codepoint, utf8_chars[i])) {
			buffer[j++] = codepoint;
		}
	}
}

static uint32_t ZEND_FASTCALL qb_get_utf8_codepoint_count(qb_interpreter_context *cxt, uint8_t *utf8_chars, uint32_t utf8_length) {
	uint32_t codepoint, state = 0, count = 0, i;
	for(i = 0; i < utf8_length; i++) {
		if(!decode(&state, &codepoint, utf8_chars[i])) {
			count++;
		}
	}
	return count;
}

static void ZEND_FASTCALL qb_encode_utf8_U32(qb_interpreter_context *cxt, uint32_t *codepoints, uint32_t count, uint8_t *buffer) {
	uint32_t length = 0, i;
	for(i = 0; i < count; i++) {
		length += encode(codepoints[i], buffer + length);
	}
}

static uint32_t ZEND_FASTCALL qb_get_utf8_encoded_length_U32(qb_interpreter_context *cxt, uint32_t *codepoints, uint32_t count) {
	uint32_t length = 0, i;
	uint8_t buffer[4];
	for(i = 0; i < count; i++) {
		length += encode(codepoints[i], buffer);
	}
	return length;
}

int qb_compare_ascending_U32(const void *a, const void *b) {
	if(*((uint32_t *) a) < *((uint32_t *) b)) {
		return -1;
	} else if(*((uint32_t *) a) > *((uint32_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_U32(qb_interpreter_context *cxt, uint32_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(uint32_t), qb_compare_ascending_U32);
}

int qb_compare_descending_U32(const void *a, const void *b) {
	if(*((uint32_t *) a) < *((uint32_t *) b)) {
		return 1;
	} else if(*((uint32_t *) a) > *((uint32_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_U32(qb_interpreter_context *cxt, uint32_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(uint32_t), qb_compare_descending_U32);
}

static uint32_t ZEND_FASTCALL qb_calculate_array_min_U32(qb_interpreter_context *__restrict cxt, uint32_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		uint32_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static uint32_t ZEND_FASTCALL qb_calculate_array_max_U32(qb_interpreter_context *__restrict cxt, uint32_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		uint32_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static uint32_t ZEND_FASTCALL qb_calculate_array_product_U32(qb_interpreter_context *__restrict cxt, uint32_t *elements, uint32_t count) {
	uint32_t i;
	uint32_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static uint32_t ZEND_FASTCALL qb_calculate_array_sum_U32(qb_interpreter_context *__restrict cxt, uint32_t *elements, uint32_t count) {
	uint32_t i;
	uint32_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_compare_array_S08(int8_t *op1_start, int8_t *op1_end, int8_t *op2_start, int8_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		int8_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

int qb_compare_ascending_S08(const void *a, const void *b) {
	if(*((int8_t *) a) < *((int8_t *) b)) {
		return -1;
	} else if(*((int8_t *) a) > *((int8_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_S08(qb_interpreter_context *cxt, int8_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(int8_t), qb_compare_ascending_S08);
}

int qb_compare_descending_S08(const void *a, const void *b) {
	if(*((int8_t *) a) < *((int8_t *) b)) {
		return 1;
	} else if(*((int8_t *) a) > *((int8_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_S08(qb_interpreter_context *cxt, int8_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(int8_t), qb_compare_descending_S08);
}

static int8_t ZEND_FASTCALL qb_calculate_array_min_S08(qb_interpreter_context *__restrict cxt, int8_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		int8_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static int8_t ZEND_FASTCALL qb_calculate_array_max_S08(qb_interpreter_context *__restrict cxt, int8_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		int8_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static int8_t ZEND_FASTCALL qb_calculate_array_product_S08(qb_interpreter_context *__restrict cxt, int8_t *elements, uint32_t count) {
	uint32_t i;
	int8_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static int8_t ZEND_FASTCALL qb_calculate_array_sum_S08(qb_interpreter_context *__restrict cxt, int8_t *elements, uint32_t count) {
	uint32_t i;
	int8_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_find_element_I08(int8_t *elements, uint32_t count, int8_t needle) {
	uint32_t i;
	for(i = 0; i < count; i++) {
		if(elements[i] == needle) {
			return i;
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_find_elements_I08(int8_t *elements, uint32_t count, int8_t *needle, uint32_t needle_width) {
	uint32_t i, j, k;
	for(i = 0, j = 0; j < count; i++, j += needle_width) {
		if(elements[j] == needle[0]) {
			for(k = 1; k < needle_width; k++) {
				if(elements[j + k] != needle[k]) {
					break;
				}
			}
			if(k == needle_width) {
				return i;
			}
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_compare_array_U08(uint8_t *op1_start, uint8_t *op1_end, uint8_t *op2_start, uint8_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		uint8_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

int qb_compare_ascending_U08(const void *a, const void *b) {
	if(*((uint8_t *) a) < *((uint8_t *) b)) {
		return -1;
	} else if(*((uint8_t *) a) > *((uint8_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_U08(qb_interpreter_context *cxt, uint8_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(uint8_t), qb_compare_ascending_U08);
}

int qb_compare_descending_U08(const void *a, const void *b) {
	if(*((uint8_t *) a) < *((uint8_t *) b)) {
		return 1;
	} else if(*((uint8_t *) a) > *((uint8_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_U08(qb_interpreter_context *cxt, uint8_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(uint8_t), qb_compare_descending_U08);
}

static uint8_t ZEND_FASTCALL qb_calculate_array_min_U08(qb_interpreter_context *__restrict cxt, uint8_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		uint8_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static uint8_t ZEND_FASTCALL qb_calculate_array_max_U08(qb_interpreter_context *__restrict cxt, uint8_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		uint8_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static uint8_t ZEND_FASTCALL qb_calculate_array_product_U08(qb_interpreter_context *__restrict cxt, uint8_t *elements, uint32_t count) {
	uint32_t i;
	uint8_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static uint8_t ZEND_FASTCALL qb_calculate_array_sum_U08(qb_interpreter_context *__restrict cxt, uint8_t *elements, uint32_t count) {
	uint32_t i;
	uint8_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_compare_array_S16(int16_t *op1_start, int16_t *op1_end, int16_t *op2_start, int16_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		int16_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

int qb_compare_ascending_S16(const void *a, const void *b) {
	if(*((int16_t *) a) < *((int16_t *) b)) {
		return -1;
	} else if(*((int16_t *) a) > *((int16_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_S16(qb_interpreter_context *cxt, int16_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(int16_t), qb_compare_ascending_S16);
}

int qb_compare_descending_S16(const void *a, const void *b) {
	if(*((int16_t *) a) < *((int16_t *) b)) {
		return 1;
	} else if(*((int16_t *) a) > *((int16_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_S16(qb_interpreter_context *cxt, int16_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(int16_t), qb_compare_descending_S16);
}

static int16_t ZEND_FASTCALL qb_calculate_array_min_S16(qb_interpreter_context *__restrict cxt, int16_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		int16_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static int16_t ZEND_FASTCALL qb_calculate_array_max_S16(qb_interpreter_context *__restrict cxt, int16_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		int16_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static int16_t ZEND_FASTCALL qb_calculate_array_product_S16(qb_interpreter_context *__restrict cxt, int16_t *elements, uint32_t count) {
	uint32_t i;
	int16_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static int16_t ZEND_FASTCALL qb_calculate_array_sum_S16(qb_interpreter_context *__restrict cxt, int16_t *elements, uint32_t count) {
	uint32_t i;
	int16_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_find_element_I16(int16_t *elements, uint32_t count, int16_t needle) {
	uint32_t i;
	for(i = 0; i < count; i++) {
		if(elements[i] == needle) {
			return i;
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_find_elements_I16(int16_t *elements, uint32_t count, int16_t *needle, uint32_t needle_width) {
	uint32_t i, j, k;
	for(i = 0, j = 0; j < count; i++, j += needle_width) {
		if(elements[j] == needle[0]) {
			for(k = 1; k < needle_width; k++) {
				if(elements[j + k] != needle[k]) {
					break;
				}
			}
			if(k == needle_width) {
				return i;
			}
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_compare_array_U16(uint16_t *op1_start, uint16_t *op1_end, uint16_t *op2_start, uint16_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		uint16_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

static void ZEND_FASTCALL qb_decode_utf8_U16(qb_interpreter_context *cxt, uint8_t *utf8_chars, uint32_t utf8_length, uint16_t *buffer) {
	uint32_t codepoint, state = 0, i, j;
	for(i = 0, j = 0; i < utf8_length; i++) {
		if(!decode(&state, &codepoint, utf8_chars[i])) {
			buffer[j++] = codepoint;
		}
	}
}

static void ZEND_FASTCALL qb_encode_utf8_U16(qb_interpreter_context *cxt, uint16_t *codepoints, uint32_t count, uint8_t *buffer) {
	uint32_t length = 0, i;
	for(i = 0; i < count; i++) {
		length += encode(codepoints[i], buffer + length);
	}
}

static uint32_t ZEND_FASTCALL qb_get_utf8_encoded_length_U16(qb_interpreter_context *cxt, uint16_t *codepoints, uint32_t count) {
	uint32_t length = 0, i;
	uint8_t buffer[4];
	for(i = 0; i < count; i++) {
		length += encode(codepoints[i], buffer);
	}
	return length;
}

int qb_compare_ascending_U16(const void *a, const void *b) {
	if(*((uint16_t *) a) < *((uint16_t *) b)) {
		return -1;
	} else if(*((uint16_t *) a) > *((uint16_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_U16(qb_interpreter_context *cxt, uint16_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(uint16_t), qb_compare_ascending_U16);
}

int qb_compare_descending_U16(const void *a, const void *b) {
	if(*((uint16_t *) a) < *((uint16_t *) b)) {
		return 1;
	} else if(*((uint16_t *) a) > *((uint16_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_U16(qb_interpreter_context *cxt, uint16_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(uint16_t), qb_compare_descending_U16);
}

static uint16_t ZEND_FASTCALL qb_calculate_array_min_U16(qb_interpreter_context *__restrict cxt, uint16_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		uint16_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static uint16_t ZEND_FASTCALL qb_calculate_array_max_U16(qb_interpreter_context *__restrict cxt, uint16_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		uint16_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static uint16_t ZEND_FASTCALL qb_calculate_array_product_U16(qb_interpreter_context *__restrict cxt, uint16_t *elements, uint32_t count) {
	uint32_t i;
	uint16_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static uint16_t ZEND_FASTCALL qb_calculate_array_sum_U16(qb_interpreter_context *__restrict cxt, uint16_t *elements, uint32_t count) {
	uint32_t i;
	uint16_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_compare_array_S64(int64_t *op1_start, int64_t *op1_end, int64_t *op2_start, int64_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		int64_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

int qb_compare_ascending_S64(const void *a, const void *b) {
	if(*((int64_t *) a) < *((int64_t *) b)) {
		return -1;
	} else if(*((int64_t *) a) > *((int64_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_S64(qb_interpreter_context *cxt, int64_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(int64_t), qb_compare_ascending_S64);
}

int qb_compare_descending_S64(const void *a, const void *b) {
	if(*((int64_t *) a) < *((int64_t *) b)) {
		return 1;
	} else if(*((int64_t *) a) > *((int64_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_S64(qb_interpreter_context *cxt, int64_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(int64_t), qb_compare_descending_S64);
}

static int64_t ZEND_FASTCALL qb_calculate_array_min_S64(qb_interpreter_context *__restrict cxt, int64_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		int64_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static int64_t ZEND_FASTCALL qb_calculate_array_max_S64(qb_interpreter_context *__restrict cxt, int64_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		int64_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static int64_t ZEND_FASTCALL qb_calculate_array_product_S64(qb_interpreter_context *__restrict cxt, int64_t *elements, uint32_t count) {
	uint32_t i;
	int64_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static int64_t ZEND_FASTCALL qb_calculate_array_sum_S64(qb_interpreter_context *__restrict cxt, int64_t *elements, uint32_t count) {
	uint32_t i;
	int64_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_find_element_I64(int64_t *elements, uint32_t count, int64_t needle) {
	uint32_t i;
	for(i = 0; i < count; i++) {
		if(elements[i] == needle) {
			return i;
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_find_elements_I64(int64_t *elements, uint32_t count, int64_t *needle, uint32_t needle_width) {
	uint32_t i, j, k;
	for(i = 0, j = 0; j < count; i++, j += needle_width) {
		if(elements[j] == needle[0]) {
			for(k = 1; k < needle_width; k++) {
				if(elements[j + k] != needle[k]) {
					break;
				}
			}
			if(k == needle_width) {
				return i;
			}
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_compare_array_U64(uint64_t *op1_start, uint64_t *op1_end, uint64_t *op2_start, uint64_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		uint64_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

int qb_compare_ascending_U64(const void *a, const void *b) {
	if(*((uint64_t *) a) < *((uint64_t *) b)) {
		return -1;
	} else if(*((uint64_t *) a) > *((uint64_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_U64(qb_interpreter_context *cxt, uint64_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(uint64_t), qb_compare_ascending_U64);
}

int qb_compare_descending_U64(const void *a, const void *b) {
	if(*((uint64_t *) a) < *((uint64_t *) b)) {
		return 1;
	} else if(*((uint64_t *) a) > *((uint64_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_U64(qb_interpreter_context *cxt, uint64_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(uint64_t), qb_compare_descending_U64);
}

static uint64_t ZEND_FASTCALL qb_calculate_array_min_U64(qb_interpreter_context *__restrict cxt, uint64_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		uint64_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static uint64_t ZEND_FASTCALL qb_calculate_array_max_U64(qb_interpreter_context *__restrict cxt, uint64_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		uint64_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static uint64_t ZEND_FASTCALL qb_calculate_array_product_U64(qb_interpreter_context *__restrict cxt, uint64_t *elements, uint32_t count) {
	uint32_t i;
	uint64_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static uint64_t ZEND_FASTCALL qb_calculate_array_sum_U64(qb_interpreter_context *__restrict cxt, uint64_t *elements, uint32_t count) {
	uint32_t i;
	uint64_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_compare_array_F32(float32_t *op1_start, float32_t *op1_end, float32_t *op2_start, float32_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		float32_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

int qb_compare_ascending_F32(const void *a, const void *b) {
	if(*((float32_t *) a) < *((float32_t *) b)) {
		return -1;
	} else if(*((float32_t *) a) > *((float32_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_F32(qb_interpreter_context *cxt, float32_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(float32_t), qb_compare_ascending_F32);
}

int qb_compare_descending_F32(const void *a, const void *b) {
	if(*((float32_t *) a) < *((float32_t *) b)) {
		return 1;
	} else if(*((float32_t *) a) > *((float32_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_F32(qb_interpreter_context *cxt, float32_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(float32_t), qb_compare_descending_F32);
}

static float32_t ZEND_FASTCALL qb_calculate_array_min_F32(qb_interpreter_context *__restrict cxt, float32_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		float32_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static float32_t ZEND_FASTCALL qb_calculate_array_max_F32(qb_interpreter_context *__restrict cxt, float32_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		float32_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static float32_t ZEND_FASTCALL qb_calculate_array_product_F32(qb_interpreter_context *__restrict cxt, float32_t *elements, uint32_t count) {
	uint32_t i;
	float32_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static float32_t ZEND_FASTCALL qb_calculate_array_sum_F32(qb_interpreter_context *__restrict cxt, float32_t *elements, uint32_t count) {
	uint32_t i;
	float32_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_find_element_F32(float32_t *elements, uint32_t count, float32_t needle) {
	uint32_t i;
	for(i = 0; i < count; i++) {
		if(elements[i] == needle) {
			return i;
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_find_elements_F32(float32_t *elements, uint32_t count, float32_t *needle, uint32_t needle_width) {
	uint32_t i, j, k;
	for(i = 0, j = 0; j < count; i++, j += needle_width) {
		if(elements[j] == needle[0]) {
			for(k = 1; k < needle_width; k++) {
				if(elements[j + k] != needle[k]) {
					break;
				}
			}
			if(k == needle_width) {
				return i;
			}
		}
	}
	return -1;
}

static void ZEND_FASTCALL qb_sample_nearest_F32(qb_interpreter_context *__restrict cxt, float32_t *__restrict pixels, uint32_t width, uint32_t height, float32_t x, float32_t y, float32_t *__restrict res_ptr) {
	int32_t ix = qb_quick_floor(x);
	int32_t iy = qb_quick_floor(y);
	if(((uint32_t) ix < width) && ((uint32_t) iy < height)) {
		uint32_t index = ((iy * width) + ix) * 4;
		res_ptr[0] = pixels[index + 0];
		res_ptr[1] = pixels[index + 1];
		res_ptr[2] = pixels[index + 2];
		res_ptr[3] = pixels[index + 3];
	} else {
		res_ptr[0] = res_ptr[1] = res_ptr[2] = res_ptr[3] = 0;
	}
}

static void ZEND_FASTCALL qb_sample_bilinear_F32(qb_interpreter_context *__restrict cxt, float32_t *__restrict pixels, uint32_t width, uint32_t height, float32_t x, float32_t y, float32_t *__restrict res_ptr) {
	int32_t ix = qb_quick_floor(x - 0.5);
	int32_t iy = qb_quick_floor(y - 0.5);
	float32_t fx = (x - (float32_t) 0.5) - (float32_t) ix;
	float32_t fy = (y - (float32_t) 0.5) - (float32_t) iy;
	if(fx == 0 && fy == 0) {
		if(((uint32_t) ix < width) && ((uint32_t) iy < height)) {
			uint32_t index = ((iy * width) + ix) * 4;
			res_ptr[0]	= pixels[index + 0];
			res_ptr[1]	= pixels[index + 1];
			res_ptr[2]	= pixels[index + 2];
			res_ptr[3]	= pixels[index + 3];
		} else {
			res_ptr[0] = res_ptr[1] = res_ptr[2] = res_ptr[3] = 0;
		}
	} else { 
		float32_t fx1 = (float32_t) 1 - fx;
		float32_t fy1 = (float32_t) 1 - fy;
		float32_t w00 = fx1 * fy1;
		float32_t w10 = fx * fy1;
		float32_t w01 = fx1 * fy;
		float32_t w11 = fx * fy;
		float32_t p00[4], p01[4], p10[4], p11[4];
		if((((uint32_t) ix + 0) < width) && (((uint32_t) iy + 0) < height)) {
			uint32_t index = (((iy + 0) * width) + (ix + 0)) * 4;
			p00[0] = pixels[index + 0];
			p00[1] = pixels[index + 1];
			p00[2] = pixels[index + 2];
			p00[3] = pixels[index + 3];
		} else {
			p00[0] = p00[1] = p00[2] = p00[3] = 0;
		}
		if((((uint32_t) ix + 1) < width) && (((uint32_t) iy + 0) < height)) {
			uint32_t index = (((iy + 0) * width) + (ix + 1)) * 4;
			p10[0] = pixels[index + 0];
			p10[1] = pixels[index + 1];
			p10[2] = pixels[index + 2];
			p10[3] = pixels[index + 3];
		} else {
			p10[0] = p10[1] = p10[2] = p10[3] = 0;
		}
		if((((uint32_t) ix + 0) < width) && (((uint32_t) iy + 1) < height)) {
			uint32_t index = (((iy + 1) * width) + (ix + 0)) * 4;
			p01[0] = pixels[index + 0];
			p01[1] = pixels[index + 1];
			p01[2] = pixels[index + 2];
			p01[3] = pixels[index + 3];
		} else {
			p01[0] = p01[1] = p01[2] = p01[3] = 0;
		}
		if((((uint32_t) ix + 1) < width) && (((uint32_t) iy + 1) < height)) {
			uint32_t index = (((iy + 1) * width) + (ix + 1)) * 4;
			p11[0] = pixels[index + 0];
			p11[1] = pixels[index + 1];
			p11[2] = pixels[index + 2];
			p11[3] = pixels[index + 3];
		} else {
			p11[0] = p11[1] = p11[2] = p11[3] = 0;
		}
		res_ptr[0] = p00[0] * w00 + p10[0] * w10 + p01[0] * w01 + p11[0] * w11;
		res_ptr[1] = p00[1] * w00 + p10[1] * w10 + p01[1] * w01 + p11[1] * w11;
		res_ptr[2] = p00[2] * w00 + p10[2] * w10 + p01[2] * w01 + p11[2] * w11;
		res_ptr[3] = p00[3] * w00 + p10[3] * w10 + p01[3] * w01 + p11[3] * w11;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_F32(qb_interpreter_context *cxt, float32_t *m1, uint32_t m1_row, uint32_t m1_col, float32_t *m2, uint32_t m2_row, uint32_t m2_col, float32_t *res_ptr) {
	uint32_t i, j, k, p, q, res_index = 0;
	for(i = 0, q = 0; i < m1_row; ++i) {
		for(j = 0; j < m2_col; ++j) {
			float32_t dot_product = 0;
			for(p = 0, k = 0; p < m2_row; ++p, k += m2_col) {
				dot_product += m1[p + q] * m2[k + j];
			}
			res_ptr[res_index++] = dot_product;
		}
		q += m1_col;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_F32(qb_interpreter_context *cxt, float32_t *m, uint32_t m_row, uint32_t m_col, float32_t *v, uint32_t v_row, float32_t *res_ptr) {
	uint32_t i, j, k;
	for(i = 0, k = 0; i < m_row; ++i) {
		float32_t dot_product = 0;
		for(j = 0; j < m_col; ++j) {
			dot_product += m[k++] * v[j];
		}
		res_ptr[i] = dot_product;
	}
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_F32(qb_interpreter_context *cxt, float32_t *v, uint32_t v_col, float32_t *m, uint32_t m_row, uint32_t m_col, float32_t *res_ptr) {
	uint32_t i, j, k;
	for(i = 0; i < m_col; ++i) {
		float32_t dot_product = 0;
		for(j = 0, k = 0; j < m_row; ++j) {
			dot_product += v[j] * m[k + i];
			k += m_col;
		}
		res_ptr[i] = dot_product;
	}
}

static float32_t ZEND_FASTCALL qb_calculate_dot_product_F32(qb_interpreter_context *__restrict cxt, float32_t *v1, float32_t *v2, uint32_t size) {
	uint32_t i;
	float32_t sum = 0;
	for(i = 0; i < size; i++) {
		sum += v1[i] * v2[i];
	}
	return sum;
}

static float32_t ZEND_FASTCALL qb_calculate_array_length_F32(qb_interpreter_context *__restrict cxt, float32_t *v, uint32_t count) {
	uint32_t i;
	float32_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += v[i] * v[i];
	}
	return sqrtf(sum);
}

static float32_t ZEND_FASTCALL qb_calculate_array_distance_F32(qb_interpreter_context *__restrict cxt, float32_t *v1, float32_t *v2, uint32_t count) {
	uint32_t i;
	float32_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += (v1[i] - v2[i]) * (v1[i] - v2[i]);
	}
	return sqrtf(sum);
}

static void ZEND_FASTCALL qb_normalize_array_F32(qb_interpreter_context *__restrict cxt, float32_t *v, uint32_t count, float32_t *res_ptr) {
	uint32_t i;
	float32_t len = qb_calculate_array_length_F32(cxt, v, count);
	for(i = 0; i < count; i++) {
		res_ptr[i] = v[i] / len;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_4x4_F32(qb_interpreter_context *cxt, float32_t *m1, float32_t *m2, float32_t *res_ptr) {
	uint32_t q;
	for(q = 0; q < 12; q += 4) {
		float32_t dot_product0 = (m1[0 + q] * m2[0 + 0]) + (m1[1 + q] * m2[4 + 0]) + (m1[2 + q] * m2[8 + 0]) + (m1[3 + q] * m2[12 + 0]);
		float32_t dot_product1 = (m1[0 + q] * m2[0 + 1]) + (m1[1 + q] * m2[4 + 1]) + (m1[2 + q] * m2[8 + 1]) + (m1[3 + q] * m2[12 + 1]);
		float32_t dot_product2 = (m1[0 + q] * m2[0 + 2]) + (m1[1 + q] * m2[4 + 2]) + (m1[2 + q] * m2[8 + 2]) + (m1[3 + q] * m2[12 + 2]);
		float32_t dot_product3 = (m1[0 + q] * m2[0 + 3]) + (m1[1 + q] * m2[4 + 3]) + (m1[2 + q] * m2[8 + 3]) + (m1[3 + q] * m2[12 + 3]);
		res_ptr[q + 0] = dot_product0;
		res_ptr[q + 1] = dot_product1;
		res_ptr[q + 2] = dot_product2;
		res_ptr[q + 3] = dot_product3;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_4x4_F32(qb_interpreter_context *cxt, float32_t *m, float32_t *v, float32_t *res_ptr) {
	float32_t dot_product0 = (m[0 + 0] * v[0]) + (m[4 + 0] * v[1]) + (m[8 + 0] * v[2]) + (m[12 + 0] * v[3]);
	float32_t dot_product1 = (m[0 + 1] * v[0]) + (m[4 + 1] * v[1]) + (m[8 + 1] * v[2]) + (m[12 + 1] * v[3]);
	float32_t dot_product2 = (m[0 + 2] * v[0]) + (m[4 + 2] * v[1]) + (m[8 + 2] * v[2]) + (m[12 + 2] * v[3]);
	float32_t dot_product3 = (m[0 + 3] * v[0]) + (m[4 + 3] * v[1]) + (m[8 + 3] * v[2]) + (m[12 + 3] * v[3]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
	res_ptr[3] = dot_product3;
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_4x4_F32(qb_interpreter_context *cxt, float32_t *v, float32_t *m, float32_t *res_ptr) {
	float32_t dot_product0 = (v[0] * m[0 + 0]) + (v[1] * m[1 + 0]) + (v[2] * m[2 + 0]) + (v[3] * m[3 + 0]);
	float32_t dot_product1 = (v[0] * m[0 + 4]) + (v[1] * m[1 + 4]) + (v[2] * m[2 + 4]) + (v[3] * m[3 + 4]);
	float32_t dot_product2 = (v[0] * m[0 + 8]) + (v[1] * m[1 + 8]) + (v[2] * m[2 + 8]) + (v[3] * m[3 + 8]);
	float32_t dot_product3 = (v[0] * m[0 + 12]) + (v[1] * m[1 + 12]) + (v[2] * m[2 + 12]) + (v[3] * m[3 + 12]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
	res_ptr[3] = dot_product3;
}

static float32_t ZEND_FASTCALL qb_calculate_dot_product_4x_F32(qb_interpreter_context *__restrict cxt, float32_t *v1, float32_t *v2) {
	float32_t sum = (v1[0] * v2[0]) + (v1[1] * v2[1]) + (v1[2] * v2[2]) + (v1[3] * v2[3]);
	return sum;
}

static float32_t ZEND_FASTCALL qb_calculate_array_length_4x_F32(qb_interpreter_context *__restrict cxt, float32_t *v) {
	float32_t sum = (v[0] * v[0]) + (v[1] * v[1]) + (v[2] * v[2]) + (v[3] * v[3]);
	return sqrtf(sum);
}

static float32_t ZEND_FASTCALL qb_calculate_array_distance_4x_F32(qb_interpreter_context *__restrict cxt, float32_t *v1, float32_t *v2) {
	float32_t sum = (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]) + (v1[2] - v2[2]) * (v1[2] - v2[2]) + (v1[3] - v2[3]) * (v1[3] - v2[3]);
	return sqrtf(sum);
}

static void ZEND_FASTCALL qb_normalize_array_4x_F32(qb_interpreter_context *__restrict cxt, float32_t *v, float32_t *res_ptr) {
	float32_t len = qb_calculate_array_length_4x_F32(cxt, v);
	res_ptr[0] = v[0] / len;
	res_ptr[1] = v[1] / len;
	res_ptr[2] = v[2] / len;
	res_ptr[3] = v[3] / len;
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_3x3_F32(qb_interpreter_context *cxt, float32_t *m1, float32_t *m2, float32_t *res_ptr) {
	uint32_t q;
	for(q = 0; q < 9; q += 3) {
		float32_t dot_product0 = (m1[0 + q] * m2[0 + 0]) + (m1[1 + q] * m2[3 + 0]) + (m1[2 + q] * m2[6 + 0]);
		float32_t dot_product1 = (m1[0 + q] * m2[0 + 1]) + (m1[1 + q] * m2[3 + 1]) + (m1[2 + q] * m2[6 + 1]);
		float32_t dot_product2 = (m1[0 + q] * m2[0 + 2]) + (m1[1 + q] * m2[3 + 2]) + (m1[2 + q] * m2[6 + 2]);
		res_ptr[q + 0] = dot_product0;
		res_ptr[q + 1] = dot_product1;
		res_ptr[q + 2] = dot_product2;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_3x3_F32(qb_interpreter_context *cxt, float32_t *m, float32_t *v, float32_t *res_ptr) {
	float32_t dot_product0 = (m[0 + 0] * v[0]) + (m[3 + 0] * v[1]) + (m[6 + 0] * v[2]);
	float32_t dot_product1 = (m[0 + 1] * v[0]) + (m[3 + 1] * v[1]) + (m[6 + 1] * v[2]);
	float32_t dot_product2 = (m[0 + 2] * v[0]) + (m[3 + 2] * v[1]) + (m[6 + 2] * v[2]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_3x3_F32(qb_interpreter_context *cxt, float32_t *v, float32_t *m, float32_t *res_ptr) {
	float32_t dot_product0 = (v[0] * m[0 + 0]) + (v[1] * m[1 + 0]) + (v[2] * m[2 + 0]);
	float32_t dot_product1 = (v[0] * m[0 + 3]) + (v[1] * m[1 + 3]) + (v[2] * m[2 + 3]);
	float32_t dot_product2 = (v[0] * m[0 + 6]) + (v[1] * m[1 + 6]) + (v[2] * m[2 + 6]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_3x3_padded_F32(qb_interpreter_context *cxt, float32_t *m1, float32_t *m2, float32_t *res_ptr) {
	uint32_t q;
	for(q = 0; q < 12; q += 4) {
		float32_t dot_product0 = (m1[0 + q] * m2[0 + 0]) + (m1[1 + q] * m2[4 + 0]) + (m1[2 + q] * m2[8 + 0]);
		float32_t dot_product1 = (m1[0 + q] * m2[0 + 1]) + (m1[1 + q] * m2[4 + 1]) + (m1[2 + q] * m2[8 + 1]);
		float32_t dot_product2 = (m1[0 + q] * m2[0 + 2]) + (m1[1 + q] * m2[4 + 2]) + (m1[2 + q] * m2[8 + 2]);
		res_ptr[q + 0] = dot_product0;
		res_ptr[q + 1] = dot_product1;
		res_ptr[q + 2] = dot_product2;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_3x3_padded_F32(qb_interpreter_context *cxt, float32_t *m, float32_t *v, float32_t *res_ptr) {
	float32_t dot_product0 = (m[0 + 0] * v[0]) + (m[4 + 0] * v[1]) + (m[8 + 0] * v[2]);
	float32_t dot_product1 = (m[0 + 1] * v[0]) + (m[4 + 1] * v[1]) + (m[8 + 1] * v[2]);
	float32_t dot_product2 = (m[0 + 2] * v[0]) + (m[4 + 2] * v[1]) + (m[8 + 2] * v[2]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_3x3_padded_F32(qb_interpreter_context *cxt, float32_t *v, float32_t *m, float32_t *res_ptr) {
	float32_t dot_product0 = (v[0] * m[0 + 0]) + (v[1] * m[1 + 0]) + (v[2] * m[2 + 0]);
	float32_t dot_product1 = (v[0] * m[0 + 4]) + (v[1] * m[1 + 4]) + (v[2] * m[2 + 4]);
	float32_t dot_product2 = (v[0] * m[0 + 8]) + (v[1] * m[1 + 8]) + (v[2] * m[2 + 8]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
}

static float32_t ZEND_FASTCALL qb_calculate_dot_product_3x_F32(qb_interpreter_context *__restrict cxt, float32_t *v1, float32_t *v2) {
	float32_t sum = (v1[0] * v2[0]) + (v1[1] * v2[1]) + (v1[2] * v2[2]);
	return sum;
}

static float32_t ZEND_FASTCALL qb_calculate_array_length_3x_F32(qb_interpreter_context *__restrict cxt, float32_t *v) {
	float32_t sum = (v[0] * v[0]) + (v[1] * v[1]) + (v[2] * v[2]);
	return sqrtf(sum);
}

static float32_t ZEND_FASTCALL qb_calculate_array_distance_3x_F32(qb_interpreter_context *__restrict cxt, float32_t *v1, float32_t *v2) {
	float32_t sum = (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]) + (v1[2] - v2[2]) * (v1[2] - v2[2]);
	return sqrtf(sum);
}

static void ZEND_FASTCALL qb_normalize_array_3x_F32(qb_interpreter_context *__restrict cxt, float32_t *v, float32_t *res_ptr) {
	float32_t len = qb_calculate_array_length_3x_F32(cxt, v);
	res_ptr[0] = v[0] / len;
	res_ptr[1] = v[1] / len;
	res_ptr[2] = v[2] / len;
}

static void ZEND_FASTCALL qb_calculate_cross_product_F32(qb_interpreter_context *cxt, float32_t *v1, float32_t *v2, float32_t *res_ptr) {
	float32_t i = (v1[1] * v2[2]) - (v1[2] * v2[1]);
	float32_t j = (v1[2] * v2[0]) - (v1[0] * v2[2]);
	float32_t k = (v1[0] * v2[1]) - (v1[1] * v2[0]);
	res_ptr[0] = i;
	res_ptr[1] = j;
	res_ptr[2] = k;
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_2x2_F32(qb_interpreter_context *cxt, float32_t *m1, float32_t *m2, float32_t *res_ptr) {
	uint32_t q;
	for(q = 0; q < 4; q += 2) {
		float32_t dot_product0 = (m1[0 + q] * m2[0 + 0]) + (m1[1 + q] * m2[2 + 0]);
		float32_t dot_product1 = (m1[0 + q] * m2[0 + 1]) + (m1[1 + q] * m2[2 + 1]);
		res_ptr[q + 0] = dot_product0;
		res_ptr[q + 1] = dot_product1;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_2x2_F32(qb_interpreter_context *cxt, float32_t *m, float32_t *v, float32_t *res_ptr) {
	float32_t dot_product0 = (m[0 + 0] * v[0]) + (m[2 + 0] * v[1]);
	float32_t dot_product1 = (m[0 + 1] * v[0]) + (m[2 + 1] * v[1]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_2x2_F32(qb_interpreter_context *cxt, float32_t *v, float32_t *m, float32_t *res_ptr) {
	float32_t dot_product0 = (v[0] * m[0 + 0]) + (v[1] * m[1 + 0]);
	float32_t dot_product1 = (v[0] * m[0 + 2]) + (v[1] * m[1 + 2]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
}

static float32_t ZEND_FASTCALL qb_calculate_dot_product_2x_F32(qb_interpreter_context *__restrict cxt, float32_t *v1, float32_t *v2) {
	float32_t sum = (v1[0] * v2[0]) + (v1[1] * v2[1]);
	return sum;
}

static float32_t ZEND_FASTCALL qb_calculate_array_length_2x_F32(qb_interpreter_context *__restrict cxt, float32_t *v) {
	float32_t sum = (v[0] * v[0]) + (v[1] * v[1]);
	return sqrtf(sum);
}

static float32_t ZEND_FASTCALL qb_calculate_array_distance_2x_F32(qb_interpreter_context *__restrict cxt, float32_t *v1, float32_t *v2) {
	float32_t sum = (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	return sqrtf(sum);
}

static void ZEND_FASTCALL qb_normalize_array_2x_F32(qb_interpreter_context *__restrict cxt, float32_t *v, float32_t *res_ptr) {
	float32_t len = qb_calculate_array_length_2x_F32(cxt, v);
	res_ptr[0] = v[0] / len;
	res_ptr[1] = v[1] / len;
}

static int32_t ZEND_FASTCALL qb_compare_array_F64(float64_t *op1_start, float64_t *op1_end, float64_t *op2_start, float64_t *op2_end) {
	if(op1_start != op1_end && op2_start != op2_end) {
		float64_t *op1_ptr = op1_start, *op2_ptr = op2_start;
		int32_t end1 = 0, end2 = 0;
		while(1) {
			if(*op1_ptr > *op2_ptr) {
				return 1;
			} else if(*op1_ptr < *op2_ptr) {
				return -1;
			}
			op1_ptr++;
			if(op1_ptr == op1_end) {
				if(end2) {
					break;
				}
				op1_ptr = op1_start;
				end1 = 1;
			}
			op2_ptr++;
			if(op2_ptr == op2_end) {
				if(end1) {
					break;
				}
				op2_ptr = op2_start;
				end2 = 1;
			}
		}
	} else if(op2_start != op2_end) {
		return -1;
	} else if(op1_start != op1_end) {
		return 1;
	}
	return 0;
}

int qb_compare_ascending_F64(const void *a, const void *b) {
	if(*((float64_t *) a) < *((float64_t *) b)) {
		return -1;
	} else if(*((float64_t *) a) > *((float64_t *) b)) {
		return 1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_ascending_F64(qb_interpreter_context *cxt, float64_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(float64_t), qb_compare_ascending_F64);
}

int qb_compare_descending_F64(const void *a, const void *b) {
	if(*((float64_t *) a) < *((float64_t *) b)) {
		return 1;
	} else if(*((float64_t *) a) > *((float64_t *) b)) {
		return -1;
	} else {
		return 0;
	}
}

static void ZEND_FASTCALL qb_sort_descending_F64(qb_interpreter_context *cxt, float64_t *elements, uint32_t count) {
	qsort(elements, count, sizeof(float64_t), qb_compare_descending_F64);
}

static float64_t ZEND_FASTCALL qb_calculate_array_min_F64(qb_interpreter_context *__restrict cxt, float64_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		float64_t smallest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] < smallest) {
				smallest = elements[i];
			}
		}
		return smallest;
	} else {
		return 0;
	}
}

static float64_t ZEND_FASTCALL qb_calculate_array_max_F64(qb_interpreter_context *__restrict cxt, float64_t *elements, uint32_t count) {
	if(count > 0) {
		uint32_t i;
		float64_t biggest = elements[0];
		for(i = 1; i < count; i++) {
			if(elements[i] > biggest) {
				biggest = elements[i];
			}
		}
		return biggest;
	} else {
		return 0;
	}
}

static float64_t ZEND_FASTCALL qb_calculate_array_product_F64(qb_interpreter_context *__restrict cxt, float64_t *elements, uint32_t count) {
	uint32_t i;
	float64_t product = 1;
	for(i = 0; i < count; i++) {
		product *= elements[i];
	}
	return product;
}

static float64_t ZEND_FASTCALL qb_calculate_array_sum_F64(qb_interpreter_context *__restrict cxt, float64_t *elements, uint32_t count) {
	uint32_t i;
	float64_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += elements[i];
	}
	return sum;
}

static int32_t ZEND_FASTCALL qb_find_element_F64(float64_t *elements, uint32_t count, float64_t needle) {
	uint32_t i;
	for(i = 0; i < count; i++) {
		if(elements[i] == needle) {
			return i;
		}
	}
	return -1;
}

static int32_t ZEND_FASTCALL qb_find_elements_F64(float64_t *elements, uint32_t count, float64_t *needle, uint32_t needle_width) {
	uint32_t i, j, k;
	for(i = 0, j = 0; j < count; i++, j += needle_width) {
		if(elements[j] == needle[0]) {
			for(k = 1; k < needle_width; k++) {
				if(elements[j + k] != needle[k]) {
					break;
				}
			}
			if(k == needle_width) {
				return i;
			}
		}
	}
	return -1;
}

static void ZEND_FASTCALL qb_sample_nearest_F64(qb_interpreter_context *__restrict cxt, float64_t *__restrict pixels, uint32_t width, uint32_t height, float64_t x, float64_t y, float64_t *__restrict res_ptr) {
	int32_t ix = qb_quick_floor(x);
	int32_t iy = qb_quick_floor(y);
	if(((uint32_t) ix < width) && ((uint32_t) iy < height)) {
		uint32_t index = ((iy * width) + ix) * 4;
		res_ptr[0] = pixels[index + 0];
		res_ptr[1] = pixels[index + 1];
		res_ptr[2] = pixels[index + 2];
		res_ptr[3] = pixels[index + 3];
	} else {
		res_ptr[0] = res_ptr[1] = res_ptr[2] = res_ptr[3] = 0;
	}
}

static void ZEND_FASTCALL qb_sample_bilinear_F64(qb_interpreter_context *__restrict cxt, float64_t *__restrict pixels, uint32_t width, uint32_t height, float64_t x, float64_t y, float64_t *__restrict res_ptr) {
	int32_t ix = qb_quick_floor(x - 0.5);
	int32_t iy = qb_quick_floor(y - 0.5);
	float64_t fx = (x - (float64_t) 0.5) - (float64_t) ix;
	float64_t fy = (y - (float64_t) 0.5) - (float64_t) iy;
	if(fx == 0 && fy == 0) {
		if(((uint32_t) ix < width) && ((uint32_t) iy < height)) {
			uint32_t index = ((iy * width) + ix) * 4;
			res_ptr[0]	= pixels[index + 0];
			res_ptr[1]	= pixels[index + 1];
			res_ptr[2]	= pixels[index + 2];
			res_ptr[3]	= pixels[index + 3];
		} else {
			res_ptr[0] = res_ptr[1] = res_ptr[2] = res_ptr[3] = 0;
		}
	} else { 
		float64_t fx1 = (float64_t) 1 - fx;
		float64_t fy1 = (float64_t) 1 - fy;
		float64_t w00 = fx1 * fy1;
		float64_t w10 = fx * fy1;
		float64_t w01 = fx1 * fy;
		float64_t w11 = fx * fy;
		float64_t p00[4], p01[4], p10[4], p11[4];
		if((((uint32_t) ix + 0) < width) && (((uint32_t) iy + 0) < height)) {
			uint32_t index = (((iy + 0) * width) + (ix + 0)) * 4;
			p00[0] = pixels[index + 0];
			p00[1] = pixels[index + 1];
			p00[2] = pixels[index + 2];
			p00[3] = pixels[index + 3];
		} else {
			p00[0] = p00[1] = p00[2] = p00[3] = 0;
		}
		if((((uint32_t) ix + 1) < width) && (((uint32_t) iy + 0) < height)) {
			uint32_t index = (((iy + 0) * width) + (ix + 1)) * 4;
			p10[0] = pixels[index + 0];
			p10[1] = pixels[index + 1];
			p10[2] = pixels[index + 2];
			p10[3] = pixels[index + 3];
		} else {
			p10[0] = p10[1] = p10[2] = p10[3] = 0;
		}
		if((((uint32_t) ix + 0) < width) && (((uint32_t) iy + 1) < height)) {
			uint32_t index = (((iy + 1) * width) + (ix + 0)) * 4;
			p01[0] = pixels[index + 0];
			p01[1] = pixels[index + 1];
			p01[2] = pixels[index + 2];
			p01[3] = pixels[index + 3];
		} else {
			p01[0] = p01[1] = p01[2] = p01[3] = 0;
		}
		if((((uint32_t) ix + 1) < width) && (((uint32_t) iy + 1) < height)) {
			uint32_t index = (((iy + 1) * width) + (ix + 1)) * 4;
			p11[0] = pixels[index + 0];
			p11[1] = pixels[index + 1];
			p11[2] = pixels[index + 2];
			p11[3] = pixels[index + 3];
		} else {
			p11[0] = p11[1] = p11[2] = p11[3] = 0;
		}
		res_ptr[0] = p00[0] * w00 + p10[0] * w10 + p01[0] * w01 + p11[0] * w11;
		res_ptr[1] = p00[1] * w00 + p10[1] * w10 + p01[1] * w01 + p11[1] * w11;
		res_ptr[2] = p00[2] * w00 + p10[2] * w10 + p01[2] * w01 + p11[2] * w11;
		res_ptr[3] = p00[3] * w00 + p10[3] * w10 + p01[3] * w01 + p11[3] * w11;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_F64(qb_interpreter_context *cxt, float64_t *m1, uint32_t m1_row, uint32_t m1_col, float64_t *m2, uint32_t m2_row, uint32_t m2_col, float64_t *res_ptr) {
	uint32_t i, j, k, p, q, res_index = 0;
	for(i = 0, q = 0; i < m1_row; ++i) {
		for(j = 0; j < m2_col; ++j) {
			float64_t dot_product = 0;
			for(p = 0, k = 0; p < m2_row; ++p, k += m2_col) {
				dot_product += m1[p + q] * m2[k + j];
			}
			res_ptr[res_index++] = dot_product;
		}
		q += m1_col;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_F64(qb_interpreter_context *cxt, float64_t *m, uint32_t m_row, uint32_t m_col, float64_t *v, uint32_t v_row, float64_t *res_ptr) {
	uint32_t i, j, k;
	for(i = 0, k = 0; i < m_row; ++i) {
		float64_t dot_product = 0;
		for(j = 0; j < m_col; ++j) {
			dot_product += m[k++] * v[j];
		}
		res_ptr[i] = dot_product;
	}
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_F64(qb_interpreter_context *cxt, float64_t *v, uint32_t v_col, float64_t *m, uint32_t m_row, uint32_t m_col, float64_t *res_ptr) {
	uint32_t i, j, k;
	for(i = 0; i < m_col; ++i) {
		float64_t dot_product = 0;
		for(j = 0, k = 0; j < m_row; ++j) {
			dot_product += v[j] * m[k + i];
			k += m_col;
		}
		res_ptr[i] = dot_product;
	}
}

static float64_t ZEND_FASTCALL qb_calculate_dot_product_F64(qb_interpreter_context *__restrict cxt, float64_t *v1, float64_t *v2, uint32_t size) {
	uint32_t i;
	float64_t sum = 0;
	for(i = 0; i < size; i++) {
		sum += v1[i] * v2[i];
	}
	return sum;
}

static float64_t ZEND_FASTCALL qb_calculate_array_length_F64(qb_interpreter_context *__restrict cxt, float64_t *v, uint32_t count) {
	uint32_t i;
	float64_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += v[i] * v[i];
	}
	return sqrt(sum);
}

static float64_t ZEND_FASTCALL qb_calculate_array_distance_F64(qb_interpreter_context *__restrict cxt, float64_t *v1, float64_t *v2, uint32_t count) {
	uint32_t i;
	float64_t sum = 0;
	for(i = 0; i < count; i++) {
		sum += (v1[i] - v2[i]) * (v1[i] - v2[i]);
	}
	return sqrt(sum);
}

static void ZEND_FASTCALL qb_normalize_array_F64(qb_interpreter_context *__restrict cxt, float64_t *v, uint32_t count, float64_t *res_ptr) {
	uint32_t i;
	float64_t len = qb_calculate_array_length_F64(cxt, v, count);
	for(i = 0; i < count; i++) {
		res_ptr[i] = v[i] / len;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_4x4_F64(qb_interpreter_context *cxt, float64_t *m1, float64_t *m2, float64_t *res_ptr) {
	uint32_t q;
	for(q = 0; q < 12; q += 4) {
		float64_t dot_product0 = (m1[0 + q] * m2[0 + 0]) + (m1[1 + q] * m2[4 + 0]) + (m1[2 + q] * m2[8 + 0]) + (m1[3 + q] * m2[12 + 0]);
		float64_t dot_product1 = (m1[0 + q] * m2[0 + 1]) + (m1[1 + q] * m2[4 + 1]) + (m1[2 + q] * m2[8 + 1]) + (m1[3 + q] * m2[12 + 1]);
		float64_t dot_product2 = (m1[0 + q] * m2[0 + 2]) + (m1[1 + q] * m2[4 + 2]) + (m1[2 + q] * m2[8 + 2]) + (m1[3 + q] * m2[12 + 2]);
		float64_t dot_product3 = (m1[0 + q] * m2[0 + 3]) + (m1[1 + q] * m2[4 + 3]) + (m1[2 + q] * m2[8 + 3]) + (m1[3 + q] * m2[12 + 3]);
		res_ptr[q + 0] = dot_product0;
		res_ptr[q + 1] = dot_product1;
		res_ptr[q + 2] = dot_product2;
		res_ptr[q + 3] = dot_product3;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_4x4_F64(qb_interpreter_context *cxt, float64_t *m, float64_t *v, float64_t *res_ptr) {
	float64_t dot_product0 = (m[0 + 0] * v[0]) + (m[4 + 0] * v[1]) + (m[8 + 0] * v[2]) + (m[12 + 0] * v[3]);
	float64_t dot_product1 = (m[0 + 1] * v[0]) + (m[4 + 1] * v[1]) + (m[8 + 1] * v[2]) + (m[12 + 1] * v[3]);
	float64_t dot_product2 = (m[0 + 2] * v[0]) + (m[4 + 2] * v[1]) + (m[8 + 2] * v[2]) + (m[12 + 2] * v[3]);
	float64_t dot_product3 = (m[0 + 3] * v[0]) + (m[4 + 3] * v[1]) + (m[8 + 3] * v[2]) + (m[12 + 3] * v[3]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
	res_ptr[3] = dot_product3;
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_4x4_F64(qb_interpreter_context *cxt, float64_t *v, float64_t *m, float64_t *res_ptr) {
	float64_t dot_product0 = (v[0] * m[0 + 0]) + (v[1] * m[1 + 0]) + (v[2] * m[2 + 0]) + (v[3] * m[3 + 0]);
	float64_t dot_product1 = (v[0] * m[0 + 4]) + (v[1] * m[1 + 4]) + (v[2] * m[2 + 4]) + (v[3] * m[3 + 4]);
	float64_t dot_product2 = (v[0] * m[0 + 8]) + (v[1] * m[1 + 8]) + (v[2] * m[2 + 8]) + (v[3] * m[3 + 8]);
	float64_t dot_product3 = (v[0] * m[0 + 12]) + (v[1] * m[1 + 12]) + (v[2] * m[2 + 12]) + (v[3] * m[3 + 12]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
	res_ptr[3] = dot_product3;
}

static float64_t ZEND_FASTCALL qb_calculate_dot_product_4x_F64(qb_interpreter_context *__restrict cxt, float64_t *v1, float64_t *v2) {
	float64_t sum = (v1[0] * v2[0]) + (v1[1] * v2[1]) + (v1[2] * v2[2]) + (v1[3] * v2[3]);
	return sum;
}

static float64_t ZEND_FASTCALL qb_calculate_array_length_4x_F64(qb_interpreter_context *__restrict cxt, float64_t *v) {
	float64_t sum = (v[0] * v[0]) + (v[1] * v[1]) + (v[2] * v[2]) + (v[3] * v[3]);
	return sqrt(sum);
}

static float64_t ZEND_FASTCALL qb_calculate_array_distance_4x_F64(qb_interpreter_context *__restrict cxt, float64_t *v1, float64_t *v2) {
	float64_t sum = (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]) + (v1[2] - v2[2]) * (v1[2] - v2[2]) + (v1[3] - v2[3]) * (v1[3] - v2[3]);
	return sqrt(sum);
}

static void ZEND_FASTCALL qb_normalize_array_4x_F64(qb_interpreter_context *__restrict cxt, float64_t *v, float64_t *res_ptr) {
	float64_t len = qb_calculate_array_length_4x_F64(cxt, v);
	res_ptr[0] = v[0] / len;
	res_ptr[1] = v[1] / len;
	res_ptr[2] = v[2] / len;
	res_ptr[3] = v[3] / len;
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_3x3_F64(qb_interpreter_context *cxt, float64_t *m1, float64_t *m2, float64_t *res_ptr) {
	uint32_t q;
	for(q = 0; q < 9; q += 3) {
		float64_t dot_product0 = (m1[0 + q] * m2[0 + 0]) + (m1[1 + q] * m2[3 + 0]) + (m1[2 + q] * m2[6 + 0]);
		float64_t dot_product1 = (m1[0 + q] * m2[0 + 1]) + (m1[1 + q] * m2[3 + 1]) + (m1[2 + q] * m2[6 + 1]);
		float64_t dot_product2 = (m1[0 + q] * m2[0 + 2]) + (m1[1 + q] * m2[3 + 2]) + (m1[2 + q] * m2[6 + 2]);
		res_ptr[q + 0] = dot_product0;
		res_ptr[q + 1] = dot_product1;
		res_ptr[q + 2] = dot_product2;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_3x3_F64(qb_interpreter_context *cxt, float64_t *m, float64_t *v, float64_t *res_ptr) {
	float64_t dot_product0 = (m[0 + 0] * v[0]) + (m[3 + 0] * v[1]) + (m[6 + 0] * v[2]);
	float64_t dot_product1 = (m[0 + 1] * v[0]) + (m[3 + 1] * v[1]) + (m[6 + 1] * v[2]);
	float64_t dot_product2 = (m[0 + 2] * v[0]) + (m[3 + 2] * v[1]) + (m[6 + 2] * v[2]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_3x3_F64(qb_interpreter_context *cxt, float64_t *v, float64_t *m, float64_t *res_ptr) {
	float64_t dot_product0 = (v[0] * m[0 + 0]) + (v[1] * m[1 + 0]) + (v[2] * m[2 + 0]);
	float64_t dot_product1 = (v[0] * m[0 + 3]) + (v[1] * m[1 + 3]) + (v[2] * m[2 + 3]);
	float64_t dot_product2 = (v[0] * m[0 + 6]) + (v[1] * m[1 + 6]) + (v[2] * m[2 + 6]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_3x3_padded_F64(qb_interpreter_context *cxt, float64_t *m1, float64_t *m2, float64_t *res_ptr) {
	uint32_t q;
	for(q = 0; q < 12; q += 4) {
		float64_t dot_product0 = (m1[0 + q] * m2[0 + 0]) + (m1[1 + q] * m2[4 + 0]) + (m1[2 + q] * m2[8 + 0]);
		float64_t dot_product1 = (m1[0 + q] * m2[0 + 1]) + (m1[1 + q] * m2[4 + 1]) + (m1[2 + q] * m2[8 + 1]);
		float64_t dot_product2 = (m1[0 + q] * m2[0 + 2]) + (m1[1 + q] * m2[4 + 2]) + (m1[2 + q] * m2[8 + 2]);
		res_ptr[q + 0] = dot_product0;
		res_ptr[q + 1] = dot_product1;
		res_ptr[q + 2] = dot_product2;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_3x3_padded_F64(qb_interpreter_context *cxt, float64_t *m, float64_t *v, float64_t *res_ptr) {
	float64_t dot_product0 = (m[0 + 0] * v[0]) + (m[4 + 0] * v[1]) + (m[8 + 0] * v[2]);
	float64_t dot_product1 = (m[0 + 1] * v[0]) + (m[4 + 1] * v[1]) + (m[8 + 1] * v[2]);
	float64_t dot_product2 = (m[0 + 2] * v[0]) + (m[4 + 2] * v[1]) + (m[8 + 2] * v[2]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_3x3_padded_F64(qb_interpreter_context *cxt, float64_t *v, float64_t *m, float64_t *res_ptr) {
	float64_t dot_product0 = (v[0] * m[0 + 0]) + (v[1] * m[1 + 0]) + (v[2] * m[2 + 0]);
	float64_t dot_product1 = (v[0] * m[0 + 4]) + (v[1] * m[1 + 4]) + (v[2] * m[2 + 4]);
	float64_t dot_product2 = (v[0] * m[0 + 8]) + (v[1] * m[1 + 8]) + (v[2] * m[2 + 8]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
	res_ptr[2] = dot_product2;
}

static float64_t ZEND_FASTCALL qb_calculate_dot_product_3x_F64(qb_interpreter_context *__restrict cxt, float64_t *v1, float64_t *v2) {
	float64_t sum = (v1[0] * v2[0]) + (v1[1] * v2[1]) + (v1[2] * v2[2]);
	return sum;
}

static float64_t ZEND_FASTCALL qb_calculate_array_length_3x_F64(qb_interpreter_context *__restrict cxt, float64_t *v) {
	float64_t sum = (v[0] * v[0]) + (v[1] * v[1]) + (v[2] * v[2]);
	return sqrt(sum);
}

static float64_t ZEND_FASTCALL qb_calculate_array_distance_3x_F64(qb_interpreter_context *__restrict cxt, float64_t *v1, float64_t *v2) {
	float64_t sum = (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]) + (v1[2] - v2[2]) * (v1[2] - v2[2]);
	return sqrt(sum);
}

static void ZEND_FASTCALL qb_normalize_array_3x_F64(qb_interpreter_context *__restrict cxt, float64_t *v, float64_t *res_ptr) {
	float64_t len = qb_calculate_array_length_3x_F64(cxt, v);
	res_ptr[0] = v[0] / len;
	res_ptr[1] = v[1] / len;
	res_ptr[2] = v[2] / len;
}

static void ZEND_FASTCALL qb_calculate_cross_product_F64(qb_interpreter_context *cxt, float64_t *v1, float64_t *v2, float64_t *res_ptr) {
	float64_t i = (v1[1] * v2[2]) - (v1[2] * v2[1]);
	float64_t j = (v1[2] * v2[0]) - (v1[0] * v2[2]);
	float64_t k = (v1[0] * v2[1]) - (v1[1] * v2[0]);
	res_ptr[0] = i;
	res_ptr[1] = j;
	res_ptr[2] = k;
}

static void ZEND_FASTCALL qb_multiply_matrix_by_matrix_2x2_F64(qb_interpreter_context *cxt, float64_t *m1, float64_t *m2, float64_t *res_ptr) {
	uint32_t q;
	for(q = 0; q < 4; q += 2) {
		float64_t dot_product0 = (m1[0 + q] * m2[0 + 0]) + (m1[1 + q] * m2[2 + 0]);
		float64_t dot_product1 = (m1[0 + q] * m2[0 + 1]) + (m1[1 + q] * m2[2 + 1]);
		res_ptr[q + 0] = dot_product0;
		res_ptr[q + 1] = dot_product1;
	}
}

static void ZEND_FASTCALL qb_multiply_matrix_by_vector_2x2_F64(qb_interpreter_context *cxt, float64_t *m, float64_t *v, float64_t *res_ptr) {
	float64_t dot_product0 = (m[0 + 0] * v[0]) + (m[2 + 0] * v[1]);
	float64_t dot_product1 = (m[0 + 1] * v[0]) + (m[2 + 1] * v[1]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
}

static void ZEND_FASTCALL qb_multiply_vector_by_matrix_2x2_F64(qb_interpreter_context *cxt, float64_t *v, float64_t *m, float64_t *res_ptr) {
	float64_t dot_product0 = (v[0] * m[0 + 0]) + (v[1] * m[1 + 0]);
	float64_t dot_product1 = (v[0] * m[0 + 2]) + (v[1] * m[1 + 2]);
	res_ptr[0] = dot_product0;
	res_ptr[1] = dot_product1;
}

static float64_t ZEND_FASTCALL qb_calculate_dot_product_2x_F64(qb_interpreter_context *__restrict cxt, float64_t *v1, float64_t *v2) {
	float64_t sum = (v1[0] * v2[0]) + (v1[1] * v2[1]);
	return sum;
}

static float64_t ZEND_FASTCALL qb_calculate_array_length_2x_F64(qb_interpreter_context *__restrict cxt, float64_t *v) {
	float64_t sum = (v[0] * v[0]) + (v[1] * v[1]);
	return sqrt(sum);
}

static float64_t ZEND_FASTCALL qb_calculate_array_distance_2x_F64(qb_interpreter_context *__restrict cxt, float64_t *v1, float64_t *v2) {
	float64_t sum = (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	return sqrt(sum);
}

static void ZEND_FASTCALL qb_normalize_array_2x_F64(qb_interpreter_context *__restrict cxt, float64_t *v, float64_t *res_ptr) {
	float64_t len = qb_calculate_array_length_2x_F64(cxt, v);
	res_ptr[0] = v[0] / len;
	res_ptr[1] = v[1] / len;
}

static void ZEND_FASTCALL qb_run(qb_interpreter_context *__restrict cxt) {
#define op1	(*op1_ptr)
#define op2	(*op2_ptr)
#define op3	(*op3_ptr)
#define op4	(*op4_ptr)
#define op5	(*op5_ptr)
#define op6	(*op6_ptr)
#define res	(*res_ptr)
	
	if(cxt) {
		register void *__restrict op_handler;
		register int8_t *__restrict instruction_pointer;
		int8_t *__restrict segments[MAX_SEGMENT_COUNT];
		int8_t *__restrict segment0;
		int32_t segment_expandable[MAX_SEGMENT_COUNT];
		uint32_t segment_element_counts[MAX_SEGMENT_COUNT];
		char sprintf_buffer[64];
		uint32_t string_length;
		zend_bool *windows_timed_out_pointer = cxt->windows_timed_out_pointer;
		USE_TSRM
		
		{
			uint32_t i;
			instruction_pointer = cxt->function->instructions;
			op_handler = *((void **) instruction_pointer);
			instruction_pointer += sizeof(void *);
			// copy values from cxt onto the stack so they can be accessed without two second deferences
			for(i = 0; i < cxt->storage->segment_count; i++) {
				qb_memory_segment *segment = &cxt->storage->segments[i];
				segments[i] = segment->memory;
				segment_element_counts[i] = *segment->array_size_pointer;
				segment_expandable[i] = (segment->flags & QB_SEGMENT_EXPANDABLE);
				// set the pointers in the segment structure to local variables here so we can update
				// them as well when we expand the segment
				segment->stack_ref_memory = &segments[i];
				segment->stack_ref_element_count = &segment_element_counts[i];
			}
			// store pointer to segment 0 in a separate variable to enable better optimization
			// since segment 0 and 1 will never be enlarged, we don't have to worry about it changing
			segment0 = segments[0];
		}
		
		do {
			switch((int) op_handler) {
				case QB_NOP:
				op_handler = ((qb_instruction_0 *) instruction_pointer)->next_handler;
				{
				}
				instruction_pointer += sizeof(qb_instruction_0);
				break;
				
				case QB_JMP:
				op_handler = ((qb_instruction_jump_0 *) instruction_pointer)->next_handler;
				{
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
				}
				instruction_pointer = ((qb_instruction_jump_0 *) instruction_pointer)->instruction_pointer;
				break;
				
				case QB_RET:
				{
				}
				goto label_exit;
				
				case QB_EXIT_I32:
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					EG(exit_status) = op1;
					zend_bailout();
				}
				
				case QB_FCALL_VAR:
				op_handler = ((qb_instruction_fcall *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_fcall *) instruction_pointer)->line_number
					uint32_t symbol_index = ((qb_instruction_fcall *) instruction_pointer)->symbol_index;
					uint32_t argument_count = ((qb_instruction_fcall *) instruction_pointer)->argument_count;
					uint32_t *operands = ((qb_instruction_fcall *) instruction_pointer)->operands, *op;
					uint32_t i;
					zend_function *function = cxt->function->external_symbols[symbol_index]->pointer;
					qb_initialize_function_call(cxt, function, argument_count, PHP_LINE_NUMBER);
					cxt->argument_address = &cxt->value_address;
					cxt->value_address.segment_selector = QB_SELECTOR_VARIABLE;
					for(i = 0, op = operands; i < argument_count; i++) {
						op += qb_decode_fcall_variable_operand(cxt, segments, op);
						qb_copy_argument(cxt, i);
					}
					qb_execute_function_call(cxt);
					for(i = 0, op = operands; i < argument_count + 1; i++) {
						op += qb_decode_fcall_variable_operand(cxt, segments, op);
						qb_resync_argument(cxt, i);
					}
					qb_finalize_function_call(cxt);
					if(cxt->exception_encountered) {
						goto label_exit;
					}
					instruction_pointer += sizeof(((qb_instruction_fcall *) instruction_pointer)->next_handler) + ((qb_instruction_fcall *) instruction_pointer)->operand_size;
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_FCALL_MIX:
				op_handler = ((qb_instruction_fcall *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_fcall *) instruction_pointer)->line_number
					uint32_t symbol_index = ((qb_instruction_fcall *) instruction_pointer)->symbol_index;
					uint32_t argument_count = ((qb_instruction_fcall *) instruction_pointer)->argument_count;
					uint32_t *operands = ((qb_instruction_fcall *) instruction_pointer)->operands, *op;
					uint32_t i;
					zend_function *function = cxt->function->external_symbols[symbol_index]->pointer;
					qb_initialize_function_call(cxt, function, argument_count, PHP_LINE_NUMBER);
					for(i = 0, op = operands; i < argument_count; i++) {
						op += qb_decode_fcall_mix_operand(cxt, segments, op);
						qb_copy_argument(cxt, i);
					}
					qb_execute_function_call(cxt);
					for(i = 0, op = operands; i < argument_count + 1; i++) {
						op += qb_decode_fcall_mix_operand(cxt, segments, op);
						qb_resync_argument(cxt, i);
					}
					qb_finalize_function_call(cxt);
					if(cxt->exception_encountered) {
						goto label_exit;
					}
					instruction_pointer += sizeof(((qb_instruction_fcall *) instruction_pointer)->next_handler) + ((qb_instruction_fcall *) instruction_pointer)->operand_size;
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_INIT:
				op_handler = ((qb_instruction_branch_0 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					if(cxt->storage->flags & QB_STORAGE_STATIC_INITIALIZED) {
						condition = 1;
					} else {
						condition = 0;
						cxt->storage->flags |= QB_STORAGE_STATIC_INITIALIZED;
					}
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_0 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_0 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_0 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_T_I32_VAR:
				op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_branch_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_T_I32_ELC:
				op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_1_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_T_I32_ELV:
				op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_1_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_F_I32_VAR:
				op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_branch_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = !op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_F_I32_ELC:
				op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_1_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = !op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_F_I32_ELV:
				op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_1_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = !op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_EQ_I32_I32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_I32_I32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_EQ_I32_I32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I32_I32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_I32_I32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I32_I32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S32_S32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_S32_S32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S32_S32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S32_S32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_S32_S32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S32_S32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S32_S32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_S32_S32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S32_S32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S32_S32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_S32_S32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S32_S32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_I32_I32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 + op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_I32_I32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 - op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_S32_S32_S32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_S32_S32_S32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_S32_S32_S32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 % op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_I32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_I32_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = - op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I32_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_I32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int32_t *) segment0) + index1;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_I32_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						++res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int32_t *) segment0) + index1;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_I32_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						--res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_I32_I32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S32(op1_start, op1_end, op2_start, op2_end) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_I32_I32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S32(op1_start, op1_end, op2_start, op2_end) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S32_S32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_S32_S32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S32_S32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S32_S32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S32(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S32_S32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_S32_S32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S32_S32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S32_S32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S32(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_I32_I32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 == op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_I32_I32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 != op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_S32_S32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_S32_S32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NOT_SET_I32_I32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (!op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ANY_I32_I32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_end, *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = 0;
					while(op1_ptr != op1_end) {
						if(op1) {
							res = 1;
							break;
						}
						op1_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ANY_I32_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_end, *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = 0;
					while(op1_ptr != op1_end) {
						if(op1) {
							res = 1;
							break;
						}
						op1_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ANY_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_end, *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = 0;
					while(op1_ptr != op1_end) {
						if(op1) {
							res = 1;
							break;
						}
						op1_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ALL_I32_I32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_end, *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = 1;
					while(op1_ptr != op1_end) {
						if(!op1) {
							res = 0;
							break;
						}
						op1_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ALL_I32_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_end, *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = 1;
					while(op1_ptr != op1_end) {
						if(!op1) {
							res = 0;
							break;
						}
						op1_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ALL_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_end, *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = 1;
					while(op1_ptr != op1_end) {
						if(!op1) {
							res = 0;
							break;
						}
						op1_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_AND_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 & op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_AND_I32_I32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 & op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 | op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_OR_I32_I32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 | op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 ^ op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_XOR_I32_I32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 ^ op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_NOT_I32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = ~op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BW_NOT_I32_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = ~op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SHL_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_S32_S32_S32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 << op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_S32_S32_S32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 >> op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AND_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 && op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_OR_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = op1 || op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_XOR_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = !op1 != !op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NOT_I32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = !op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ISSET_I32_I32_ELV:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 >= segment_element_counts[selector1]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((int32_t *) segments[selector1]) + index1;
					}
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (op1_ptr) && (op1 != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_UNSET_I32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int32_t *) segment0) + index1;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I32_ELC:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elc_operand1, selector1, index1;
					
					elc_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I32_ELV:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					
					elv_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I32_ARR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					
					arr_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(res_start_index + res_count <= segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], res_start_index, res_count);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_MOV_I32_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I32_I08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int8_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I32_I16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int16_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S32_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S32_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S32_S32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (int32_t) abs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_S32_S32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) abs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) abs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S32_S32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) abs(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_S32_S32_S32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_S32_S32_S32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (int32_t) qb_rand_S64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_S32_S32_S32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = (int32_t) qb_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = (int32_t) qb_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) qb_rand_S64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (int32_t) qb_mt_rand_S64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_S32_S32_S32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = (int32_t) qb_mt_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + index3;
					
					res = (int32_t) qb_mt_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) qb_mt_rand_S64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_S32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId32, (int32_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_S32_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId32, (int32_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId32, (int32_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId32, (int32_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_S32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId32, (int32_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S32_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId32, (int32_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId32, (int32_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S32_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId32, (int32_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId32, (int32_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((int32_t *) &res) = op1;
#else
					{
						int32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I32_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((int32_t *) &res) = op1;
#else
					{
						int32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((int32_t *) &res) = op1;
#else
					{
						int32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int32_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((int32_t *) &res) = op1;
#else
					{
						int32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I32_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((int32_t *) &res) = op1;
#else
					{
						int32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((int32_t *) &res) = op1;
#else
					{
						int32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((int32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((int32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((int32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((int32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((int32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((int32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_S32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_S32(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_S32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_S32(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_S32_S32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = qb_calculate_array_min_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S32_S32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = qb_calculate_array_max_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S32_S32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = qb_calculate_array_product_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S32_S32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S32_S32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S32_S32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S32_S32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S32_S32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I32(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I32_I32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I32(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I32(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_I32(op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I32(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I32_I32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I32(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I32(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_I32(op1_ptr, op1_count, op2_ptr, op2_count) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_IF_LT_U32_U32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_U32_U32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_U32_U32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U32_U32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_U32_U32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U32_U32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U32_U32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_U32_U32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U32_U32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U32_U32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_U32_U32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U32_U32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_MUL_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint32_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_U32_U32_U32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint32_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_U32_U32_U32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint32_t *) segment0) + index3;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_U32_U32_U32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 % op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U32_U32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_U32_U32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U32_U32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U32_U32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_U32(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U32_U32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_U32_U32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U32_U32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U32_U32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_U32(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_U32_U32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_U32_U32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint32_t *) segment0) + index3;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_U32_U32_U32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 << op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint32_t *) segment0) + index3;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_U32_U32_U32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 >> op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_U32_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U32_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U32_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint32_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_U32_U32_U32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint32_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_U32_U32_U32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint32_t *) segment0) + index3;
					
					res = (uint32_t) qb_rand_U64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_U32_U32_U32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = (uint32_t) qb_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = (uint32_t) qb_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (uint32_t) qb_rand_U64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint32_t *) segment0) + index3;
					
					res = (uint32_t) qb_mt_rand_U64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_U32_U32_U32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = (uint32_t) qb_mt_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					res = (uint32_t) qb_mt_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (uint32_t) qb_mt_rand_U64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_UTF8_DEC_U08_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = qb_get_utf8_codepoint_count(cxt, op1_ptr, op1_count);
					if(string_length > res_count) {
						res_count = string_length;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + res_start_index;
					
					qb_decode_utf8_U32(cxt, op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UTF8_ENC_U32_U08:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = qb_get_utf8_encoded_length_U32(cxt, op1_ptr, op1_count);
					if(string_length > res_count) {
						res_count = string_length;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					qb_encode_utf8_U32(cxt, op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_U32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu32, (uint32_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_U32_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu32, (uint32_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu32, (uint32_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu32, (uint32_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_U32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu32, (uint32_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U32_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu32, (uint32_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu32, (uint32_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U32_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu32, (uint32_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu32, (uint32_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_U32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_U32(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_U32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_U32(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_U32_U32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint32_t *) segment0) + index2;
					
					res = qb_calculate_array_min_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U32_U32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint32_t *) segment0) + index2;
					
					res = qb_calculate_array_max_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U32_U32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint32_t *) segment0) + index2;
					
					res = qb_calculate_array_product_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U32_U32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint32_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U32_U32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U32_U32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U32_U32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U32_U32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_I08_I08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_I08_I08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_EQ_I08_I08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I08_I08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_I08_I08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I08_I08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S08_S08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_S08_S08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S08_S08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S08_S08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_S08_S08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S08_S08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S08_S08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_S08_S08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S08_S08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S08_S08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_S08_S08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S08_S08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_I08_I08_I08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 + op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_I08_I08_I08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 - op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_S08_S08_S08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_S08_S08_S08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_S08_S08_S08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 % op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_I08_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_I08_I08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I08_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I08_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = - op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I08_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I08_I08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I08_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I08_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_I08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int8_t *) segment0) + index1;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_I08_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I08_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I08_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						++res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int8_t *) segment0) + index1;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_I08_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I08_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I08_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						--res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_I08_I08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_I08_I08_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I08_I08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I08_I08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S08(op1_start, op1_end, op2_start, op2_end) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I08_I08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_I08_I08_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I08_I08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I08_I08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S08(op1_start, op1_end, op2_start, op2_end) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S08_S08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_S08_S08_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S08_S08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S08_S08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S08(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S08_S08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_S08_S08_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S08_S08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S08_S08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S08(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_I08_I08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 == op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_I08_I08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 != op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_S08_S08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_S08_S08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 & op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_AND_I08_I08_I08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 & op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 | op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_OR_I08_I08_I08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 | op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 ^ op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_XOR_I08_I08_I08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 ^ op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_NOT_I08_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = ~op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BW_NOT_I08_I08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I08_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I08_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = ~op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SHL_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_S08_S08_S08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 << op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_S08_S08_S08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 >> op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_I08_I32_ELV:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 >= segment_element_counts[selector1]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((int8_t *) segments[selector1]) + index1;
					}
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (op1_ptr) && (op1 != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_UNSET_I08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int8_t *) segment0) + index1;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I08_ELC:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elc_operand1, selector1, index1;
					
					elc_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I08_ELV:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					
					elv_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I08_ARR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					
					arr_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(res_start_index + res_count <= segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], res_start_index, res_count);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_MOV_S08_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_I16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int16_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S08_S08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = (int8_t) abs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_S08_S08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) abs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) abs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S08_S08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int8_t) abs(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_S08_S08_S08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_S08_S08_S08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = (int8_t) qb_rand_S64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_S08_S08_S08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = (int8_t) qb_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = (int8_t) qb_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (int8_t) qb_rand_S64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int8_t *) segment0) + index3;
					
					res = (int8_t) qb_mt_rand_S64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_S08_S08_S08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = (int8_t) qb_mt_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + index3;
					
					res = (int8_t) qb_mt_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (int8_t) qb_mt_rand_S64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_S08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId8, (int8_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_S08_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId8, (int8_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S08_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId8, (int8_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S08_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId8, (int8_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_S08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int8_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId8, (int8_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S08_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId8, (int8_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId8, (int8_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S08_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId8, (int8_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId8, (int8_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_S08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_S08(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_S08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_S08(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_S08_S08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = qb_calculate_array_min_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S08_S08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = qb_calculate_array_max_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S08_S08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = qb_calculate_array_product_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S08_S08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S08_S08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S08_S08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S08_S08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S08_S08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_I08_I08_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I08(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I08_I08_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I08(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I08_I08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I08(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I08_I08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_I08(op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I08_I08_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I08(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I08_I08_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I08(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I08_I08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I08(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I08_I08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_I08(op1_ptr, op1_count, op2_ptr, op2_count) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_IF_LT_U08_U08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_U08_U08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_U08_U08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U08_U08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_U08_U08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U08_U08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U08_U08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_U08_U08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U08_U08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U08_U08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_U08_U08_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U08_U08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_MUL_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint8_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_U08_U08_U08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint8_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_U08_U08_U08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint8_t *) segment0) + index3;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_U08_U08_U08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 % op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U08_U08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_U08_U08_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U08_U08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U08_U08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_U08(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U08_U08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_U08_U08_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U08_U08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U08_U08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_U08(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_U08_U08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_U08_U08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint8_t *) segment0) + index3;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_U08_U08_U08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 << op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint8_t *) segment0) + index3;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_U08_U08_U08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 >> op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_U08_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_I16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int16_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint8_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_U08_U08_U08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint8_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_U08_U08_U08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint8_t *) segment0) + index3;
					
					res = (uint8_t) qb_rand_U64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_U08_U08_U08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = (uint8_t) qb_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = (uint8_t) qb_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (uint8_t) qb_rand_U64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint8_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint8_t *) segment0) + index3;
					
					res = (uint8_t) qb_mt_rand_U64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_U08_U08_U08_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = (uint8_t) qb_mt_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + index3;
					
					res = (uint8_t) qb_mt_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint8_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint8_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (uint8_t) qb_mt_rand_U64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_STR_U08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					php_write(op1_ptr, op1_count TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_STR_U08_U08:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					res_count = res_count + op1_count;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_U08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu8, (uint8_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_U08_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu8, (uint8_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U08_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu8, (uint8_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U08_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu8, (uint8_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint8_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu8, (uint8_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U08_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu8, (uint8_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu8, (uint8_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U08_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint8_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu8, (uint8_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu8, (uint8_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_U08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_U08(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_U08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_U08(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint8_t *) segment0) + index2;
					
					res = qb_calculate_array_min_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint8_t *) segment0) + index2;
					
					res = qb_calculate_array_max_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint8_t *) segment0) + index2;
					
					res = qb_calculate_array_product_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint8_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U08_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U08_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U08_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U08_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_I16_I16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_I16_I16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_EQ_I16_I16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I16_I16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_I16_I16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I16_I16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S16_S16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_S16_S16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S16_S16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S16_S16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_S16_S16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S16_S16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S16_S16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_S16_S16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S16_S16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S16_S16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_S16_S16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S16_S16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_I16_I16_I16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 + op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_I16_I16_I16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 - op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_S16_S16_S16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_S16_S16_S16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_S16_S16_S16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 % op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_I16_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_I16_I16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I16_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I16_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = - op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I16_I16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_I16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int16_t *) segment0) + index1;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_I16_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I16_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I16_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						++res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int16_t *) segment0) + index1;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_I16_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I16_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I16_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						--res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_I16_I16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_I16_I16_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I16_I16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I16_I16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S16(op1_start, op1_end, op2_start, op2_end) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I16_I16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_I16_I16_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I16_I16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I16_I16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S16(op1_start, op1_end, op2_start, op2_end) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S16_S16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_S16_S16_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S16_S16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S16_S16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S16(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S16_S16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_S16_S16_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S16_S16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S16_S16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S16(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_I16_I16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 == op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_I16_I16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 != op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_S16_S16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_S16_S16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 & op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_AND_I16_I16_I16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 & op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 | op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_OR_I16_I16_I16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 | op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 ^ op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_XOR_I16_I16_I16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 ^ op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_NOT_I16_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = ~op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BW_NOT_I16_I16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I16_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I16_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = ~op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SHL_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_S16_S16_S16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 << op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_S16_S16_S16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 >> op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_I16_I32_ELV:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 >= segment_element_counts[selector1]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((int16_t *) segments[selector1]) + index1;
					}
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (op1_ptr) && (op1 != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_UNSET_I16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int16_t *) segment0) + index1;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I16_ELC:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elc_operand1, selector1, index1;
					
					elc_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I16_ELV:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					
					elv_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I16_ARR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					
					arr_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(res_start_index + res_count <= segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], res_start_index, res_count);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_MOV_S16_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S16_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I16_I08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int8_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S16_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S16_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S16_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S16_S16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = (int16_t) abs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_S16_S16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) abs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) abs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S16_S16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int16_t) abs(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_S16_S16_S16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_S16_S16_S16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = (int16_t) qb_rand_S64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_S16_S16_S16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = (int16_t) qb_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = (int16_t) qb_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (int16_t) qb_rand_S64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int16_t *) segment0) + index3;
					
					res = (int16_t) qb_mt_rand_S64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_S16_S16_S16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = (int16_t) qb_mt_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + index3;
					
					res = (int16_t) qb_mt_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (int16_t) qb_mt_rand_S64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_S16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId16, (int16_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_S16_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId16, (int16_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S16_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId16, (int16_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S16_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId16, (int16_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_S16_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId16, (int16_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S16_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId16, (int16_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S16_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId16, (int16_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S16_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId16, (int16_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId16, (int16_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I16_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((int16_t *) &res) = op1;
#else
					{
						int16_t v = op1;

						*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I16_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((int16_t *) &res) = op1;
#else
					{
						int16_t v = op1;

						*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I16_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((int16_t *) &res) = op1;
#else
					{
						int16_t v = op1;

						*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I16_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int16_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((int16_t *) &res) = op1;
#else
					{
						int16_t v = op1;

						*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I16_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((int16_t *) &res) = op1;
#else
					{
						int16_t v = op1;

						*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I16_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((int16_t *) &res) = op1;
#else
					{
						int16_t v = op1;

						*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((int16_t *) op1_ptr);
#else
					*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((int16_t *) op1_ptr);
#else
					*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((int16_t *) op1_ptr);
#else
					*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((int16_t *) op1_ptr);
#else
					*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((int16_t *) op1_ptr);
#else
					*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((int16_t *) op1_ptr);
#else
					*((uint16_t *) &res) = _byteswap_ushort(*((uint16_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_S16:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_S16(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_S16:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_S16(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_S16_S16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = qb_calculate_array_min_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S16_S16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = qb_calculate_array_max_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S16_S16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = qb_calculate_array_product_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S16_S16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S16_S16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S16_S16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S16_S16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S16_S16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_I16_I16_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I16(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I16_I16_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I16(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I16_I16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I16(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I16_I16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_I16(op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I16_I16_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I16(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I16_I16_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I16(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I16_I16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I16(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I16_I16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_I16(op1_ptr, op1_count, op2_ptr, op2_count) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_IF_LT_U16_U16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_U16_U16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_U16_U16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U16_U16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_U16_U16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U16_U16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U16_U16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_U16_U16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U16_U16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U16_U16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_U16_U16_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U16_U16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_MUL_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint16_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_U16_U16_U16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint16_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_U16_U16_U16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint16_t *) segment0) + index3;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_U16_U16_U16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 % op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U16_U16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_U16_U16_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U16_U16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U16_U16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_U16(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U16_U16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_U16_U16_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U16_U16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U16_U16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_U16(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_U16_U16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_U16_U16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint16_t *) segment0) + index3;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_U16_U16_U16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 << op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint16_t *) segment0) + index3;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_U16_U16_U16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 >> op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_U16_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U16_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U16_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U16_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U16_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint16_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_U16_U16_U16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint16_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_U16_U16_U16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint16_t *) segment0) + index3;
					
					res = (uint16_t) qb_rand_U64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_U16_U16_U16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = (uint16_t) qb_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = (uint16_t) qb_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (uint16_t) qb_rand_U64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint16_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint16_t *) segment0) + index3;
					
					res = (uint16_t) qb_mt_rand_U64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_U16_U16_U16_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = (uint16_t) qb_mt_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + index3;
					
					res = (uint16_t) qb_mt_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint16_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint16_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (uint16_t) qb_mt_rand_U64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_UTF8_DEC_U08_U16:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = qb_get_utf8_codepoint_count(cxt, op1_ptr, op1_count);
					if(string_length > res_count) {
						res_count = string_length;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + res_start_index;
					
					qb_decode_utf8_U16(cxt, op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UTF8_ENC_U16_U08:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = qb_get_utf8_encoded_length_U16(cxt, op1_ptr, op1_count);
					if(string_length > res_count) {
						res_count = string_length;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					qb_encode_utf8_U16(cxt, op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_U16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu16, (uint16_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_U16_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu16, (uint16_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U16_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu16, (uint16_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U16_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu16, (uint16_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_U16_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint16_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu16, (uint16_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U16_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu16, (uint16_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U16_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint16_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu16, (uint16_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U16_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint16_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu16, (uint16_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu16, (uint16_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_U16:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_U16(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_U16:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_U16(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_U16_U16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint16_t *) segment0) + index2;
					
					res = qb_calculate_array_min_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U16_U16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint16_t *) segment0) + index2;
					
					res = qb_calculate_array_max_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U16_U16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint16_t *) segment0) + index2;
					
					res = qb_calculate_array_product_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U16_U16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint16_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U16_U16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U16_U16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U16_U16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U16_U16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U16_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U16_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U16_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U16_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint16_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_I64_I64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_I64_I64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_EQ_I64_I64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I64_I64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_I64_I64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I64_I64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S64_S64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_S64_S64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S64_S64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S64_S64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_S64_S64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S64_S64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S64_S64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_S64_S64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S64_S64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S64_S64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_S64_S64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S64_S64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_I64_I64_I64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 + op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_I64_I64_I64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 - op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_S64_S64_S64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_S64_S64_S64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_S64_S64_S64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 % op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_I64_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_I64_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I64_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I64_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = - op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I64_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_I64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int64_t *) segment0) + index1;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_I64_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						++res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int64_t *) segment0) + index1;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_I64_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						--res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_I64_I64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_I64_I64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I64_I64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I64_I64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S64(op1_start, op1_end, op2_start, op2_end) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I64_I64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_I64_I64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I64_I64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I64_I64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S64(op1_start, op1_end, op2_start, op2_end) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S64_S64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_S64_S64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S64_S64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S64_S64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S64(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S64_S64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_S64_S64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S64_S64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S64_S64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_S64(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_I64_I64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 == op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_I64_I64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 != op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_S64_S64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_S64_S64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 & op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_AND_I64_I64_I64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 & op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 | op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_OR_I64_I64_I64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 | op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 ^ op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_XOR_I64_I64_I64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 ^ op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_NOT_I64_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = ~op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BW_NOT_I64_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I64_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I64_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = ~op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SHL_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_S64_S64_S64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 << op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_S64_S64_S64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 >> op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_I64_I32_ELV:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 >= segment_element_counts[selector1]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((int64_t *) segments[selector1]) + index1;
					}
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (op1_ptr) && (op1 != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_UNSET_I64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((int64_t *) segment0) + index1;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I64_ELC:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elc_operand1, selector1, index1;
					
					elc_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I64_ELV:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					
					elv_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I64_ARR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					
					arr_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(res_start_index + res_count <= segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], res_start_index, res_count);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_MOV_I64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I64_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I64_I08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int8_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I64_I16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int16_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S64_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S64_S64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = (int64_t) llabs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_S64_S64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) llabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) llabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S64_S64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) llabs(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_S64_S64_S64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_S64_S64_S64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = (int64_t) qb_rand_S64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_S64_S64_S64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = (int64_t) qb_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = (int64_t) qb_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) qb_rand_S64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int64_t *) segment0) + index3;
					
					res = (int64_t) qb_mt_rand_S64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_S64_S64_S64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = (int64_t) qb_mt_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + index3;
					
					res = (int64_t) qb_mt_rand_S64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) qb_mt_rand_S64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_S64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId64, (int64_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_S64_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId64, (int64_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId64, (int64_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId64, (int64_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_S64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId64, (int64_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S64_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId64, (int64_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId64, (int64_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S64_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((int64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId64, (int64_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRId64, (int64_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((int64_t *) &res) = op1;
#else
					{
						int64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I64_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((int64_t *) &res) = op1;
#else
					{
						int64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((int64_t *) &res) = op1;
#else
					{
						int64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((int64_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((int64_t *) &res) = op1;
#else
					{
						int64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I64_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((int64_t *) &res) = op1;
#else
					{
						int64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((int64_t *) &res) = op1;
#else
					{
						int64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((int64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((int64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((int64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((int64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((int64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((int64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_S64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_S64(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_S64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_S64(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_S64_S64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = qb_calculate_array_min_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S64_S64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = qb_calculate_array_max_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S64_S64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = qb_calculate_array_product_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S64_S64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S64_S64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S64_S64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S64_S64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S64_S64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_I64_I64_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I64(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I64_I64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I64(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I64_I64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I64(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I64_I64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_I64(op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I64_I64_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I64(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I64_I64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I64(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I64_I64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_I64(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I64_I64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					int64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_I64(op1_ptr, op1_count, op2_ptr, op2_count) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_IF_LT_U64_U64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_U64_U64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_U64_U64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U64_U64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_U64_U64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U64_U64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U64_U64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_U64_U64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U64_U64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U64_U64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_U64_U64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U64_U64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_MUL_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint64_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_U64_U64_U64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint64_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_U64_U64_U64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint64_t *) segment0) + index3;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_U64_U64_U64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 % op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U64_U64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_U64_U64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U64_U64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U64_U64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_U64(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U64_U64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_U64_U64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U64_U64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U64_U64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_U64(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_U64_U64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_U64_U64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint64_t *) segment0) + index3;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_U64_U64_U64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 << op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint64_t *) segment0) + index3;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_U64_U64_U64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 >> op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_U64_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U64_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U64_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U64_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint64_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_U64_U64_U64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint64_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_U64_U64_U64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint64_t *) segment0) + index3;
					
					res = (uint64_t) qb_rand_U64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_U64_U64_U64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = (uint64_t) qb_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = (uint64_t) qb_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (uint64_t) qb_rand_U64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((uint64_t *) segment0) + index3;
					
					res = (uint64_t) qb_mt_rand_U64(cxt, op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_U64_U64_U64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = (uint64_t) qb_mt_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + index3;
					
					res = (uint64_t) qb_mt_rand_U64(cxt, op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					uint64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((uint64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (uint64_t) qb_mt_rand_U64(cxt, op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_U64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu64, (uint64_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_U64_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu64, (uint64_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu64, (uint64_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu64, (uint64_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_U64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint64_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu64, (uint64_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U64_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu64, (uint64_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					uint64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu64, (uint64_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U64_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((uint64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu64, (uint64_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%" PRIu64, (uint64_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_U64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_U64(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_U64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_U64(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_U64_U64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint64_t *) segment0) + index2;
					
					res = qb_calculate_array_min_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U64_U64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint64_t *) segment0) + index2;
					
					res = qb_calculate_array_max_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U64_U64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint64_t *) segment0) + index2;
					
					res = qb_calculate_array_product_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U64_U64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint64_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U64_U64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U64_U64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U64_U64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U64_U64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_F32_F32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_EQ_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_F32_F32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_F32_F32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_F32_F32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_F32_F32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_F32_F32_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 + op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 - op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = (float32_t) fmod(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) fmod(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) fmod(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) fmod(op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_FLR_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = (float32_t) (op1 - op2 * floor(op1 / op2));
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_FLR_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) (op1 - op2 * floor(op1 / op2));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_FLR_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) (op1 - op2 * floor(op1 / op2));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_FLR_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) (op1 - op2 * floor(op1 / op2));
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = - op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((float32_t *) segment0) + index1;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_F32_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_F32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						++res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((float32_t *) segment0) + index1;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_F32_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						--res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_F32_F32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_F32(op1_start, op1_end, op2_start, op2_end) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_F32_F32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_F32(op1_start, op1_end, op2_start, op2_end) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_F32_F32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_F32(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_F32_F32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_F32(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_F32_F32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 == op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_F32_F32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 != op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_F32_F32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_F32_F32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_F32_I32_ELV:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 >= segment_element_counts[selector1]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((float32_t *) segments[selector1]) + index1;
					}
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (op1_ptr) && (op1 != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_UNSET_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((float32_t *) segment0) + index1;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_F32_ELC:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elc_operand1, selector1, index1;
					
					elc_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_F32_ELV:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					
					elv_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_F32_ARR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					
					arr_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(res_start_index + res_count <= segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], res_start_index, res_count);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_MOV_F32_S32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_S32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint32_t *) segment0) + index2;
					
					res = (uint32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_U32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = (uint32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = (uint32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (uint32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_S08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int8_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint8_t *) segment0) + index2;
					
					res = (uint8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = (uint8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = (uint8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (uint8_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_S16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int16_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint16_t *) segment0) + index2;
					
					res = (uint16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_U16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = (uint16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = (uint16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (uint16_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_S64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint64_t *) segment0) + index2;
					
					res = (uint64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_U64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = (uint64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = (uint64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (uint64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) fabs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) fabs(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SIN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) sin(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SIN_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) sin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) sin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) sin(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) asin(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ASIN_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) asin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) asin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) asin(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) cos(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_COS_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) cos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) cos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) cos(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) acos(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ACOS_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) acos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) acos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) acos(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) tan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_TAN_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) tan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) tan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) tan(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) atan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ATAN_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) atan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) atan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) atan(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN2_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = (float32_t) atan2(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ATAN2_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) atan2(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ATAN2_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) atan2(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ATAN2_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) atan2(op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SINH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) sinh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SINH_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) sinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SINH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) sinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SINH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) sinh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) asinh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ASINH_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) asinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) asinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) asinh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) cosh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_COSH_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) cosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) cosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) cosh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) acosh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ACOSH_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) acosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) acosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) acosh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) tanh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_TANH_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) tanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) tanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) tanh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) atanh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ATANH_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) atanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) atanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) atanh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) ceil(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_CEIL_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) ceil(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) ceil(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) ceil(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) floor(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FLOOR_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) floor(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ROUND_F32_I32_I32_F32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_4 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_4 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_4 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((int32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_4 *) instruction_pointer)->operand4;
					index4 = var_operand4;
					res_ptr = ((float32_t *) segment0) + index4;
					
					res = (float32_t) _php_math_round(op1, op2, op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_ROUND_F32_I32_I32_F32_ELC:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + index4;
					
					res = (float32_t) _php_math_round(op1, op2, op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ROUND_F32_I32_I32_F32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + index4;
					
					res = (float32_t) _php_math_round(op1, op2, op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ROUND_F32_I32_I32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t op3_start_index, op3_count;
					int32_t *op3_start, *op3_end, *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index3];
					op3_count = ((uint32_t *) segment0)[size_index3];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], op3_start_index + op3_count - 1, PHP_LINE_NUMBER);
					}
					op3_ptr = op3_start = ((int32_t *) segments[selector3]) + op3_start_index;
					op3_end = op3_ptr + op3_count;
					
					arr_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index4];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index4];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(segment_expandable[selector4]) {
						if(res_start_index + res_count > segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0 && op3_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) _php_math_round(op1, op2, op3);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							op3_ptr++;
							if(op3_ptr == op3_end) {
								op3_ptr = op3_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_LOG_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) log(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) log(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) log(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) log(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) log1p(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG1P_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) log1p(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) log1p(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) log1p(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) log2(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG2_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) log2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) log2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) log2(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) log10(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG10_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) log10(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) log10(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) log10(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) exp(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXP_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) exp(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) exp(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) exp(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) expm1(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXPM1_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) expm1(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) expm1(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) expm1(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) exp2(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXP2_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) exp2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) exp2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) exp2(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_POW_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = (float32_t) pow(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_POW_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) pow(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_POW_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) pow(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_POW_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) pow(op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SQRT_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) sqrt(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SQRT_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) sqrt(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SQRT_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) sqrt(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SQRT_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) sqrt(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_HYPOT_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = (float32_t) hypot(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_HYPOT_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) hypot(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_HYPOT_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) hypot(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_HYPOT_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) hypot(op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LCG_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((float32_t *) segment0) + index1;
					
					res = (float32_t) php_combined_lcg(TSRMLS_C);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_LCG_F32_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + index1;
					
					res = (float32_t) php_combined_lcg(TSRMLS_C);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_LCG_F32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + index1;
					
					res = (float32_t) php_combined_lcg(TSRMLS_C);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_LCG_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						res = (float32_t) php_combined_lcg(TSRMLS_C);
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_FIN_F32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = zend_finite(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FIN_F32_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = zend_finite(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FIN_F32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = zend_finite(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FIN_F32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = zend_finite(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (zend_isinf(op1) != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_INF_F32_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (zend_isinf(op1) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (zend_isinf(op1) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (zend_isinf(op1) != 0);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = zend_isnan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NAN_F32_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = zend_isnan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = zend_isnan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = zend_isnan(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ISQRT_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) (1 / sqrt(op1));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ISQRT_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (1 / sqrt(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ISQRT_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) (1 / sqrt(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ISQRT_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) (1 / sqrt(op1));
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CLAMP_F32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_4 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_4 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_4 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((float32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_4 *) instruction_pointer)->operand4;
					index4 = var_operand4;
					res_ptr = ((float32_t *) segment0) + index4;
					
					if(op3 < op1) {
						res = op1;
					} else if(op3 > op2) {
						res = op2;
					} else {
						res = op3;
					}
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_CLAMP_F32_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + index4;
					
					if(op3 < op1) {
						res = op1;
					} else if(op3 > op2) {
						res = op2;
					} else {
						res = op3;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_CLAMP_F32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + index4;
					
					if(op3 < op1) {
						res = op1;
					} else if(op3 > op2) {
						res = op2;
					} else {
						res = op3;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_CLAMP_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t op3_start_index, op3_count;
					float32_t *op3_start, *op3_end, *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index3];
					op3_count = ((uint32_t *) segment0)[size_index3];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], op3_start_index + op3_count - 1, PHP_LINE_NUMBER);
					}
					op3_ptr = op3_start = ((float32_t *) segments[selector3]) + op3_start_index;
					op3_end = op3_ptr + op3_count;
					
					arr_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index4];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index4];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(segment_expandable[selector4]) {
						if(res_start_index + res_count > segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0 && op3_count != 0) {
						while(res_ptr != res_end) {
							if(op3 < op1) {
								res = op1;
							} else if(op3 > op2) {
								res = op2;
							} else {
								res = op3;
							}
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							op3_ptr++;
							if(op3_ptr == op3_end) {
								op3_ptr = op3_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_FRACT_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = op1 - (float32_t) floor(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FRACT_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = op1 - (float32_t) floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FRACT_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = op1 - (float32_t) floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FRACT_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = op1 - (float32_t) floor(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIX_F32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_4 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_4 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_4 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((float32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_4 *) instruction_pointer)->operand4;
					index4 = var_operand4;
					res_ptr = ((float32_t *) segment0) + index4;
					
					res = (float32_t) (op1 * (1.0 - op3) + op2 * op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MIX_F32_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + index4;
					
					res = (float32_t) (op1 * (1.0 - op3) + op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MIX_F32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + index4;
					
					res = (float32_t) (op1 * (1.0 - op3) + op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MIX_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t op3_start_index, op3_count;
					float32_t *op3_start, *op3_end, *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index3];
					op3_count = ((uint32_t *) segment0)[size_index3];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], op3_start_index + op3_count - 1, PHP_LINE_NUMBER);
					}
					op3_ptr = op3_start = ((float32_t *) segments[selector3]) + op3_start_index;
					op3_end = op3_ptr + op3_count;
					
					arr_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index4];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index4];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(segment_expandable[selector4]) {
						if(res_start_index + res_count > segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0 && op3_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) (op1 * (1.0 - op3) + op2 * op3);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							op3_ptr++;
							if(op3_ptr == op3_end) {
								op3_ptr = op3_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SIGN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					if(op1 < 0) {
						res = -1;
					} else if(op1 > 0) {
						res = 1;
					} else {
						res = 0;
					}
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SIGN_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					if(op1 < 0) {
						res = -1;
					} else if(op1 > 0) {
						res = 1;
					} else {
						res = 0;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIGN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					if(op1 < 0) {
						res = -1;
					} else if(op1 > 0) {
						res = 1;
					} else {
						res = 0;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIGN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							if(op1 < 0) {
								res = -1;
							} else if(op1 > 0) {
								res = 1;
							} else {
								res = 0;
							}
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_STEP_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = (float32_t) ((op2 < op1) ? 0 : 1);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_STEP_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) ((op2 < op1) ? 0 : 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_STEP_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) ((op2 < op1) ? 0 : 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_STEP_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) ((op2 < op1) ? 0 : 1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SSTEP_F32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_4 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_4 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_4 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((float32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_4 *) instruction_pointer)->operand4;
					index4 = var_operand4;
					res_ptr = ((float32_t *) segment0) + index4;
					
					if(op3 <= op1) {
						res = 0;
					} else if(op3 >= op2) {
						res = 1;
					} else {
						float32_t value = (op3 - op1) / (op2 - op1);
						res = value * value * (3 - 2 * value);
					}
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_SSTEP_F32_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + index4;
					
					if(op3 <= op1) {
						res = 0;
					} else if(op3 >= op2) {
						res = 1;
					} else {
						float32_t value = (op3 - op1) / (op2 - op1);
						res = value * value * (3 - 2 * value);
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SSTEP_F32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + index4;
					
					if(op3 <= op1) {
						res = 0;
					} else if(op3 >= op2) {
						res = 1;
					} else {
						float32_t value = (op3 - op1) / (op2 - op1);
						res = value * value * (3 - 2 * value);
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SSTEP_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t op3_start_index, op3_count;
					float32_t *op3_start, *op3_end, *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index3];
					op3_count = ((uint32_t *) segment0)[size_index3];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], op3_start_index + op3_count - 1, PHP_LINE_NUMBER);
					}
					op3_ptr = op3_start = ((float32_t *) segments[selector3]) + op3_start_index;
					op3_end = op3_ptr + op3_count;
					
					arr_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index4];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index4];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(segment_expandable[selector4]) {
						if(res_start_index + res_count > segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector4]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0 && op3_count != 0) {
						while(res_ptr != res_end) {
							if(op3 <= op1) {
								res = 0;
							} else if(op3 >= op2) {
								res = 1;
							} else {
								float32_t value = (op3 - op1) / (op2 - op1);
								res = value * value * (3 - 2 * value);
							}
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							op3_ptr++;
							if(op3_ptr == op3_end) {
								op3_ptr = op3_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_RAD2DEG_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) ((op1 / M_PI) * 180);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_RAD2DEG_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) ((op1 / M_PI) * 180);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RAD2DEG_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) ((op1 / M_PI) * 180);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RAD2DEG_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) ((op1 / M_PI) * 180);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) ((op1 / 180.0) * M_PI);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_DEG2RAD_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) ((op1 / 180.0) * M_PI);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) ((op1 / 180.0) * M_PI);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) ((op1 / 180.0) * M_PI);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision / 2, (float32_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_F32_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision / 2, (float32_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_F32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision / 2, (float32_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision / 2, (float32_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_F32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision / 2, (float32_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F32_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision / 2, (float32_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision / 2, (float32_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F32_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float32_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision / 2, (float32_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision / 2, (float32_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_F32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((float32_t *) &res) = op1;
#else
					{
						float32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_F32_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((float32_t *) &res) = op1;
#else
					{
						float32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_F32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((float32_t *) &res) = op1;
#else
					{
						float32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float32_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((float32_t *) &res) = op1;
#else
					{
						float32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F32_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((float32_t *) &res) = op1;
#else
					{
						float32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((float32_t *) &res) = op1;
#else
					{
						float32_t v = op1;

						*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((float32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((float32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((float32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((float32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((float32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((float32_t *) op1_ptr);
#else
					*((uint32_t *) &res) = _byteswap_ulong(*((uint32_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_F32(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_F32(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = qb_calculate_array_min_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = qb_calculate_array_max_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = qb_calculate_array_product_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F32(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F32_F32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F32(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F32(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_F32(op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F32(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F32_F32_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F32(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F32(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_F32(op1_ptr, op1_count, op2_ptr, op2_count) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SAMPLE_NN_F32_U32_U32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float32_t *__restrict op4_ptr;
					
					uint32_t var_operand5, index5;
					float32_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					index4 = var_operand4;
					op4_ptr = ((float32_t *) segment0) + index4;
					
					var_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					index5 = var_operand5;
					op5_ptr = ((float32_t *) segment0) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector6]) + res_start_index;
					
					qb_sample_nearest_F32(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_F32_U32_U32_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float32_t *__restrict op4_ptr;
					
					uint32_t elc_operand5, selector5, index5;
					float32_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector4]) + index4;
					
					elc_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					selector5 = elc_operand5 & 0x00FF;
					index5 = elc_operand5 >> 8;
					if(UNEXPECTED(index5 >= segment_element_counts[selector5])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector5], index5, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector5]) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector6]) + res_start_index;
					
					qb_sample_nearest_F32(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_F32_U32_U32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float32_t *__restrict op4_ptr;
					
					uint32_t elv_operand5, selector5, index_selector5, index_index5, index5;
					float32_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector4]) + index4;
					
					elv_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					selector5 = elv_operand5 & 0x00FF;
					index_selector5 = (elv_operand5 >> 8) & 0x00FF;
					index_index5 = elv_operand5 >> 16;
					index5 = ((uint32_t *) segments[index_selector5])[index_index5];
					if(UNEXPECTED(index5 >= segment_element_counts[selector5])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector5], index5, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector5]) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector6]) + res_start_index;
					
					qb_sample_nearest_F32(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_F32_U32_U32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float32_t *__restrict op4_ptr;
					
					uint32_t var_operand5, index5;
					float32_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					index4 = var_operand4;
					op4_ptr = ((float32_t *) segment0) + index4;
					
					var_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					index5 = var_operand5;
					op5_ptr = ((float32_t *) segment0) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector6]) + res_start_index;
					
					qb_sample_bilinear_F32(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_F32_U32_U32_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float32_t *__restrict op4_ptr;
					
					uint32_t elc_operand5, selector5, index5;
					float32_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector4]) + index4;
					
					elc_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					selector5 = elc_operand5 & 0x00FF;
					index5 = elc_operand5 >> 8;
					if(UNEXPECTED(index5 >= segment_element_counts[selector5])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector5], index5, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector5]) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector6]) + res_start_index;
					
					qb_sample_bilinear_F32(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_F32_U32_U32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float32_t *__restrict op4_ptr;
					
					uint32_t elv_operand5, selector5, index_selector5, index_index5, index5;
					float32_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector4]) + index4;
					
					elv_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					selector5 = elv_operand5 & 0x00FF;
					index_selector5 = (elv_operand5 >> 8) & 0x00FF;
					index_index5 = elv_operand5 >> 16;
					index5 = ((uint32_t *) segments[index_selector5])[index_index5];
					if(UNEXPECTED(index5 >= segment_element_counts[selector5])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector5], index5, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector5]) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector6]) + res_start_index;
					
					qb_sample_bilinear_F32(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_MUL_MM_F32_U32_U32_F32_U32_U32_F32:
				op_handler = ((qb_instruction_7_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_7_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t op4_start_index, op4_count;
					float32_t *__restrict op4_ptr;
					
					uint32_t var_operand5, index5;
					uint32_t *__restrict op5_ptr;
					
					uint32_t var_operand6, index6;
					uint32_t *__restrict op6_ptr;
					
					uint32_t arr_operand7, selector7, index_index7, size_index7;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_7_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_7_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_7_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					arr_operand4 = ((qb_instruction_7_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index4];
					op4_count = ((uint32_t *) segment0)[size_index4];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], op4_start_index + op4_count - 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector4]) + op4_start_index;
					
					var_operand5 = ((qb_instruction_7_lineno *) instruction_pointer)->operand5;
					index5 = var_operand5;
					op5_ptr = ((uint32_t *) segment0) + index5;
					
					var_operand6 = ((qb_instruction_7_lineno *) instruction_pointer)->operand6;
					index6 = var_operand6;
					op6_ptr = ((uint32_t *) segment0) + index6;
					
					arr_operand7 = ((qb_instruction_7_lineno *) instruction_pointer)->operand7;
					selector7 = arr_operand7 & 0x00FF;
					index_index7 = (arr_operand7 >> 8) & 0x03FF;
					size_index7 = arr_operand7 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index7];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index7];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector7]) {
						if(res_start_index + res_count > segment_element_counts[selector7]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector7], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector7])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector7], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector7]) + res_start_index;
					
					if(op3 != op5) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Number of columns in first matrix (%d) does not match number of rows in second matrix (%d)", op3, op5);
					}
					qb_multiply_matrix_by_matrix_F32(cxt, op1_ptr, op2, op3, op4_ptr, op5, op6, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_7_lineno);
				break;
				
				case QB_MUL_MV_F32_U32_U32_F32_F32:
				op_handler = ((qb_instruction_5_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_5_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t op4_start_index, op4_count;
					float32_t *__restrict op4_ptr;
					
					uint32_t arr_operand5, selector5, index_index5, size_index5;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_5_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_5_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_5_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					arr_operand4 = ((qb_instruction_5_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index4];
					op4_count = ((uint32_t *) segment0)[size_index4];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], op4_start_index + op4_count - 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector4]) + op4_start_index;
					
					arr_operand5 = ((qb_instruction_5_lineno *) instruction_pointer)->operand5;
					selector5 = arr_operand5 & 0x00FF;
					index_index5 = (arr_operand5 >> 8) & 0x03FF;
					size_index5 = arr_operand5 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index5];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index5];
					if(op4_count > res_count) {
						res_count = op4_count;
					}
					if(segment_expandable[selector5]) {
						if(res_start_index + res_count > segment_element_counts[selector5]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector5], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector5])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector5], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector5]) + res_start_index;
					
					if(op3 != op4_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Number of columns in matrix (%d) does not match size of vector (%d)", op3, op4_count);
					}
					qb_multiply_matrix_by_vector_F32(cxt, op1_ptr, op2, op3, op4_ptr, op4_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_5_lineno);
				break;
				
				case QB_MUL_VM_F32_F32_U32_U32_F32:
				op_handler = ((qb_instruction_5_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_5_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					uint32_t *__restrict op4_ptr;
					
					uint32_t arr_operand5, selector5, index_index5, size_index5;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_5_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_5_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_5_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_5_lineno *) instruction_pointer)->operand4;
					index4 = var_operand4;
					op4_ptr = ((uint32_t *) segment0) + index4;
					
					arr_operand5 = ((qb_instruction_5_lineno *) instruction_pointer)->operand5;
					selector5 = arr_operand5 & 0x00FF;
					index_index5 = (arr_operand5 >> 8) & 0x03FF;
					size_index5 = arr_operand5 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index5];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index5];
					if(op4 > res_count) {
						res_count = op4;
					}
					if(segment_expandable[selector5]) {
						if(res_start_index + res_count > segment_element_counts[selector5]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector5], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector5])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector5], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector5]) + res_start_index;
					
					if(op3 != op1_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Number of rows in matrix (%d) does not match size of vector (%d)", op3, op1_count);
					}
					qb_multiply_vector_by_matrix_F32(cxt, op1_ptr, op1_count, op2_ptr, op3, op4, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_5_lineno);
				break;
				
				case QB_DOT_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_dot_product_F32(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_dot_product_F32(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_dot_product_F32(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = qb_calculate_array_length_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_array_distance_F32(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_array_distance_F32(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_array_distance_F32(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					
					qb_normalize_array_F32(cxt, op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MUL_MM_4X4_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(16 > res_count) {
						res_count = 16;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_matrix_4x4_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_4X4_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_vector_4x4_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_4X4_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_vector_by_matrix_4x4_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = qb_calculate_dot_product_4x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_4x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_4x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_4X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = qb_calculate_array_length_4x_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_4X_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_4x_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_4X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_4x_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_4X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = qb_calculate_array_distance_4x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_4X_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_4x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_4X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_4x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_4X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					
					qb_normalize_array_4x_F32(cxt, op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MUL_MM_3X3_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(9 > res_count) {
						res_count = 9;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_matrix_3x3_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_3X3_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(3 > res_count) {
						res_count = 3;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_vector_3x3_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_3X3_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(3 > res_count) {
						res_count = 3;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_vector_by_matrix_3x3_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_3X3P_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(12 > res_count) {
						res_count = 12;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_matrix_3x3_padded_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_3X3P_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(3 > res_count) {
						res_count = 3;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_vector_3x3_padded_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_3X3P_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(3 > res_count) {
						res_count = 3;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_vector_by_matrix_3x3_padded_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = qb_calculate_dot_product_3x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_3x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_3x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_3X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = qb_calculate_array_length_3x_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_3X_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_3x_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_3X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_3x_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_3X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = qb_calculate_array_distance_3x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_3X_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_3x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_3X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_3x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_3X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					
					qb_normalize_array_3x_F32(cxt, op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CROSS_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_calculate_cross_product_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_2X2_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_matrix_2x2_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_2X2_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_vector_2x2_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_2X2_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_vector_by_matrix_2x2_F32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = qb_calculate_dot_product_2x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_2x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_2x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_2X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = qb_calculate_array_length_2x_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_2X_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_2x_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_2X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_2x_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_2X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = qb_calculate_array_distance_2x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_2X_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_2x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_2X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_2x_F32(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_2X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					
					qb_normalize_array_2x_F32(cxt, op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_1X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_1X_F32_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_1X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DOT_1X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_1X_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_1X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_1X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float32_t *) segment0) + index3;
					
					res = (float32_t) fabs(op1 - op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_1X_F32_F32_F32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) fabs(op1 - op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_1X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector3]) + index3;
					
					res = (float32_t) fabs(op1 - op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_1X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float32_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					
					res = (float32_t) (op1 / fabs(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_F64_F64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_EQ_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_F64_F64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_F64_F64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_F64_F64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_F64_F64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					var_operand1 = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_F64_F64_ELC:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					elc_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					elv_operand1 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef ZEND_WIN32
					if(*windows_timed_out_pointer) {
						zend_timeout(1);
						goto label_exit;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 + op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 - op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 * op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = op1 / op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = fmod(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = fmod(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = fmod(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = fmod(op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_FLR_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = (float64_t) (op1 - op2 * floor(op1 / op2));
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_FLR_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) (op1 - op2 * floor(op1 / op2));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_FLR_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) (op1 - op2 * floor(op1 / op2));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_FLR_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) (op1 - op2 * floor(op1 / op2));
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = - op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((float64_t *) segment0) + index1;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_F64_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_F64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + index1;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						++res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((float64_t *) segment0) + index1;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_F64_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + index1;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						--res;
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_F64_F64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_F64(op1_start, op1_end, op2_start, op2_end) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_F64_F64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_F64(op1_start, op1_end, op2_start, op2_end) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_F64_F64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_F64(op1_start, op1_end, op2_start, op2_end) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_F64_F64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = (qb_compare_array_F64(op1_start, op1_end, op2_start, op2_end) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_F64_F64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 == op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_F64_F64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 != op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_F64_F64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_F64_F64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 <= op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_F64_I32_ELV:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 >= segment_element_counts[selector1]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((float64_t *) segments[selector1]) + index1;
					}
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (op1_ptr) && (op1 != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_UNSET_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((float64_t *) segment0) + index1;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_F64_ELC:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elc_operand1, selector1, index1;
					
					elc_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_F64_ELV:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					
					elv_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(index1 < segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], index1, 1);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_F64_ARR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					
					arr_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(res_start_index + res_count <= segment_element_counts[selector1]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector1], res_start_index, res_count);
					}
					
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_MOV_F64_S32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_S32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint32_t *) segment0) + index2;
					
					res = (uint32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_U32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = (uint32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					res = (uint32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (uint32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int8_t *) segment0) + index2;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_S08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + index2;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int8_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint8_t *) segment0) + index2;
					
					res = (uint8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = (uint8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + index2;
					
					res = (uint8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (uint8_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int16_t *) segment0) + index2;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_S16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + index2;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int16_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint16_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint16_t *) segment0) + index2;
					
					res = (uint16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_U16_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint16_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = (uint16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint16_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + index2;
					
					res = (uint16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint16_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (uint16_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int64_t *) segment0) + index2;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_S64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + index2;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (int64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((uint64_t *) segment0) + index2;
					
					res = (uint64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_U64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = (uint64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + index2;
					
					res = (uint64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (uint64_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float32_t *) segment0) + index2;
					
					res = (float32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_F32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + index2;
					
					res = (float32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float32_t) op1;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) fabs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) fabs(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 < op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (op1 > op2) ? op1 : op2;
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SIN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) sin(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SIN_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) sin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) sin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) sin(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) asin(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ASIN_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) asin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) asin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) asin(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) cos(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_COS_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) cos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) cos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) cos(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) acos(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ACOS_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) acos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) acos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) acos(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) tan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_TAN_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) tan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) tan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) tan(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) atan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ATAN_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) atan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) atan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) atan(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN2_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = (float64_t) atan2(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ATAN2_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) atan2(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ATAN2_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) atan2(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ATAN2_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) atan2(op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SINH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) sinh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SINH_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) sinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SINH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) sinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SINH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) sinh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) asinh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ASINH_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) asinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) asinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) asinh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) cosh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_COSH_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) cosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) cosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) cosh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) acosh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ACOSH_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) acosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) acosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) acosh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) tanh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_TANH_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) tanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) tanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) tanh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) atanh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ATANH_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) atanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) atanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) atanh(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) ceil(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_CEIL_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) ceil(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) ceil(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) ceil(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) floor(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FLOOR_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) floor(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ROUND_F64_I32_I32_F64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_4 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_4 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((int32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_4 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((int32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_4 *) instruction_pointer)->operand4;
					index4 = var_operand4;
					res_ptr = ((float64_t *) segment0) + index4;
					
					res = (float64_t) _php_math_round(op1, op2, op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_ROUND_F64_I32_I32_F64_ELC:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					int32_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + index4;
					
					res = (float64_t) _php_math_round(op1, op2, op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ROUND_F64_I32_I32_F64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					int32_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + index4;
					
					res = (float64_t) _php_math_round(op1, op2, op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ROUND_F64_I32_I32_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					int32_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t op3_start_index, op3_count;
					int32_t *op3_start, *op3_end, *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((int32_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index3];
					op3_count = ((uint32_t *) segment0)[size_index3];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], op3_start_index + op3_count - 1, PHP_LINE_NUMBER);
					}
					op3_ptr = op3_start = ((int32_t *) segments[selector3]) + op3_start_index;
					op3_end = op3_ptr + op3_count;
					
					arr_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index4];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index4];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(segment_expandable[selector4]) {
						if(res_start_index + res_count > segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0 && op3_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) _php_math_round(op1, op2, op3);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							op3_ptr++;
							if(op3_ptr == op3_end) {
								op3_ptr = op3_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_LOG_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) log(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) log(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) log(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) log(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) log1p(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG1P_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) log1p(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) log1p(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) log1p(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) log2(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG2_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) log2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) log2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) log2(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) log10(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG10_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) log10(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) log10(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) log10(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) exp(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXP_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) exp(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) exp(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) exp(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) expm1(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXPM1_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) expm1(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) expm1(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) expm1(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) exp2(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXP2_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) exp2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) exp2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) exp2(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_POW_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = (float64_t) pow(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_POW_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) pow(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_POW_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) pow(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_POW_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) pow(op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SQRT_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) sqrt(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SQRT_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) sqrt(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SQRT_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) sqrt(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SQRT_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) sqrt(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_HYPOT_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = (float64_t) hypot(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_HYPOT_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) hypot(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_HYPOT_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) hypot(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_HYPOT_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) hypot(op1, op2);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LCG_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					res_ptr = ((float64_t *) segment0) + index1;
					
					res = (float64_t) php_combined_lcg(TSRMLS_C);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_LCG_F64_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + index1;
					
					res = (float64_t) php_combined_lcg(TSRMLS_C);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_LCG_F64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(segment_expandable[selector1]) {
						if(index1 >= segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], index1 + 1);
						}
					} else {
						if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + index1;
					
					res = (float64_t) php_combined_lcg(TSRMLS_C);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_LCG_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + res_start_index;
					res_end = res_ptr + res_count;
					
					while(res_ptr != res_end) {
						res = (float64_t) php_combined_lcg(TSRMLS_C);
						res_ptr++;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_FIN_F64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = zend_finite(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FIN_F64_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = zend_finite(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FIN_F64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = zend_finite(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FIN_F64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = zend_finite(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = (zend_isinf(op1) != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_INF_F64_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (zend_isinf(op1) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = (zend_isinf(op1) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (zend_isinf(op1) != 0);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					int32_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((int32_t *) segment0) + index2;
					
					res = zend_isnan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NAN_F64_I32_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					int32_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = zend_isnan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					int32_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + index2;
					
					res = zend_isnan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					int32_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = zend_isnan(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ISQRT_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) (1 / sqrt(op1));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ISQRT_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (1 / sqrt(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ISQRT_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) (1 / sqrt(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ISQRT_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) (1 / sqrt(op1));
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CLAMP_F64_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_4 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_4 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_4 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((float64_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_4 *) instruction_pointer)->operand4;
					index4 = var_operand4;
					res_ptr = ((float64_t *) segment0) + index4;
					
					if(op3 < op1) {
						res = op1;
					} else if(op3 > op2) {
						res = op2;
					} else {
						res = op3;
					}
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_CLAMP_F64_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + index4;
					
					if(op3 < op1) {
						res = op1;
					} else if(op3 > op2) {
						res = op2;
					} else {
						res = op3;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_CLAMP_F64_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + index4;
					
					if(op3 < op1) {
						res = op1;
					} else if(op3 > op2) {
						res = op2;
					} else {
						res = op3;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_CLAMP_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t op3_start_index, op3_count;
					float64_t *op3_start, *op3_end, *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index3];
					op3_count = ((uint32_t *) segment0)[size_index3];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], op3_start_index + op3_count - 1, PHP_LINE_NUMBER);
					}
					op3_ptr = op3_start = ((float64_t *) segments[selector3]) + op3_start_index;
					op3_end = op3_ptr + op3_count;
					
					arr_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index4];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index4];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(segment_expandable[selector4]) {
						if(res_start_index + res_count > segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0 && op3_count != 0) {
						while(res_ptr != res_end) {
							if(op3 < op1) {
								res = op1;
							} else if(op3 > op2) {
								res = op2;
							} else {
								res = op3;
							}
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							op3_ptr++;
							if(op3_ptr == op3_end) {
								op3_ptr = op3_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_FRACT_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = op1 - (float64_t) floor(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FRACT_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = op1 - (float64_t) floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FRACT_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = op1 - (float64_t) floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FRACT_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = op1 - (float64_t) floor(op1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIX_F64_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_4 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_4 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_4 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((float64_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_4 *) instruction_pointer)->operand4;
					index4 = var_operand4;
					res_ptr = ((float64_t *) segment0) + index4;
					
					res = (float64_t) (op1 * (1.0 - op3) + op2 * op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MIX_F64_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + index4;
					
					res = (float64_t) (op1 * (1.0 - op3) + op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MIX_F64_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + index4;
					
					res = (float64_t) (op1 * (1.0 - op3) + op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MIX_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t op3_start_index, op3_count;
					float64_t *op3_start, *op3_end, *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index3];
					op3_count = ((uint32_t *) segment0)[size_index3];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], op3_start_index + op3_count - 1, PHP_LINE_NUMBER);
					}
					op3_ptr = op3_start = ((float64_t *) segments[selector3]) + op3_start_index;
					op3_end = op3_ptr + op3_count;
					
					arr_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index4];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index4];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(segment_expandable[selector4]) {
						if(res_start_index + res_count > segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0 && op3_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) (op1 * (1.0 - op3) + op2 * op3);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							op3_ptr++;
							if(op3_ptr == op3_end) {
								op3_ptr = op3_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SIGN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					if(op1 < 0) {
						res = -1;
					} else if(op1 > 0) {
						res = 1;
					} else {
						res = 0;
					}
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SIGN_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					if(op1 < 0) {
						res = -1;
					} else if(op1 > 0) {
						res = 1;
					} else {
						res = 0;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIGN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					if(op1 < 0) {
						res = -1;
					} else if(op1 > 0) {
						res = 1;
					} else {
						res = 0;
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIGN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							if(op1 < 0) {
								res = -1;
							} else if(op1 > 0) {
								res = 1;
							} else {
								res = 0;
							}
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_STEP_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_3 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_3 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = (float64_t) ((op2 < op1) ? 0 : 1);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_STEP_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) ((op2 < op1) ? 0 : 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_STEP_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) ((op2 < op1) ? 0 : 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_STEP_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) ((op2 < op1) ? 0 : 1);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SSTEP_F64_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_4 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_4 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_4 *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((float64_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_4 *) instruction_pointer)->operand4;
					index4 = var_operand4;
					res_ptr = ((float64_t *) segment0) + index4;
					
					if(op3 <= op1) {
						res = 0;
					} else if(op3 >= op2) {
						res = 1;
					} else {
						float64_t value = (op3 - op1) / (op2 - op1);
						res = value * value * (3 - 2 * value);
					}
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_SSTEP_F64_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + index4;
					
					if(op3 <= op1) {
						res = 0;
					} else if(op3 >= op2) {
						res = 1;
					} else {
						float64_t value = (op3 - op1) / (op2 - op1);
						res = value * value * (3 - 2 * value);
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SSTEP_F64_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(segment_expandable[selector4]) {
						if(index4 >= segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], index4 + 1);
						}
					} else {
						if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + index4;
					
					if(op3 <= op1) {
						res = 0;
					} else if(op3 >= op2) {
						res = 1;
					} else {
						float64_t value = (op3 - op1) / (op2 - op1);
						res = value * value * (3 - 2 * value);
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SSTEP_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *op2_start, *op2_end, *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t op3_start_index, op3_count;
					float64_t *op3_start, *op3_end, *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_4_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_4_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = op2_start = ((float64_t *) segments[selector2]) + op2_start_index;
					op2_end = op2_ptr + op2_count;
					
					arr_operand3 = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index3];
					op3_count = ((uint32_t *) segment0)[size_index3];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], op3_start_index + op3_count - 1, PHP_LINE_NUMBER);
					}
					op3_ptr = op3_start = ((float64_t *) segments[selector3]) + op3_start_index;
					op3_end = op3_ptr + op3_count;
					
					arr_operand4 = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index4];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index4];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(segment_expandable[selector4]) {
						if(res_start_index + res_count > segment_element_counts[selector4]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector4], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector4])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector4], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector4]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0 && op2_count != 0 && op3_count != 0) {
						while(res_ptr != res_end) {
							if(op3 <= op1) {
								res = 0;
							} else if(op3 >= op2) {
								res = 1;
							} else {
								float64_t value = (op3 - op1) / (op2 - op1);
								res = value * value * (3 - 2 * value);
							}
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							op2_ptr++;
							if(op2_ptr == op2_end) {
								op2_ptr = op2_start;
							}
							op3_ptr++;
							if(op3_ptr == op3_end) {
								op3_ptr = op3_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_RAD2DEG_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) ((op1 / M_PI) * 180);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_RAD2DEG_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) ((op1 / M_PI) * 180);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RAD2DEG_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) ((op1 / M_PI) * 180);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RAD2DEG_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) ((op1 / M_PI) * 180);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					var_operand2 = ((qb_instruction_2 *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) ((op1 / 180.0) * M_PI);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_DEG2RAD_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) ((op1 / 180.0) * M_PI);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) ((op1 / 180.0) * M_PI);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *res_end, *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					res_end = res_ptr + res_count;
					
					if(op1_count != 0) {
						while(res_ptr != res_end) {
							res = (float64_t) ((op1 / 180.0) * M_PI);
							op1_ptr++;
							if(op1_ptr == op1_end) {
								op1_ptr = op1_start;
							}
							res_ptr++;
						}
					}
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1 *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision, (float64_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_F64_ELC:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					elc_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision, (float64_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_F64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					elv_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision, (float64_t) op1);
					php_write(sprintf_buffer, string_length TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_end, *__restrict op1_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					php_write("[", 1  TSRMLS_CC);
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision, (float64_t) op1);
						php_write(sprintf_buffer, string_length TSRMLS_CC);
						op1_ptr++;
						if(op1_ptr != op1_end) {
							php_write(", ", 2  TSRMLS_CC);
						}
					}
					php_write("]", 1  TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_F64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision, (float64_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F64_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision, (float64_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision, (float64_t) op1);
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, sprintf_buffer, string_length);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F64_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *op1_start, *op1_end, *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = op1_start = ((float64_t *) segments[selector1]) + op1_start_index;
					op1_end = op1_ptr + op1_count;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					string_length = 0;
					while(op1_ptr != op1_end) {
						string_length += snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision, (float64_t) op1) + 2;
						op1_ptr++;
					}
					res_count = res_count + string_length;
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
					op1_ptr = op1_start;
					res_ptr += res_count_before;
					*res_ptr = '[';
					res_ptr++;
					while(op1_ptr != op1_end) {
						string_length = snprintf(sprintf_buffer, sizeof(sprintf_buffer), "%.*G", cxt->floating_point_precision, (float64_t) op1);
						memcpy(res_ptr, sprintf_buffer, string_length);
						res_ptr += string_length;
						op1_ptr++;
						if(op1_ptr != op1_end) {
							*res_ptr = ',';
							res_ptr++;
							*res_ptr = ' ';
							res_ptr++;
						}
					}
					*res_ptr = ']';
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_F64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((float64_t *) &res) = op1;
#else
					{
						float64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_F64_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((float64_t *) &res) = op1;
#else
					{
						float64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_F64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_LITTLE_ENDIAN
					*((float64_t *) &res) = op1;
#else
					{
						float64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					var_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((float64_t *) segment0) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((float64_t *) &res) = op1;
#else
					{
						float64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F64_U08_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elc_operand1, selector1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elc_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elc_operand1 & 0x00FF;
					index1 = elc_operand1 >> 8;
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((float64_t *) &res) = op1;
#else
					{
						float64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t elv_operand1, selector1, index_selector1, index_index1, index1;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					uint8_t *__restrict res_ptr;
					
					elv_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = elv_operand1 & 0x00FF;
					index_selector1 = (elv_operand1 >> 8) & 0x00FF;
					index_index1 = elv_operand1 >> 16;
					index1 = ((uint32_t *) segments[index_selector1])[index_index1];
					if(UNEXPECTED(index1 >= segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], index1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + index1;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(8 > res_count) {
						res_count = 8;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector2]) + res_start_index;
					
#ifdef QB_BIG_ENDIAN
					*((float64_t *) &res) = op1;
#else
					{
						float64_t v = op1;

						*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) &v));
					}
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((float64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((float64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef QB_LITTLE_ENDIAN
					res = *((float64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((float64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((float64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					uint8_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
#ifdef QB_BIG_ENDIAN
					res = *((float64_t *) op1_ptr);
#else
					*((uint64_t *) &res) = _byteswap_uint64(*((uint64_t *) op1_ptr));
#endif
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + res_start_index;
					
					qb_sort_ascending_F64(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index1];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index1];
					if(segment_expandable[selector1]) {
						if(res_start_index + res_count > segment_element_counts[selector1]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector1], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector1])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector1], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector1]) + res_start_index;
					
					qb_sort_descending_F64(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = qb_calculate_array_min_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = qb_calculate_array_max_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = qb_calculate_array_product_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = qb_calculate_array_sum_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_min_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_max_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_product_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_sum_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F64(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F64_F64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F64(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F64(op1_ptr, op1_count, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_F64(op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((float64_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F64(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F64_F64_I32_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F64(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + index2;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_element_F64(op1_ptr, op1_count, op2) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					int32_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((int32_t *) segment0) + index3;
					
					res = qb_find_elements_F64(op1_ptr, op1_count, op2_ptr, op2_count) != -1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SAMPLE_NN_F64_U32_U32_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float64_t *__restrict op4_ptr;
					
					uint32_t var_operand5, index5;
					float64_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					index4 = var_operand4;
					op4_ptr = ((float64_t *) segment0) + index4;
					
					var_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					index5 = var_operand5;
					op5_ptr = ((float64_t *) segment0) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector6]) + res_start_index;
					
					qb_sample_nearest_F64(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_F64_U32_U32_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float64_t *__restrict op4_ptr;
					
					uint32_t elc_operand5, selector5, index5;
					float64_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector4]) + index4;
					
					elc_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					selector5 = elc_operand5 & 0x00FF;
					index5 = elc_operand5 >> 8;
					if(UNEXPECTED(index5 >= segment_element_counts[selector5])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector5], index5, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector5]) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector6]) + res_start_index;
					
					qb_sample_nearest_F64(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_F64_U32_U32_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float64_t *__restrict op4_ptr;
					
					uint32_t elv_operand5, selector5, index_selector5, index_index5, index5;
					float64_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector4]) + index4;
					
					elv_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					selector5 = elv_operand5 & 0x00FF;
					index_selector5 = (elv_operand5 >> 8) & 0x00FF;
					index_index5 = elv_operand5 >> 16;
					index5 = ((uint32_t *) segments[index_selector5])[index_index5];
					if(UNEXPECTED(index5 >= segment_element_counts[selector5])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector5], index5, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector5]) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector6]) + res_start_index;
					
					qb_sample_nearest_F64(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_F64_U32_U32_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					float64_t *__restrict op4_ptr;
					
					uint32_t var_operand5, index5;
					float64_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					index4 = var_operand4;
					op4_ptr = ((float64_t *) segment0) + index4;
					
					var_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					index5 = var_operand5;
					op5_ptr = ((float64_t *) segment0) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector6]) + res_start_index;
					
					qb_sample_bilinear_F64(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_F64_U32_U32_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t elc_operand4, selector4, index4;
					float64_t *__restrict op4_ptr;
					
					uint32_t elc_operand5, selector5, index5;
					float64_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elc_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					elc_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					selector4 = elc_operand4 & 0x00FF;
					index4 = elc_operand4 >> 8;
					if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector4]) + index4;
					
					elc_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					selector5 = elc_operand5 & 0x00FF;
					index5 = elc_operand5 >> 8;
					if(UNEXPECTED(index5 >= segment_element_counts[selector5])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector5], index5, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector5]) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector6]) + res_start_index;
					
					qb_sample_bilinear_F64(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_F64_U32_U32_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t elv_operand4, selector4, index_selector4, index_index4, index4;
					float64_t *__restrict op4_ptr;
					
					uint32_t elv_operand5, selector5, index_selector5, index_index5, index5;
					float64_t *__restrict op5_ptr;
					
					uint32_t arr_operand6, selector6, index_index6, size_index6;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_6_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector2]) + index2;
					
					elv_operand3 = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector3]) + index3;
					
					elv_operand4 = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					selector4 = elv_operand4 & 0x00FF;
					index_selector4 = (elv_operand4 >> 8) & 0x00FF;
					index_index4 = elv_operand4 >> 16;
					index4 = ((uint32_t *) segments[index_selector4])[index_index4];
					if(UNEXPECTED(index4 >= segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], index4, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector4]) + index4;
					
					elv_operand5 = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					selector5 = elv_operand5 & 0x00FF;
					index_selector5 = (elv_operand5 >> 8) & 0x00FF;
					index_index5 = elv_operand5 >> 16;
					index5 = ((uint32_t *) segments[index_selector5])[index_index5];
					if(UNEXPECTED(index5 >= segment_element_counts[selector5])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector5], index5, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector5]) + index5;
					
					arr_operand6 = ((qb_instruction_6_lineno *) instruction_pointer)->operand6;
					selector6 = arr_operand6 & 0x00FF;
					index_index6 = (arr_operand6 >> 8) & 0x03FF;
					size_index6 = arr_operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index6];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index6];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector6]) {
						if(res_start_index + res_count > segment_element_counts[selector6]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector6], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector6])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector6], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector6]) + res_start_index;
					
					qb_sample_bilinear_F64(cxt, op1_ptr, op2, op3, op4, op5, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_MUL_MM_F64_U32_U32_F64_U32_U32_F64:
				op_handler = ((qb_instruction_7_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_7_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t op4_start_index, op4_count;
					float64_t *__restrict op4_ptr;
					
					uint32_t var_operand5, index5;
					uint32_t *__restrict op5_ptr;
					
					uint32_t var_operand6, index6;
					uint32_t *__restrict op6_ptr;
					
					uint32_t arr_operand7, selector7, index_index7, size_index7;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_7_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_7_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_7_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					arr_operand4 = ((qb_instruction_7_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index4];
					op4_count = ((uint32_t *) segment0)[size_index4];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], op4_start_index + op4_count - 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector4]) + op4_start_index;
					
					var_operand5 = ((qb_instruction_7_lineno *) instruction_pointer)->operand5;
					index5 = var_operand5;
					op5_ptr = ((uint32_t *) segment0) + index5;
					
					var_operand6 = ((qb_instruction_7_lineno *) instruction_pointer)->operand6;
					index6 = var_operand6;
					op6_ptr = ((uint32_t *) segment0) + index6;
					
					arr_operand7 = ((qb_instruction_7_lineno *) instruction_pointer)->operand7;
					selector7 = arr_operand7 & 0x00FF;
					index_index7 = (arr_operand7 >> 8) & 0x03FF;
					size_index7 = arr_operand7 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index7];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index7];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector7]) {
						if(res_start_index + res_count > segment_element_counts[selector7]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector7], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector7])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector7], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector7]) + res_start_index;
					
					if(op3 != op5) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Number of columns in first matrix (%d) does not match number of rows in second matrix (%d)", op3, op5);
					}
					qb_multiply_matrix_by_matrix_F64(cxt, op1_ptr, op2, op3, op4_ptr, op5, op6, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_7_lineno);
				break;
				
				case QB_MUL_MV_F64_U32_U32_F64_F64:
				op_handler = ((qb_instruction_5_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_5_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					uint32_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t arr_operand4, selector4, index_index4, size_index4;
					uint32_t op4_start_index, op4_count;
					float64_t *__restrict op4_ptr;
					
					uint32_t arr_operand5, selector5, index_index5, size_index5;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_5_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_5_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					op2_ptr = ((uint32_t *) segment0) + index2;
					
					var_operand3 = ((qb_instruction_5_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					arr_operand4 = ((qb_instruction_5_lineno *) instruction_pointer)->operand4;
					selector4 = arr_operand4 & 0x00FF;
					index_index4 = (arr_operand4 >> 8) & 0x03FF;
					size_index4 = arr_operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index4];
					op4_count = ((uint32_t *) segment0)[size_index4];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector4])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector4], op4_start_index + op4_count - 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector4]) + op4_start_index;
					
					arr_operand5 = ((qb_instruction_5_lineno *) instruction_pointer)->operand5;
					selector5 = arr_operand5 & 0x00FF;
					index_index5 = (arr_operand5 >> 8) & 0x03FF;
					size_index5 = arr_operand5 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index5];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index5];
					if(op4_count > res_count) {
						res_count = op4_count;
					}
					if(segment_expandable[selector5]) {
						if(res_start_index + res_count > segment_element_counts[selector5]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector5], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector5])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector5], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector5]) + res_start_index;
					
					if(op3 != op4_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Number of columns in matrix (%d) does not match size of vector (%d)", op3, op4_count);
					}
					qb_multiply_matrix_by_vector_F64(cxt, op1_ptr, op2, op3, op4_ptr, op4_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_5_lineno);
				break;
				
				case QB_MUL_VM_F64_F64_U32_U32_F64:
				op_handler = ((qb_instruction_5_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_5_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					uint32_t *__restrict op3_ptr;
					
					uint32_t var_operand4, index4;
					uint32_t *__restrict op4_ptr;
					
					uint32_t arr_operand5, selector5, index_index5, size_index5;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_5_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_5_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_5_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					op3_ptr = ((uint32_t *) segment0) + index3;
					
					var_operand4 = ((qb_instruction_5_lineno *) instruction_pointer)->operand4;
					index4 = var_operand4;
					op4_ptr = ((uint32_t *) segment0) + index4;
					
					arr_operand5 = ((qb_instruction_5_lineno *) instruction_pointer)->operand5;
					selector5 = arr_operand5 & 0x00FF;
					index_index5 = (arr_operand5 >> 8) & 0x03FF;
					size_index5 = arr_operand5 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index5];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index5];
					if(op4 > res_count) {
						res_count = op4;
					}
					if(segment_expandable[selector5]) {
						if(res_start_index + res_count > segment_element_counts[selector5]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector5], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector5])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector5], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector5]) + res_start_index;
					
					if(op3 != op1_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Number of rows in matrix (%d) does not match size of vector (%d)", op3, op1_count);
					}
					qb_multiply_vector_by_matrix_F64(cxt, op1_ptr, op1_count, op2_ptr, op3, op4, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_5_lineno);
				break;
				
				case QB_DOT_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_dot_product_F64(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_dot_product_F64(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_dot_product_F64(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = qb_calculate_array_length_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_array_distance_F64(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_array_distance_F64(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					if(op1_count != op2_count) {
						*cxt->line_number_pointer = PHP_LINE_NUMBER;
						qb_abort("Size of first array (%d) does not match size of second array (%d)", op1_count, op2_count);
					}
					res = qb_calculate_array_distance_F64(cxt, op1_ptr, op2_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					
					qb_normalize_array_F64(cxt, op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MUL_MM_4X4_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(16 > res_count) {
						res_count = 16;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_matrix_4x4_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_4X4_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_vector_4x4_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_4X4_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_vector_by_matrix_4x4_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = qb_calculate_dot_product_4x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_4x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_4x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_4X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = qb_calculate_array_length_4x_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_4X_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_4x_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_4X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_4x_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_4X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = qb_calculate_array_distance_4x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_4X_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_4x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_4X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_4x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_4X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					
					qb_normalize_array_4x_F64(cxt, op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MUL_MM_3X3_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(9 > res_count) {
						res_count = 9;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_matrix_3x3_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_3X3_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(3 > res_count) {
						res_count = 3;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_vector_3x3_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_3X3_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(3 > res_count) {
						res_count = 3;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_vector_by_matrix_3x3_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_3X3P_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(12 > res_count) {
						res_count = 12;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_matrix_3x3_padded_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_3X3P_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(3 > res_count) {
						res_count = 3;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_vector_3x3_padded_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_3X3P_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(3 > res_count) {
						res_count = 3;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_vector_by_matrix_3x3_padded_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = qb_calculate_dot_product_3x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_3x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_3x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_3X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = qb_calculate_array_length_3x_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_3X_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_3x_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_3X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_3x_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_3X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = qb_calculate_array_distance_3x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_3X_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_3x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_3X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_3x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_3X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					
					qb_normalize_array_3x_F64(cxt, op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CROSS_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_calculate_cross_product_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_2X2_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(4 > res_count) {
						res_count = 4;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_matrix_2x2_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_2X2_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_matrix_by_vector_2x2_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_2X2_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t arr_operand3, selector3, index_index3, size_index3;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					arr_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = arr_operand3 & 0x00FF;
					index_index3 = (arr_operand3 >> 8) & 0x03FF;
					size_index3 = arr_operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index3];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index3];
					if(2 > res_count) {
						res_count = 2;
					}
					if(segment_expandable[selector3]) {
						if(res_start_index + res_count > segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + res_start_index;
					
					qb_multiply_vector_by_matrix_2x2_F64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = qb_calculate_dot_product_2x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_2x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_dot_product_2x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_2X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = qb_calculate_array_length_2x_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_2X_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_2x_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_2X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = qb_calculate_array_length_2x_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_2X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = qb_calculate_array_distance_2x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_2X_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_2x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_2X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = qb_calculate_array_distance_2x_F64(cxt, op1_ptr, op2_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_2X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					
					qb_normalize_array_2x_F64(cxt, op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_1X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t var_operand2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					var_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					index2 = var_operand2;
					res_ptr = ((float64_t *) segment0) + index2;
					
					res = (float64_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_1X_F64_F64_ELC:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elc_operand2, selector2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elc_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elc_operand2 & 0x00FF;
					index2 = elc_operand2 >> 8;
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_1X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t elv_operand2, selector2, index_selector2, index_index2, index2;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					elv_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = elv_operand2 & 0x00FF;
					index_selector2 = (elv_operand2 >> 8) & 0x00FF;
					index_index2 = elv_operand2 >> 16;
					index2 = ((uint32_t *) segments[index_selector2])[index_index2];
					if(segment_expandable[selector2]) {
						if(index2 >= segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], index2 + 1);
						}
					} else {
						if(UNEXPECTED(index2 >= segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], index2, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + index2;
					
					res = (float64_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DOT_1X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_1X_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_1X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_1X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t var_operand3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					var_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					index3 = var_operand3;
					res_ptr = ((float64_t *) segment0) + index3;
					
					res = (float64_t) fabs(op1 - op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_1X_F64_F64_F64_ELC:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elc_operand3, selector3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elc_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elc_operand3 & 0x00FF;
					index3 = elc_operand3 >> 8;
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) fabs(op1 - op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_1X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t op2_start_index, op2_count;
					float64_t *__restrict op2_ptr;
					
					uint32_t elv_operand3, selector3, index_selector3, index_index3, index3;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index2];
					op2_count = ((uint32_t *) segment0)[size_index2];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector2])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector2], op2_start_index + op2_count - 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector2]) + op2_start_index;
					
					elv_operand3 = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					selector3 = elv_operand3 & 0x00FF;
					index_selector3 = (elv_operand3 >> 8) & 0x00FF;
					index_index3 = elv_operand3 >> 16;
					index3 = ((uint32_t *) segments[index_selector3])[index_index3];
					if(segment_expandable[selector3]) {
						if(index3 >= segment_element_counts[selector3]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector3], index3 + 1);
						}
					} else {
						if(UNEXPECTED(index3 >= segment_element_counts[selector3])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector3], index3, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector3]) + index3;
					
					res = (float64_t) fabs(op1 - op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_1X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t arr_operand1, selector1, index_index1, size_index1;
					uint32_t op1_start_index, op1_count;
					float64_t *__restrict op1_ptr;
					
					uint32_t arr_operand2, selector2, index_index2, size_index2;
					uint32_t res_start_index, res_count, res_count_before;
					float64_t *__restrict res_ptr;
					
					arr_operand1 = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					selector1 = arr_operand1 & 0x00FF;
					index_index1 = (arr_operand1 >> 8) & 0x03FF;
					size_index1 = arr_operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index1];
					op1_count = ((uint32_t *) segment0)[size_index1];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector1])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector1], op1_start_index + op1_count - 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector1]) + op1_start_index;
					
					arr_operand2 = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					selector2 = arr_operand2 & 0x00FF;
					index_index2 = (arr_operand2 >> 8) & 0x03FF;
					size_index2 = arr_operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index2];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index2];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(segment_expandable[selector2]) {
						if(res_start_index + res_count > segment_element_counts[selector2]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector2], res_start_index + res_count);
						}
					} else {
						if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector2])) {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector2], res_start_index + res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector2]) + res_start_index;
					
					res = (float64_t) (op1 / fabs(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXT_U32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t var_operand1, index1;
					uint32_t *__restrict op1_ptr;
					
					var_operand1 = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					index1 = var_operand1;
					op1_ptr = ((uint32_t *) segment0) + index1;
					
					qb_run_zend_extension_op(cxt, op1, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				default:
				__assume(0);
			}
		} while(1);
		label_exit:
		{
			uint32_t i;
			// point the stack_ref pointer back to variables in the structure
			for(i = 0; i < cxt->storage->segment_count; i++) {
				qb_memory_segment *segment = &cxt->storage->segments[i];
				segment->stack_ref_memory = &segment->memory;
				segment->stack_ref_element_count = &segment->element_count;
			}
			return;
		}
	}
	
#undef op1
#undef op2
#undef op3
#undef op4
#undef op5
#undef op6
#undef res
}

